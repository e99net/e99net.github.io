{"meta":{"title":"99°","subtitle":null,"description":"记录一些备查的内容和个人成长过程中的感想，希望也能让你有所收获~~","author":"sqLiu","url":"https://e99net.github.io"},"pages":[{"title":"categories","date":"2018-04-11T14:38:46.000Z","updated":"2018-07-29T06:16:56.046Z","comments":false,"path":"categories/index.html","permalink":"https://e99net.github.io/categories/index.html","excerpt":"","keywords":null,"text":"","raw":null,"content":null},{"title":"Gists","date":"2018-07-29T06:17:14.861Z","updated":"2017-11-12T12:06:51.537Z","comments":true,"path":"gists/index.html","permalink":"https://e99net.github.io/gists/index.html","excerpt":"","keywords":null,"text":"vim emacs","raw":null,"content":null},{"title":"Open Source Projects","date":"2018-07-29T06:17:25.503Z","updated":"2017-11-12T12:02:36.097Z","comments":true,"path":"projects/index.html","permalink":"https://e99net.github.io/projects/index.html","excerpt":"","keywords":null,"text":"Here are my personal projects.","raw":null,"content":null},{"title":"Resume","date":"2020-03-15T05:36:26.139Z","updated":"2020-03-15T05:36:26.139Z","comments":true,"path":"resume/index.html","permalink":"https://e99net.github.io/resume/index.html","excerpt":"","keywords":null,"text":"简体中文 Options Emails are welcomed. It’s unfinished yet. I’m still working on it.","raw":null,"content":null},{"title":"简历","date":"2020-03-15T05:33:35.022Z","updated":"2020-03-15T05:33:35.022Z","comments":true,"path":"resume-cn/index.html","permalink":"https://e99net.github.io/resume-cn/index.html","excerpt":"","keywords":null,"text":"English 选项 欢迎来信 ( 电子邮件 )。","raw":null,"content":null},{"title":"","date":"2018-04-11T14:38:46.000Z","updated":"2018-05-09T02:53:54.266Z","comments":false,"path":"tags/index.html","permalink":"https://e99net.github.io/tags/index.html","excerpt":"","keywords":null,"text":"","raw":null,"content":null},{"title":"About","date":"2020-03-15T05:27:08.281Z","updated":"2020-03-15T05:27:08.281Z","comments":false,"path":"about/index.html","permalink":"https://e99net.github.io/about/index.html","excerpt":"","keywords":null,"text":"简体中文 Hi there, welcome to my blog 99 degree(99°).This is e99net(FlyHacker).I am a student, programming for interest. E-mail Blog Policy All the posts and blogs here are licensed under a Creative Commons Attribution-NonCommercial-NoDerivs 4.0 Generic License. Friends 影法師の物語","raw":null,"content":null},{"title":"关于","date":"2020-03-15T05:27:30.477Z","updated":"2020-03-15T05:27:30.477Z","comments":false,"path":"about-cn/index.html","permalink":"https://e99net.github.io/about-cn/index.html","excerpt":"","keywords":null,"text":"English 你好，欢迎来到我的博客「99度 (99°) 」，我是FlyHacker。我是一个学生，因兴趣而编程。 电子邮件 博客政策 所有这个网站的博客和文章都采用 知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议。 友情链接 影法師の物語","raw":null,"content":null}],"posts":[{"title":"Rust新手上路","slug":"NewbieOfRust","date":"2021-11-21T15:01:56.761Z","updated":"2021-11-21T15:39:56.873Z","comments":false,"path":"2021/11/21/NewbieOfRust/","link":"","permalink":"https://e99net.github.io/2021/11/21/NewbieOfRust/","excerpt":"rustup 环境变量配置 RUSTUP_HOME 后期包的累积可能会占用巨量的存储空间，设置此环境变量将存储的包放置在富裕的空间 下载源 加快下载速度，设置这两个环境变量后再运行rustup-init.exe 12RUSTUP_DIST_SERVER : https://mirrors.ustc.edu.cn/rust-staticRUSTUP_UPDATE_ROOT : https://mirrors.ustc.edu.cn/rust-static/rustup","keywords":null,"text":"rustup 环境变量配置 RUSTUP_HOME 后期包的累积可能会占用巨量的存储空间，设置此环境变量将存储的包放置在富裕的空间 下载源 加快下载速度，设置这两个环境变量后再运行rustup-init.exe 12RUSTUP_DIST_SERVER : https://mirrors.ustc.edu.cn/rust-staticRUSTUP_UPDATE_ROOT : https://mirrors.ustc.edu.cn/rust-static/rustup 安装指定日期版本的某个rust编译器 示例：下载2021年11月09日发布的channel为nightly的x86_64-unknown-linux-gnu编译器 1rustup default nightly-2021-11-10-x86_64-unknown-linux-gnu 注意：命令中的日期（上例是2021-11-10）比实际发布日期（2021-11-09）晚一天，即2021-11-09发布2021-11-10版本 列出目前已经安装过的工具链 1rustup toolchain list 卸载工具链 1rustup toolchain uninstall nightly 切换默认工具链 12rustup default nightly-x86_64-unknown-linux-gnurustup default nightly cargo 环境变量配置 CARGO_HOME 后期包的累积可能会占用巨量的存储空间，设置此环境变量将存储的包放置在富裕的空间 指定channel运行cargo命令 123cargo +nightly install ...cargo +nightly build ...cargo +nightly test ...","raw":null,"content":null,"categories":[{"name":"memo","slug":"memo","permalink":"https://e99net.github.io/categories/memo/"}],"tags":[{"name":"Rust","slug":"Rust","permalink":"https://e99net.github.io/tags/Rust/"}]},{"title":"总结LeetCode上石头游戏这一类型的几道题","slug":"LeetCode_StoneGame","date":"2021-11-21T07:27:01.406Z","updated":"2022-09-12T06:17:08.166Z","comments":false,"path":"2021/11/21/LeetCode_StoneGame/","link":"","permalink":"https://e99net.github.io/2021/11/21/LeetCode_StoneGame/","excerpt":"第一题LeetCode 877 Medium [ https://leetcode.com/problems/stone-game ] 描述： Alice 和 Bob 用几堆石子在做游戏。一共有偶数堆石子，排成一行；每堆都有 正 整数颗石子，数目为 piles[i] 。 游戏以谁手中的石子最多来决出胜负。石子的 总数 是 奇数 ，所以没有平局。 Alice 和 Bob 轮流进行，Alice 先开始 。 每回合，玩家从行的 开始 或 结束 处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中 石子最多 的玩家 获胜 。 假设 Alice 和 Bob 都发挥出最佳水平，当 Alice 赢得比赛时返回 true ，当 Bob 赢得比赛时返回 false 。","keywords":null,"text":"第一题LeetCode 877 Medium [ https://leetcode.com/problems/stone-game ] 描述： Alice 和 Bob 用几堆石子在做游戏。一共有偶数堆石子，排成一行；每堆都有 正 整数颗石子，数目为 piles[i] 。 游戏以谁手中的石子最多来决出胜负。石子的 总数 是 奇数 ，所以没有平局。 Alice 和 Bob 轮流进行，Alice 先开始 。 每回合，玩家从行的 开始 或 结束 处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中 石子最多 的玩家 获胜 。 假设 Alice 和 Bob 都发挥出最佳水平，当 Alice 赢得比赛时返回 true ，当 Bob 赢得比赛时返回 false 。 输入： 一个整数数组 输出： true 或 false 样例输入1： [5,3,4,5] 样例输出1： true 说明： Alice 先开始，只能拿前 5 颗或后 5 颗石子 。 假设他取了前 5 颗，这一行就变成了 [3,4,5] 。 如果 Bob 拿走前 3 颗，那么剩下的是 [4,5]，Alice 拿走后 5 颗赢得 10 分。 如果 Bob 拿走后 5 颗，那么剩下的是 [3,4]，Alice 拿走后 4 颗赢得 9 分。 这表明，取前 5 颗石子对 Alice 来说是一个胜利的举动，所以返回 true 。 样例输入2： [3,7,2,3] 样例输出2： true 数据范围 $2 &lt;= piles.length &lt;= 500$ $ 1 &lt;= piles[i] &lt;= 500 $ 解题思路： 解法一：DFS，用player变量区分轮到Alice还是Bob，分别递归调用取最左边那一堆和最右边那一堆的情况，石子全部取完后判断Alice总数是否大于Bob总数，是则赢，否则输。两种递归情况只要有一个返回true即可表示Alice能赢。 解法二：DP，用一个二维DP数组，dp[i][j]表示在区间[i, j]内Alice比Bob多拿的石子数，最后dp[0][n-1]大于0则表示Alice能赢。在区间[i, j]内分情况讨论：若Alice拿了piles[i]，那么dp[i+1][j]表示Bob比Alice多拿的石子数，piles[i]-dp[i+1][j]就是Alice比Bob多拿的石子数；若Alice拿了piles[j]，那么dp[i][j-1]表示Bob比Alice多拿的石子数，piles[j]-dp[i][j-1]就是Alice比Bob多拿的石子数。两种情况取最大值即可更新dp[i][j]，注意，这里的更新顺序是从小区间向大区间更新，初始化长度为1的区间dp[i][i]为piles[i]。 解法三：脑筋急转弯，因为总共有偶数堆石子，所以可以按奇偶分成堆数相等的两份，又因为石子总数为奇数，所以分成的两份的石子数一定不相等，总存在一份大于另一份。如果按奇数堆分的那一份大于按偶数堆分的那一份，那么Alice每次取奇数堆最后总会赢，反之，每次取偶数堆也总会赢。 参考代码: 代码1，DFS（现在已TLE） 12345678910111213141516class Solution &#123;public: bool stoneGame(vector&lt;int&gt;&amp; piles) &#123; return helper(piles, 0, 0, 0, (int)piles.size() - 1, 0); &#125; bool helper(vector&lt;int&gt;&amp; piles, int aliceNum, int bobNum, int left, int right, int player) &#123; if(left&gt;right) return aliceNum&gt;bobNum; if(player==0) &#123; //轮到Alice return helper(piles, aliceNum+piles[left], bobNum, left+1, right, 1) || helper(piles, aliceNum+piles[right], bobNum, left, right-1, 1); &#125; else &#123; //轮到Bob return helper(piles, aliceNum, bobNum+piles[left], left+1, right, 0) || helper(piles, aliceNum, bobNum+piles[right], left, right-1, 0); &#125; &#125;&#125;; 代码2，DP 1234567891011121314class Solution &#123;public: bool stoneGame(vector&lt;int&gt;&amp; piles) &#123; int n=piles.size(), dp[n][n]; for(int i=0;i&lt;n;i++) dp[i][i]=piles[i]; for(int len=1;len&lt;n;len++) &#123; for(int i=0;i&lt;n-len;i++) &#123; int j=i+len; dp[i][j]=max(piles[i]-dp[i+1][j], piles[j]-dp[i][j-1]); &#125; &#125; return dp[0][n-1]&gt;0; &#125;&#125;; 代码3，脑筋急转弯 123456class Solution &#123;public: bool stoneGame(vector&lt;int&gt;&amp; piles) &#123; return true; &#125;&#125;; 第二题LeetCode 1140 Medium [ https://leetcode.com/problems/stone-game-ii ] 描述： Alice 和 Bob 继续他们的石子游戏。许多堆石子 排成一行，每堆都有正整数颗石子 piles[i]。游戏以谁手中的石子最多来决出胜负。 Alice 和 Bob 轮流进行，Alice 先开始。最初，M = 1。 在每个玩家的回合中，该玩家可以拿走剩下的 前 X 堆的所有石子，其中 1 &lt;= X &lt;= 2M。然后，令 M = max(M, X)。 游戏一直持续到所有石子都被拿走。 假设 Alice 和 Bob 都发挥出最佳水平，返回 Alice 可以得到的最大数量的石头。 输入： 一个整数数组 输出： 一个整数 输入样例1： [2,7,9,4,4] 输出样例1： 10 说明： 如果一开始Alice取了一堆，Bob取了两堆，然后Alice再取两堆。爱丽丝可以得到2 + 4 + 4 = 10堆。如果Alice一开始拿走了两堆，那么Bob可以拿走剩下的三堆。在这种情况下，Alice得到2 + 7 = 9堆。返回10，因为它更大。 输入样例2： [1,2,3,4,5,100] 输出样例2： 104 数据范围： $ 1 &lt;= piles.length &lt;= 100 $ $ 1 &lt;= piles[i] &lt;= 10^4 $ 解题思路：动态规划 参考代码： 代码1，DP 12345678910111213141516171819202122class Solution &#123;public: int stoneGame(vector&lt;int&gt;&amp; piles) &#123; int n=piles.size(); vector&lt;int&gt; sums=piles; vector&lt;vector&lt;int&gt;&gt; dp(n+1, vector&lt;int&gt;(n+1)); for(int i=n-2;i&gt;=0;i--) &#123; sums[i]+=sums[i+1]; &#125; for(int i=0;i&lt;n;i++) &#123; dp[i][n]=sums[i]; &#125; for(int i=n-1;i&gt;=0;i--) &#123; for(int m=n-1;m&gt;=1;m--) &#123; for(int x=1;x&lt;=2*m &amp;&amp; i+x&lt;=n;++x) &#123; dp[i][m]=max(dp[i][m],sums[i]-dp[i+x][max(x,m)]); &#125; &#125; &#125; return dp[0][1]; &#125;&#125;; 代码2，带记忆数组的递归 12345678910111213141516171819202122class Solution &#123;public: int stoneGame(vector&lt;int&gt;&amp; piles) &#123; int n = piles.size(); vector&lt;int&gt; sums = piles; vector&lt;vector&lt;int&gt;&gt; memo(n, vector&lt;int&gt;(n)); for (int i = n - 2; i &gt;= 0; --i) &#123; sums[i] += sums[i + 1]; &#125; return helper(sums, 0, 1, memo); &#125; int helper(vector&lt;int&gt;&amp; sums, int i, int m, vector&lt;vector&lt;int&gt;&gt;&amp; memo) &#123; if (i + 2 * m &gt;= sums.size()) return sums[i]; if (memo[i][m] &gt; 0) return memo[i][m]; int res = 0; for (int x = 1; x &lt;= 2 * m; ++x) &#123; int cur = sums[i] - sums[i + x]; res = max(res, cur + sums[i + x] - helper(sums, i + x, max(x, m), memo)); &#125; return memo[i][m] = res; &#125;&#125;; 第三题LeetCode 1406 Hard [ https://leetcode.com/problems/stone-game-iii ] 描述： Alice 和 Bob 用几堆石子在做游戏。几堆石子排成一行，每堆石子都对应一个得分，由数组 stoneValue 给出。 Alice 和 Bob 轮流取石子，Alice 总是先开始。在每个玩家的回合中，该玩家可以拿走剩下石子中的的前 **1、2 或 3 堆石子 **。比赛一直持续到所有石头都被拿走。 每个玩家的最终得分为他所拿到的每堆石子的对应得分之和。每个玩家的初始分数都是 0 。比赛的目标是决出最高分，得分最高的选手将会赢得比赛，比赛也可能会出现平局。 假设 Alice 和 Bob 都采取 最优策略 。如果 Alice 赢了就返回 “Alice” ，Bob 赢了就返回 “Bob”，平局（分数相同）返回 “Tie” 。 输入： 一个整数数组 输出： “Bob” 或 “Alice” 或 “Tie” 输入样例1： [1,2,3,7] 输出样例1： “Bob” 说明： Alice 总是会输，她的最佳选择是拿走前三堆，得分变成 6 。但是 Bob 的得分为 7，Bob 获胜。 输入样例2： [1,2,3,-9] 输出样例2： “Alice” 说明： Alice 要想获胜就必须在第一个回合拿走前三堆石子，给 Bob 留下负分。 如果 Alice 只拿走第一堆，那么她的得分为 1，接下来 Bob 拿走第二、三堆，得分为 5 。之后 Alice 只能拿到分数 -9 的石子堆，输掉比赛。 如果 Alice 拿走前两堆，那么她的得分为 3，接下来 Bob 拿走第三堆，得分为 3 。之后 Alice 只能拿到分数 -9 的石子堆，同样会输掉比赛。 注意，他们都应该采取 最优策略 ，所以在这里 Alice 将选择能够使她获胜的方案。 输入样例3： [1,2,3,6] 输出样例3： “Tie” 说明： Alice 无法赢得比赛。如果她决定选择前三堆，她可以以平局结束比赛，否则她就会输。 输入样例4： [1,2,3,-1,-2,-3,7] 输出样例4： “Alice” 输入样例5： [-1,-2,-3] 输出样例5： “Tie” 数据范围： $ 1 &lt;= stoneValue.length &lt;= 50000 $ $ -1000 &lt;= stoneValue[i] &lt;= 1000 $ 解题思路： 参考代码： 1 第四题LeetCode 1510 Hard [ https://leetcode.com/problems/stone-game-iv ] 描述： Alice 和 Bob 两个人轮流玩一个游戏，Alice 先手。 一开始，有 n 个石子堆在一起。每个人轮流操作，正在操作的玩家可以从石子堆里拿走 任意 非零 平方数 个石子。 如果石子堆里没有石子了，则无法操作的玩家输掉游戏。 给你正整数 n ，且已知两个人都采取最优策略。如果 Alice 会赢得比赛，那么返回 true ，否则返回 false 。 输入： 一个整数 输出： true 或 false 输入样例1： 1 输出样例1： true 说明： Alice 拿走 1 个石子并赢得胜利，因为 Bob 无法进行任何操作。 输入样例2： 2 输出样例2： false 说明： Alice 只能拿走 1 个石子，然后 Bob 拿走最后一个石子并赢得胜利（2 -&gt; 1 -&gt; 0）。 输入样例3： 4 输出样例3： true 说明： n 已经是一个平方数，Alice 可以一次全拿掉 4 个石子并赢得胜利（4 -&gt; 0）。 输入样例4： 7 输出样例4： false 说明： 当 Bob 采取最优策略时，Alice 无法赢得比赛。 如果 Alice 一开始拿走 4 个石子， Bob 会拿走 1 个石子，然后 Alice 只能拿走 1 个石子，Bob 拿走最后一个石子并赢得胜利（7 -&gt; 3 -&gt; 2 -&gt; 1 -&gt; 0）。 如果 Alice 一开始拿走 1 个石子， Bob 会拿走 4 个石子，然后 Alice 只能拿走 1 个石子，Bob 拿走最后一个石子并赢得胜利（7 -&gt; 6 -&gt; 2 -&gt; 1 -&gt; 0）。 输入样例5： 17 输出样例5： false 说明： 如果 Bob 采取最优策略，Alice 无法赢得胜利。 数据范围： $ 1 &lt;= n &lt;= 10^5 $ 解题思路： 参考代码： 1 第五题LeetCode 1563 Hard [ https://leetcode.com/problems/stone-game-v ] 描述： 几块石子 排成一行 ，每块石子都有一个关联值，关联值为整数，由数组 stoneValue 给出。 游戏中的每一轮：Alice 会将这行石子分成两个 非空行（即，左侧行和右侧行）；Bob 负责计算每一行的值，即此行中所有石子的值的总和。Bob 会丢弃值最大的行，Alice 的得分为剩下那行的值（每轮累加）。如果两行的值相等，Bob 让 Alice 决定丢弃哪一行。下一轮从剩下的那一行开始。 只 剩下一块石子 时，游戏结束。Alice 的分数最初为 0 。 返回 Alice 能够获得的最大分数 。 输入： 一个整数数组 输出： 一个整数 输入样例1： [6,2,3,4,5,5] 输出样例1： 18 说明： 在第一轮中，Alice 将行划分为 [6，2，3]，[4，5，5] 。左行的值是 11 ，右行的值是 14 。Bob 丢弃了右行，Alice 的分数现在是 11 。 在第二轮中，Alice 将行分成 [6]，[2，3] 。这一次 Bob 扔掉了左行，Alice 的分数变成了 16（11 + 5）。 最后一轮 Alice 只能将行分成 [2]，[3] 。Bob 扔掉右行，Alice 的分数现在是 18（16 + 2）。游戏结束，因为这行只剩下一块石头了。 输入样例2： [7,7,7,7,7,7,7] 输出样例2： 28 输入样例3： [4] 输出样例3： 0 数据范围： $ 1 &lt;= stoneValue.length &lt;= 500 $ $ 1 &lt;= stoneValue[i] &lt;= 10^6 $ 解题思路：动态规划 参考代码： 1 第六题LeetCode 1686 Medium [ https://leetcode.com/problems/stone-game-vi ] 描述： Alice 和 Bob 轮流玩一个游戏，Alice 先手。 一堆石子里总共有 n 个石子，轮到某个玩家时，他可以 移出 一个石子并得到这个石子的价值。Alice 和 Bob 对石子价值有 不一样的的评判标准 。双方都知道对方的评判标准。 给你两个长度为 n 的整数数组 aliceValues 和 bobValues 。aliceValues[i] 和 bobValues[i] 分别表示 Alice 和 Bob 认为第 i 个石子的价值。 所有石子都被取完后，得分较高的人为胜者。如果两个玩家得分相同，那么为平局。两位玩家都会采用 最优策略 进行游戏。 请你推断游戏的结果，用如下的方式表示： 如果 Alice 赢，返回 1 。 如果 Bob 赢，返回 -1 。 如果游戏平局，返回 0 。 输入： 两个长度相等的整数数组 输出： 1 或 -1 或 0 输入样例1： [1,3] [2,1] 输出样例1： 1 说明： 如果 Alice 拿石子 1 （下标从 0开始），那么 Alice 可以得到 3 分。 Bob 只能选择石子 0 ，得到 2 分。 Alice 获胜。 输入样例2： [1,2] [3,1] 输出样例2： 0 说明： Alice 拿石子 0 ， Bob 拿石子 1 ，他们得分都为 1 分。 打平。 输入样例3： [2,4,3] [1,6,7] 输出样例3： -1 说明： 不管 Alice 怎么操作，Bob 都可以得到比 Alice 更高的得分。 比方说，Alice 拿石子 1 ，Bob 拿石子 2 ， Alice 拿石子 0 ，Alice 会得到 6 分而 Bob 得分为 7 分。 Bob 会获胜。 数据范围： $ 1 &lt;= n &lt;= 10^5 $ $ 1 &lt;= aliceValues[i], bobValues[i] &lt;= 100 $ 解题思路：动态规划 参考代码： 代码1 1 第七题LeetCode 1690 Medium [ https://leetcode.com/problems/stone-game-vii ] 描述： 石子游戏中，Alice 和 Bob 轮流进行自己的回合，Alice 先开始 。 有 n 块石子排成一排。每个玩家的回合中，可以从行中 移除 最左边的石头或最右边的石头，并获得与该行中剩余石头值之 和 相等的得分。当没有石头可移除时，得分较高者获胜。 Bob 发现他总是输掉游戏，所以他决定尽力 减小得分的差值 。爱丽丝的目标是最大限度地 扩大得分的差值 。 给你一个整数数组 stones ，其中 stones[i] 表示 从左边开始 的第 i 个石头的值，如果 Alice 和 Bob 都 发挥出最佳水平 ，请返回他们 得分的差值 。 输入： 一个整数数组 输出： 一个整数 输入样例1： [5,3,1,4,2] 输出样例1： 6 说明： 爱丽丝移除 2 ，得分 5 + 3 + 1 + 4 = 13 。游戏情况：爱丽丝 = 13 ，鲍勃 = 0 ，石子 = [5,3,1,4] 。 鲍勃移除 5 ，得分 3 + 1 + 4 = 8 。游戏情况：爱丽丝 = 13 ，鲍勃 = 8 ，石子 = [3,1,4] 。 爱丽丝移除 3 ，得分 1 + 4 = 5 。游戏情况：爱丽丝 = 18 ，鲍勃 = 8 ，石子 = [1,4] 。 鲍勃移除 1 ，得分 4 。游戏情况：爱丽丝 = 18 ，鲍勃 = 12 ，石子 = [4] 。 爱丽丝移除 4 ，得分 0 。游戏情况：爱丽丝 = 18 ，鲍勃 = 12 ，石子 = [] 。 得分的差值 18 - 12 = 6 。 输入样例2： [7,90,5,1,100,10,10,2] 输出样例2： 122 数据范围： $ 2 &lt;= n &lt;= 1000 $ $ 1 &lt;= stones[i] &lt;= 1000 $ 解题思路： 参考代码： 1 第八题LeetCode 1872 Hard [ https://leetcode.com/problems/stone-game-viii ] 描述： Alice 和 Bob 玩一个游戏，两人轮流操作， Alice 先手 。 总共有 n 个石子排成一行。轮到某个玩家的回合时，如果石子的数目 大于 1 ，他将执行以下操作： 选择一个整数 x &gt; 1 ，并且 移除 最左边的 x 个石子。 将 移除 的石子价值之 和 累加到该玩家的分数中。 将一个 新的石子 放在最左边，且新石子的值为被移除石子值之和。 当只剩下 一个 石子时，游戏结束。 Alice 和 Bob 的 分数之差 为 (Alice 的分数 - Bob 的分数) 。 Alice 的目标是 最大化 分数差，Bob 的目标是 最小化 分数差。 给你一个长度为 n 的整数数组 stones ，其中 stones[i] 是 从左边起 第 i 个石子的价值。请你返回在双方都采用 最优 策略的情况下，Alice 和 Bob 的 分数之差 。 输入： 一个整数数组 输出： 一个整数 输入样例1： [-1,2,-3,4,-5] 输出样例1： 5 说明： Alice 移除最左边的 4 个石子，得分增加 (-1) + 2 + (-3) + 4 = 2 ，并且将一个价值为 2 的石子放在最左边。stones = [2,-5] 。 Bob 移除最左边的 2 个石子，得分增加 2 + (-5) = -3 ，并且将一个价值为 -3 的石子放在最左边。stones = [-3] 。 两者分数之差为 2 - (-3) = 5 。 输入样例2： [7,-6,5,10,5,-2,-6] 输出样例2： 13 说明： Alice 移除所有石子，得分增加 7 + (-6) + 5 + 10 + 5 + (-2) + (-6) = 13 ，并且将一个价值为 13 的石子放在最左边。stones = [13] 。 两者分数之差为 13 - 0 = 13 。 输入样例3： [-10,-12] 输出样例3： -22 说明： Alice 只有一种操作，就是移除所有石子。得分增加 (-10) + (-12) = -22 ，并且将一个价值为 -22 的石子放在最左边。stones = [-22] 。 两者分数之差为 (-22) - 0 = -22 。 数据范围： $n == stones.length$ $2 &lt;= n &lt;= 10^5$ $-10^4 &lt;= stones[i] &lt;= 10^4$ 解题思路：动态规划+前缀和 首先要明白一点，不管是谁进行操作，数组的总和是不变的。 这里对玩家操作进行抽象，抽象成对前缀和数组进行操作，所以要预先计算出前缀和数组。一名玩家在石子值前缀和数组中选取第 i 个值，然后另一玩家在 [i + 1, n - 1] 区间内选取下一前缀和数值。 Alice和Bob都会采取最优策略，Alice每次操作要尽量增大他和Bob的分数差，Bob每次操作要尽量减小Alice和他的分数差，实际上就是无论轮到谁操作，都尽量获得最大分数的意思。那么，在同一条件下 Alice 和 Bob 的操作就完全相同。注意：这里求得统一都是且只是（Alice的分数-Bob的分数）。 设计一个动态规划数组dp表示玩家的最优策略即可，dp[i]表示区间 [i, n - 1] 范围内能够获得的最大分数差，则对位置 i，根据是否选取第 i 个前缀和可得到状态转移方程 dp[i] = max(dp[i + 1], preSum[i] - dp[i + 1])。 这里再详细解释一下状态转移方程：如果不选取第i个前缀和，那么区间[i, n-1]范围内能够获得的最大分数差就是区间[i+1, n-1]范围内能够获得的最大分数差。如果选取第i个前缀和，那么区间[i, n-1]范围内能够获得的最大分数差就是选取的第i个前缀和得到的分数减去区间[i+1, n-1]范围内能够获得的最大分数差，之所以减是因为这次和下一次的操作者不同，从下一次操作者的视角来看，dp[i+1]得到的是他与另一个人的最大分数差，而这次操作要求的是操作者与下一次操作者的分数差，即$x1-x2=-(x2-x1)$。 由于第 n - 1 个前缀和一定会被选取，可从后向前进行动态规划。又因为第一次选取操作时只能从第 2 个石子开始，Alice 的有效起始点为 dp[1]，所以最后要求的结果就是dp[1]（区间 [1, n - 1] 范围内能够获得的最大分数差）。 参考代码： 代码1，按照解题思路写的 123456789101112131415class Solution &#123;public: int stoneGameVIII(vector&lt;int&gt;&amp; stones) &#123; int n=stones.size(); vector&lt;int&gt; preSum; partial_sum(stones.begin(),stones.end(),back_inserter(preSum)); //copy(preSum.begin(),preSum.end(),ostream_iterator&lt;int&gt;(cout,&quot; &quot;)); vector&lt;int&gt; dp(n); dp[n-1]=preSum[n-1]; for(int i=n-2;i&gt;=1;i--) &#123; dp[i]=max(dp[i+1],preSum[i]-dp[i+1]); &#125; return dp[1]; &#125;&#125;; 代码2，另一种解题思路，与代码1的解题思路并无太大区别，动态规划数组定义不同 123456789101112131415161718class Solution &#123;public: int stoneGameVIII(vector&lt;int&gt;&amp; stones) &#123; int n=stones.size(); vector&lt;int&gt; presum(n+1); // 前缀和数组 vector&lt;int&gt; dp(n+1); // d // 求前缀和数组 for(int i=1;i&lt;=n;i++) &#123; presum[i]=presum[i-1]+stones[i-1]; &#125; dp[1]=0; // 剩一堆石子时，先手-后手 的最大分数差为0 dp[2]=presum[n]-dp[1]; for(int i=3;i&lt;=n;i++) &#123; dp[i]=max(dp[i-1],presum[n-i+2]-dp[i-1]); &#125; return dp[n];// 剩n堆石子的最大分数差 &#125;&#125;;","raw":null,"content":null,"categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://e99net.github.io/categories/Algorithm/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://e99net.github.io/tags/Dynamic-Programming/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://e99net.github.io/tags/LeetCode/"}]},{"title":"总结LeetCode上跳跃游戏这一类型的几道题","slug":"LeetCode_JumpGame","date":"2021-11-21T07:27:01.405Z","updated":"2022-09-12T02:21:17.927Z","comments":false,"path":"2021/11/21/LeetCode_JumpGame/","link":"","permalink":"https://e99net.github.io/2021/11/21/LeetCode_JumpGame/","excerpt":"第一题LeetCode 55 Medium [ https://leetcode.com/problems/jump-game ] 描述： 给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 判断你是否能够到达最后一个下标。","keywords":null,"text":"第一题LeetCode 55 Medium [ https://leetcode.com/problems/jump-game ] 描述： 给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 判断你是否能够到达最后一个下标。 输入： 一个非负整数数组 输出： true 或 false 样例输入1： [2,3,1,1,4] 样例输出1： true 说明：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。 样例输入2： [3,2,1,0,4] 样例输出2： false 说明：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。 数据范围 $1 &lt;= nums.length &lt;= 10^4$ $0 &lt;= nums[i] &lt;= 10^5$ 解题思路：贪心法 用动态规划也可解此题，但最好的方法还是贪心，只关心能否到达末尾即可。 参考代码: 代码1，时间复杂度$O(n)$ 1234567891011class Solution &#123;public: bool canJump(vector&lt;int&gt;&amp; nums) &#123; int n=nums.size(),reach=0; for(int i=0;i&lt;n;i++) &#123; if(i&gt;reach || reach&gt;=n-1) break; reach=max(reach,i+nums[i]); &#125; return reach&gt;=n-1; &#125;&#125;; 第二题LeetCode 45 Medium [ https://leetcode.com/problems/jump-game-ii ] 描述： 给定一个非负整数数组，你最初位于数组的第一个位置。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 你的目标是使用最少的跳跃次数到达数组的最后一个位置。 假设你总是可以到达数组的最后一个位置。 输入： 一个非负整数数组 输出： 一个整数 输入样例1： [2,3,1,1,4] 输出样例1： 2 说明：跳到最后一个位置的最小跳跃数是 2。从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。 输入样例2： [2,3,0,1,4] 输出样例2： 2 数据范围： $1 &lt;= nums.length &lt;= 10^4$ $0 &lt;= nums[i] &lt;= 1000$ 解题思路：贪心法 参考代码： 123456789101112131415class Solution &#123;public: int jump(vector&lt;int&gt;&amp; nums) &#123; int n=nums.size(),res=0,i=0,cur=0; while(cur&lt;n-1) &#123; res++; int pre=cur; for(;i&lt;=pre;i++) &#123; cur=max(cur,i+nums[i]); &#125; if(cur==pre) return -1; &#125; return res; &#125;&#125;; 第三题LeetCode 1306 Hard [ https://leetcode.com/problems/jump-game-iii ] 描述： 这里有一个非负整数数组 arr，你最开始位于该数组的起始下标 start 处。当你位于下标 i 处时，你可以跳到 i + arr[i] 或者 i - arr[i]。 请你判断自己是否能够跳到对应元素值为 0 的 任一 下标处。 注意，不管是什么情况下，你都无法跳到数组之外。 输入： 一个非负整数数组和一个整数 输出： true 或 false 输入样例1： [4,2,3,0,3,1,2] 5 输出样例1： true 说明： 到达值为 0 的下标 3 有以下可能方案：下标 5 -&gt; 下标 4 -&gt; 下标 1 -&gt; 下标 3下标 5 -&gt; 下标 6 -&gt; 下标 4 -&gt; 下标 1 -&gt; 下标 3 输入样例2： [3,0,2,1,2] 2 输出样例2： false 说明：无法到达值为 0 的下标 1 处。 数据范围： $1 &lt;= arr.length &lt;= 5 * 10^4$ $0 &lt;= arr[i] &lt; arr.length$ $0 &lt;= start &lt; arr.length$ 解题思路：DFS 参考代码： 12345678910111213141516171819class Solution &#123;public: bool canReach(vector&lt;int&gt;&amp; arr, int start) &#123; int n=arr.size(); vector&lt;bool&gt; visited(n); return helper(arr,visited,start); &#125; bool helper(vector&lt;int&gt;&amp; arr, vector&lt;bool&gt;&amp; visited, int start) &#123; if(arr[start]==0) return true; if(visited[start]) return false; visited[start]=true; bool flag=false; if(start-arr[start]&gt;=0) flag = flag || helper(arr,visited,start-arr[start]); if(start+arr[start]&lt;arr.size()) flag = flag || helper(arr,visited,start+arr[start]); return flag; &#125;&#125;; 第四题LeetCode 1345 Hard [ https://leetcode.com/problems/jump-game-iv ] 描述： 给你一个整数数组 arr ，你一开始在数组的第一个元素处（下标为 0）。 每一步，你可以从下标 i 跳到下标： i + 1 满足：i + 1 &lt; arr.lengthi - 1 满足：i - 1 &gt;= 0j 满足：arr[i] == arr[j] 且 i != j请你返回到达数组最后一个元素的下标处所需的 最少操作次数 。 注意：任何时候你都不能跳到数组外面。 输入： 一个整数数组 输出： 一个整数 输入样例1： [100,-23,-23,404,100,23,23,23,3,404] 输出样例1： 3 说明：那你需要跳跃 3 次，下标依次为 0 –&gt; 4 –&gt; 3 –&gt; 9 。下标 9 为数组的最后一个元素的下标。 输入样例2： [7] 输出样例2： 0 说明：一开始就在最后一个元素处，所以你不需要跳跃。 输入样例3： [7,6,9,6,9,6,9,7] 输出样例3： 1 说明：你可以直接从下标 0 处跳到下标 7 处，也就是数组的最后一个元素处。 输入样例4： [6,1,9] 输出样例4： 2 输入样例5： [11,22,7,7,7,7,7,7,7,22,13] 输出样例5： 3 数据范围： $1 &lt;= arr.length &lt;= 5 * 10^4$ $-10^8 &lt;= arr[i] &lt;= 10^8$ 解题思路：BFS 参考代码： 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: int minJumps(vector&lt;int&gt;&amp; arr) &#123; int res=INT_MAX,n=arr.size(),cur=0; vector&lt;bool&gt; visited(n); unordered_map&lt;int,vector&lt;int&gt;&gt; m; for(int i=0;i&lt;n;i++) &#123; m[arr[i]].push_back(i); &#125; queue&lt;int&gt; q&#123;&#123;0&#125;&#125;; visited[0]=true; while(!q.empty()) &#123; for(int i=q.size();i&gt;0;i--) &#123; int t=q.front();q.pop(); if(t==n-1) &#123; res=min(res,cur); &#125; if(t-1&gt;=0 &amp;&amp; !visited[t-1]) &#123; q.push(t-1); visited[t-1]=true; &#125; if(t+1&lt;n &amp;&amp; !visited[t+1]) &#123; q.push(t+1); visited[t+1]=true; &#125; for(int v:m[arr[t]]) &#123; if(v!=t &amp;&amp; !visited[v]) &#123; q.push(v); visited[v]=true; &#125; &#125; m[arr[t]].clear(); &#125; ++cur; &#125; return res; &#125;&#125;; 第五题LeetCode 1340 Hard [ https://leetcode.com/problems/jump-game-v ] 描述： 给你一个整数数组 arr 和一个整数 d 。每一步你可以从下标 i 跳到： i + x ，其中 i + x &lt; arr.length 且 0 &lt; x &lt;= d 。i - x ，其中 i - x &gt;= 0 且 0 &lt; x &lt;= d 。除此以外，你从下标 i 跳到下标 j 需要满足：arr[i] &gt; arr[j] 且 arr[i] &gt; arr[k] ，其中下标 k 是所有 i 到 j 之间的数字（更正式的，min(i, j) &lt; k &lt; max(i, j)）。 你可以选择数组的任意下标开始跳跃。请你返回你 最多 可以访问多少个下标。 请注意，任何时刻你都不能跳到数组的外面。 输入： 一个整数数组和一个整数 输出： 一个整数 输入样例1： [6,4,14,6,8,13,9,7,10,6,12] 2 输出样例1： 4 说明： 你可以从下标 10 出发，然后如上图依次经过 10 –&gt; 8 –&gt; 6 –&gt; 7 。注意，如果你从下标 6 开始，你只能跳到下标 7 处。你不能跳到下标 5 处因为 13 &gt; 9 。你也不能跳到下标 4 处，因为下标 5 在下标 4 和 6 之间且 13 &gt; 9 。类似的，你不能从下标 3 处跳到下标 2 或者下标 1 处。 输入样例2： [3,3,3,3,3] 3 输出样例2： 1 输入样例3： [7,6,5,4,3,2,1] 1 输出样例3： 7 输入样例4： [7,1,7,1,7,1] 2 输出样例4： 2 输入样例5： [66] 1 输出样例5： 1 数据范围： $1 &lt;= arr.length &lt;= 1000$ $1 &lt;= arr[i] &lt;= 10^5$ $1 &lt;= d &lt;= arr.length$ 解题思路：动态规划用 $dp[i]$ 表示从 $i$ 开始跳，最多可以跳的台阶数。因为，根据题意只能往低了跳，且中间不能遇到比自己高的，所以，动态规划要按从低向高的顺序计算，要先排序（这一点很重要），这里借助multimap数据结构进行排序，默认升序排列。状态转移方程 $dp[i]=max(dp[i], 1+dp[j])$，从 $i$ 跳到所有可能的 $j$ 参考代码： 1234567891011121314151617181920212223242526class Solution &#123;public: int maxJumps(vector&lt;int&gt;&amp; arr, int d) &#123; int n=arr.size(); vector&lt;int&gt; dp(n); // dp数组 multimap&lt;int,int&gt; m; for(int i=0;i&lt;n;i++) &#123; m.insert(make_pair(arr[i],i)); &#125; for(auto&amp; it:m) &#123; // 从低到高开始dp int i=it.second; dp[i]=1; // 至少为1，因为至少包含自身 for(int j=i-1;j&gt;=i-d &amp;&amp; j&gt;=0 &amp;&amp; arr[j]&lt;arr[i];j--) &#123; // 往左边找比自己低的，遇到比自己高的就停止 // 由于由低到高计算，比自己低的已经计算好了 dp[i]=max(dp[i],1+dp[j]); &#125; for(int j=i+1;j&lt;=i+d &amp;&amp; j&lt;n &amp;&amp; arr[j]&lt;arr[i];j++) &#123; // 往右边找比自己低的，遇到比自己高的就停止 // 由于由低到高计算，比自己低的已经计算好了 dp[i]=max(dp[i],1+dp[j]); &#125; &#125; return *max_element(dp.begin(),dp.end()); &#125;&#125;; 第六题LeetCode 1696 Medium [ https://leetcode.com/problems/jump-game-vi ] 描述： 给你一个下标从 0 开始的整数数组 nums 和一个整数 k 。 一开始你在下标 0 处。每一步，你最多可以往前跳 k 步，但你不能跳出数组的边界。也就是说，你可以从下标 i 跳到 [i + 1， min(n - 1, i + k)] 包含 两个端点的任意位置。 你的目标是到达数组最后一个位置（下标为 n - 1 ），你的 得分 为经过的所有数字之和。 请你返回你能得到的 最大得分 。 输入： 一个整数数组和一个整数 输出： 一个整数 输入样例1： [1,-1,-2,4,-7,3] 2 输出样例1： 7 说明：你可以选择子序列 [1,-1,4,3] ，和为 7 。 输入样例2： [10,-5,-2,4,0,3] 3 输出样例2： 17 输入样例3： [1,-5,-20,4,-1,3,-6,-3] 2 输出样例3： 0 数据范围： $1 &lt;= nums.length, k &lt;= 10^5$ $-10^4 &lt;= nums[i] &lt;= 10^4$ 解题思路：动态规划 这题很容易想到 DP，但是 DP 的复杂度是 $O(n*k)$ 的，显然会超时，所以要借助一种数据结构快速找到[i−k, i−1]的最大值，然后再结合 DP 即可。 这种数据结构可以是堆，也可以是单调队列。用堆的话，堆顶维护区间最大值，把下标也一并放入堆中来帮助判断是否能从这个状态转移；用单调队列的话，队首维护区间最大值，按需出队、入队皆可。 参考代码： 代码1，时间复杂度$O(n*k)$ LeetCode上的数据范围是$1 &lt;= nums.length, k &lt;= 10^5$，$O(n*k)$时间复杂度的算法会超时，故代码1提交时会TLE 1234567891011121314class Solution &#123;public: int maxResult(vector&lt;int&gt;&amp; nums, int k) &#123; int n=nums.size(); vector&lt;int&gt; dp(n,INT_MIN); dp[n-1]=nums[n-1]; for(int i=n-1;i&gt;=0;i--) &#123; for(int j=1;j&lt;=k &amp;&amp; i+j&lt;n;j++) &#123; dp[i]=max(dp[i],nums[i]+dp[i+j]); &#125; &#125; return dp[0]; &#125;&#125;; 代码2，时间复杂度$O(nlogn)$，动态规划+堆 12345678910111213141516class Solution &#123;public: int maxResult(vector&lt;int&gt;&amp; nums, int k) &#123; int n=nums.size(); vector&lt;int&gt; dp(n,0); dp[0]=nums[0]; priority_queue&lt;pair&lt;int,int&gt;&gt; pq; pq.push(&#123;nums[0],0&#125;); for(int i=1;i&lt;n;i++) &#123; while(pq.top().second&lt;i-k) pq.pop(); dp[i]=nums[i]+pq.top().first; pq.push(&#123;dp[i],i&#125;); &#125; return dp[n-1]; &#125;&#125;; 代码3，每个元素只会入队列一次和出队列一次，所以总体时间复杂度$O(n)$，动态规划+滑动窗口 1234567891011121314151617class Solution &#123;public: int maxResult(vector&lt;int&gt;&amp; nums, int k) &#123; int n=nums.size(); vector&lt;int&gt; dp(n,0); dp[0]=nums[0]; deque&lt;int&gt; dq; dq.push_back(0); for(int i=1;i&lt;n;i++) &#123; while(i-k&gt;dq.front()) dq.pop_front(); dp[i]=nums[i]+dp[dq.front()]; while(dq.size() &amp;&amp; dp[i]&gt;dp[dq.back()]) dq.pop_back(); dq.push_back(i); &#125; return dp[n-1]; &#125;&#125;; 第七题LeetCode 1871 Medium [ https://leetcode.com/problems/jump-game-vii ] 描述： 给你一个下标从 0 开始的二进制字符串 s 和两个整数 minJump 和 maxJump 。一开始，你在下标 0 处，且该位置的值一定为 ‘0’ 。当同时满足如下条件时，你可以从下标 i 移动到下标 j 处： i + minJump &lt;= j &lt;= min(i + maxJump, s.length - 1) 且 s[j] == ‘0’. 如果你可以到达 s 的下标 s.length - 1 处，请你返回 true ，否则返回 false 。 输入： 一个字符串和两个整数 输出： true 或 false 输入样例1： “011010” 2 3 输出样例1： true 说明：第一步，从下标 0 移动到下标 3 。第二步，从下标 3 移动到下标 5 。 输入样例2： “01101110” 2 3 输出样例2： false 数据范围： $2 &lt;= s.length &lt;= 10^5$s[i] 要么是 ‘0’ ，要么是 ‘1’s[0] == ‘0’$1 &lt;= minJump &lt;= maxJump &lt; s.length$ 解题思路：贪心+剪枝优化 首先要明白，末尾字符为’1’的话一定返回false。因为只能跳到字符为’0’的位置，如果末尾字符为’1’，则表示永远跳不到末尾。 然后遍历字符串，标记在每个位置上能跳跃到的位置。可以使用额外的数组来标记，也可以直接在原字符串进行标记。 一开始这样是会超时的，有很多位置可能存在重复标记。因此做一个小小的优化，在标记前比较本次标记的起始位置与已标记到的位置，取较大值作为新的标记起始位置，这样可以避免重复标记之前已标记过的位置。 最后看末尾位置是否已标记，如果已标记，说明能够到达末尾。 参考代码： 123456789101112131415161718class Solution &#123;public: bool canReach(string s, int minJump, int maxJump) &#123; int n=s.size(), j=0; if(s[n-1]==&#x27;1&#x27;) return false; vector&lt;bool&gt; visited(n); visited[0]=true;//初始必须标记位置0，否则循环中的判断会导致出错 for(int i=0;i&lt;n;i++) &#123; if(s[i]==&#x27;1&#x27;) continue; //该位置的字符为&#x27;1&#x27;，则无法跳到此位置 if(!visited[i]) continue; //此位置未标记，表示从起始位置无法跳到此位置 for(j=max(j,i+minJump);j&lt;=min(i+maxJump,n-1);j++) &#123; if(s[j]==&#x27;0&#x27;) visited[j]=true; &#125; if(visited[n-1]) return true; &#125; return visited[n-1]; &#125;&#125;;","raw":null,"content":null,"categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://e99net.github.io/categories/Algorithm/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://e99net.github.io/tags/DFS/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://e99net.github.io/tags/Dynamic-Programming/"},{"name":"Greedy","slug":"Greedy","permalink":"https://e99net.github.io/tags/Greedy/"},{"name":"BFS","slug":"BFS","permalink":"https://e99net.github.io/tags/BFS/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://e99net.github.io/tags/LeetCode/"}]},{"title":"总结LeetCode上买卖股票这一类型的几道题","slug":"LeetCode_BestTimeToBuyAndSellStock","date":"2021-11-21T07:27:01.403Z","updated":"2022-09-12T01:41:48.126Z","comments":false,"path":"2021/11/21/LeetCode_BestTimeToBuyAndSellStock/","link":"","permalink":"https://e99net.github.io/2021/11/21/LeetCode_BestTimeToBuyAndSellStock/","excerpt":"第一题LeetCode 121 Easy [ https://leetcode.com/problems/best-time-to-buy-and-sell-stock/ ] 描述： 给一个数组，数组中的第i个元素代表第i天的股票价格。如果只允许完全至多一次交易（即买进一股股票并卖出这股股票），那么最大收益是多少？ 注意：卖出股票的时间不能早于买进股票的时间。","keywords":null,"text":"第一题LeetCode 121 Easy [ https://leetcode.com/problems/best-time-to-buy-and-sell-stock/ ] 描述： 给一个数组，数组中的第i个元素代表第i天的股票价格。如果只允许完全至多一次交易（即买进一股股票并卖出这股股票），那么最大收益是多少？ 注意：卖出股票的时间不能早于买进股票的时间。 输入： 一个数组。 输出： 买卖股票的最大收益。 样例输入1： [7,1,5,3,6,4] 样例输出1： 5 样例输入2： [7,6,4,3,1] 样例输出2： 0 解题思路：贪心法 遍历一次数组，用一个变量记录遍历过的数中的最小值，然后每次计算当前值和最小值之间的差值作为利润，每次选较大的利润来更新，遍历完成后，当前利润即所求。 参考代码: 代码1，时间复杂度$O(n^2)$ LeetCode上的数据范围是$1 &lt;= prices.length &lt;= 10^5$，$O(n^2)$时间复杂度的算法会超时，故代码1提交时会TLE 123456789101112class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int res=0; for(int i=0;i&lt;prices.size()-1;i++) &#123; for(int j=i+1;j&lt;prices.size();j++) &#123; res=max(res,prices[j]-prices[i]); &#125; &#125; return res; &#125;&#125;; 代码2，时间复杂度$O(n)$ 1234567891011class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int res=0, buy=INT_MAX; for(auto&amp; price:prices) &#123; buy=min(buy,price); res=max(res,price-buy); &#125; return res; &#125;&#125;; 第二题LeetCode 122 Easy [ https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/ ] 描述： 给一个数组，数组中的第i个元素代表第i天的股票价格。如果允许完成多次交易（即多次买进一股股票并卖出这股股票），那么最大收益是多少？ 注意：不能同时进行多次交易，必须在再次买进股票前卖出股票。 输入： 一个数组。 输出： 买卖股票的最大收益。 输入样例1： [7,1,5,3,6,4] 输出样例1： 7 说明：第二天买进，第三天卖出，获得收益5-1=4；第四天买进，第五天卖出，获得收益6-3=3。总共获得收益4+3=7。 输入样例2： [1,2,3,4,5] 输出样例2： 4 说明：第一天买进，第五天卖出，获得收益5-1=4。不能在第一天买进，第二天买进，稍后再卖出它们，因为这算同时进行多次交易。 输入样例3： [7,6,4,3,1] 输出样例3： 0 解题思路：贪心法 从第二天开始，如果当前价格比之前价格高，则把差值加入利润中，因为我们可以昨天买入，今日卖出，若明日价更高的话，还可以今日买入，明日再抛出。以此类推，遍历完整个数组后即可求得最大利润。 参考代码： 代码1，时间复杂度$O(n)$ 1234567891011class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices)&#123; int sum=0; for(int i=1;i&lt;prices.size();i++) &#123; if(prices[i]&gt;prices[i-1]) sum+=prices[i]-prices[i-1]; &#125; return sum; &#125;&#125;; 代码2 12345678910class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices)&#123; int sum=0; for(int i=1;i&lt;prices.size();i++) &#123; sum+=max(0,prices[i]-prices[i-1]); &#125; return sum; &#125;&#125;; 代码3，类比第一题 1234567891011class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int sell=0,buy=INT_MIN; for(int p:prices) &#123; buy=max(buy,sell-p); sell=max(sell,buy+p); &#125; return sell; &#125;&#125;; 第三题LeetCode 123 Hard [ https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/ ] 描述： 给一个数组，数组中的第i个元素代表第i天的股票价格。如果只允许完成最多两次交易（即最多两次买进股票并卖出股票），那么最大收益是多少？ 注意：不能同时进行多次交易，必须在再次买进股票前卖出股票。 输入： 一个数组。 输出： 买卖股票的最大收益。 输入样例1： [3,3,5,0,0,3,1,4] 输出样例1： 6 说明：第四天买进，第六天卖出，获得收益3-0=3；然后第七天买进，第八天卖出，获得收益4-1=3。总共获得收益3+3=6。 输入样例2： [1,2,3,4,5] 输出样例2： 4 说明：第一天买进，第五天卖出，获得收益5-1=4。不能在第一天买进，第二天买进，稍后再卖出它们，因为这算同时进行多次交易。 输入样例3： [7,6,4,3,1] 输出样例3： 0 解题思路：动态规划 题目规定最多交易两次，而不是一定要交易两次，故允许在同一天既买进又卖出，这相当于不交易 因为最多允许两次交易且交易分先后，所以可将区间分成两段，分别使用动态规划求每段的最大利润 f[i]表示在第i天一定卖出时的最大利润，即区间[0, i]的最大利润 g[i]表示在第i天买入且在最后一天一定卖出时的最大利润，即区间[i, n-1]的最大利润 那么，max{f[i]+g[i]}就是最多允许两次交易的最大利润 参考代码： 代码1，时间复杂度O(n)，空间复杂度O(n) 1234567891011121314151617181920212223class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; if(prices.size()&lt;2)return 0; const int n=prices.size(); vector&lt;int&gt; f(n,0); vector&lt;int&gt; g(n,0); for(int i=1,valley=prices[0];i&lt;n;i++) &#123; valley=min(valley,prices[i]); // 第i天一定卖出的最大利润 包括 第i-1天一定卖出的最大利润 f[i]=max(f[i-1],prices[i]-valley); &#125; for(int i=n-2,peak=prices[n-1];i&gt;=0;i--) &#123; peak=max(peak,prices[i]); // 第i天买入且最后一天一定卖出的最大利润 不包括 第i+1天买入且最后一天卖出的最大利润 g[i]=max(g[i],peak-prices[i]); &#125; int max_profit=0; for(int i=0;i&lt;n;i++) max_profit=max(max_profit,f[i]+g[i]); return max_profit; &#125;&#125;; 代码2，第四题代码2的特例，将k改成2所得 12345678910111213class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; vector&lt;int&gt; sells(3,0), buys(3,INT_MIN); for(int p:prices) &#123; for(int i=1;i&lt;=2;i++) &#123; buys[i]=max(buys[i],sells[i-1]-p); sells[i]=max(sells[i],buys[i]+p); &#125; &#125; return sells[2]; &#125;&#125;; 第四题LeetCode 188 Hard [ https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/ ] 描述： 给一个数组，数组中的第i个元素代表第i天的股票价格。如果只允许完成最多k次交易（即最多k次买进股票并卖出股票），那么最大收益是多少？ 注意：不能同时进行多次交易，必须在再次买进股票前卖出股票。 输入： 一个数组和一个数，用空格分隔。 输出： 买卖股票的最大收益。 输入样例1： [2,4,1] 2 输出样例1： 2 说明：第一天买进，第二天卖出，总共获得收益4-2=2。 输入样例2： [3,2,6,5,0,3] 2 输出样例2： 7 说明：第二天买进，第三天卖出，获得收益6-2=4；然后在第五天买进，第六天卖出，获得收益3-0=3。总共获得收益4+3=7。 解题思路：动态规划 这道题是第三题的推广如果k的值远大于prices的天数，应该直接用第二题的解法，所以这道题又是第二题和第三题的结合 参考代码： 代码1 123456789101112131415161718192021222324252627class Solution &#123;public: int maxProfit(int k, vector&lt;int&gt;&amp; prices) &#123; if(prices.empty()) return 0; const int n=prices.size(); if(k&gt;=n) return solveMaxProfit(prices); int global[k+1]=&#123;0&#125;; int local[k+1]=&#123;0&#125;; for(int i=0;i&lt;n-1;i++) &#123; int diff=prices[i+1]-prices[i]; for(int j=k;j&gt;=1;j--) &#123; local[j]=max(global[j-1]+max(diff,0),local[j]+diff); global[j]=max(global[j],local[j]); &#125; &#125; return global[k]; &#125; int solveMaxProfit(vector&lt;int&gt;&amp; prices) &#123; int res=0; for(int i=1;i&lt;prices.size();i++) &#123; if(prices[i]-prices[i-1]&gt;0) &#123; res+=prices[i]-prices[i-1]; &#125; &#125; return res; &#125;&#125;; 代码2 1234567891011121314151617181920212223class Solution &#123;public: int maxProfit(int k, vector&lt;int&gt;&amp; prices) &#123; if(k&gt;=prices.size()/2) return helper(prices); vector&lt;int&gt; sells(k+1,0),buys(k+1,INT_MIN); for(int p:prices) &#123; for(int i=1;i&lt;=k;i++) &#123; // buys[i]表示在价格为p时第i次买入的最大利润 // sells[i]表示在价格为p是第i次卖出的最大利润 buys[i]=max(buys[i],sells[i-1]-p); sells[i]=max(sells[i],buys[i]+p); &#125; &#125; return sells[k]; &#125; int helper(vector&lt;int&gt;&amp; prices) &#123; int res=0; for(int i=1;i&lt;prices.size();i++) &#123; res+=max(0,prices[i]-prices[i-1]); &#125; return res; &#125;&#125;; 第五题LeetCode 309 Medium [ https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/ ] 描述： 给一个数组，数组中的第i个元素代表第i天的股票价格。如果允许按照以下限制完成多次交易（即多次买进股票并卖出股票），那么最大收益是多少？ 限制1：不能同时进行多次交易，必须在再次买进股票前卖出股票。限制2：在卖出股票后，不能买进下一天的股票（冷却一天）。 输入： 一个数组。 输出： 买卖股票的最大收益。 输入样例： [1,2,3,0,2] 输出样例： 3 说明：第一天买进，第二天卖出，第三天冷却，第四天买进，第五天卖出，总共获得收益1+2=3。 解题思路：动态规划 ​ 状态转移图中：​ S0 代表没有买入的状态​ S1 代表买入后等待卖出的状态​ S2 代表卖出后的状态 ​ S2与S0的区别是：因为题目要求卖出后必须cooldown一轮，所以卖出进入S2后，必须再进入S0这个等待买入的状态，这一状态转换代表cooldown一轮 ​ 状态转移方程：​ $s0[i] = max(s0[i-1], s2[i-1])$​ $s1[i] = max(s1[i-1], s0[i-1] - price[i])$​ $s2[i] = s1[i-1] + price[i]$ 参考代码： 代码1 12345678910111213141516171819class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; const int n=prices.size(); if(n&lt;=1) return 0; vector&lt;int&gt; s0(n,0); vector&lt;int&gt; s1(n,0); vector&lt;int&gt; s2(n,0); s1[0]=-prices[0]; s0[0]=0; s2[0]=INT_MIN; for(int i=1;i&lt;n;i++) &#123; s0[i]=max(s0[i-1],s2[i-1]); s1[i]=max(s1[i-1],s0[i-1]-prices[i]); s2[i]=s1[i-1]+prices[i]; &#125; return max(s0[n-1],s2[n-1]); &#125;&#125;; 代码2，类比第四题代码2，两个数组意思不同 1234567891011121314class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int len=prices.size(); vector&lt;int&gt; sell(len+1,0),buy(len+1,INT_MIN); for(int i=1;i&lt;len+1;i++) &#123; // buy[i]表示第i-1天持股的最大利润 // sell[i]表示第i-1天未持股的最大利润 buy[i]=max(buy[i-1],(i-2&gt;0?sell[i-2]:0)-prices[i-1]); //i-2&gt;=0也可以 sell[i]=max(sell[i-1],buy[i-1]+prices[i-1]); &#125; return sell[len]; &#125;&#125;; 第六题LeetCode 714 Medium [ https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/ ] 描述： 给一个数组和一个数，数组中的第i个元素代表第i天的股票价格，那个数代表交易费。如果允许完成多次交易（即多次买进股票并卖出股票），且每次交易需要支付交易费，那么最大收益是多少？ 注意：不能同时进行多次交易，必须在再次买进股票前卖出股票。 输入： 一个数组prices（$0 &lt; prices.length \\le 50000$，$0 &lt; prices[i] &lt; 50000$）和一个数fee（$0 \\le fee &lt; 50000$），用空格分隔。 输出： 买卖股票的最大收益。 输入样例： [1,3,2,8,4,9] 2 输出样例： 8 说明：第一天买进，第四天卖出，第五天买进，第六天卖出，总共获得收益(8-1-2)+(9-4-2)=8。 解题思路：动态规划 贪心法不行，当卖出的利润小于交易费时，不应该卖出，否则会亏损。 状态转移方程：$sold[i] = max(sold[i - 1], hold[i - 1] + prices[i] - fee)$$hold[i] = max(hold[i - 1], sold[i - 1] - prices[i])$ 不管是卖出还是保留，第i天的利润只跟第i-1天有关系，所以可以优化空间，用两个变量来表示当前的卖出和保留的利润， 参考代码： 代码1 123456789101112class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices, int fee) &#123; int sold=0,hold=-prices[0];// hold=INT_MIN也可以 for(int price:prices) &#123; int t=sold; sold=max(sold,hold+price-fee); hold=max(hold,t-price); &#125; return sold; &#125;&#125;; 代码2，类比第二题代码3 1234567891011class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices, int fee) &#123; int sold=0,hold=-prices[0];// hold=INT_MIN也可以 for(int price:prices) &#123; hold=max(hold,sold-price); sold=max(sold,hold+price-fee); &#125; return sold; &#125;&#125;;","raw":null,"content":null,"categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://e99net.github.io/categories/Algorithm/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://e99net.github.io/tags/Dynamic-Programming/"},{"name":"Greedy","slug":"Greedy","permalink":"https://e99net.github.io/tags/Greedy/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://e99net.github.io/tags/LeetCode/"}]},{"title":"YAPI——api自动化测试平台","slug":"the_problem_of_play_docker-yapi","date":"2021-06-12T11:21:15.100Z","updated":"2021-06-12T12:43:46.164Z","comments":false,"path":"2021/06/12/the_problem_of_play_docker-yapi/","link":"","permalink":"https://e99net.github.io/2021/06/12/the_problem_of_play_docker-yapi/","excerpt":"简介YAPI是一个很炫酷的企业级api自动化测试平台，最早是由去哪儿开发，后来移交给百度进行维护。","keywords":null,"text":"简介YAPI是一个很炫酷的企业级api自动化测试平台，最早是由去哪儿开发，后来移交给百度进行维护。 记录几个玩docker-yapi时踩的坑在windows7中安装docker-yapi体验学习一下如何使用YAPI，在此过程中遇到如下几个问题： Error: getaddrinfo ENOTFOUND yapi.demo.qunar.com 此错误可忽略，貌似在配置文件中重定向到了https://registry.npm.taobao.org 镜像build了好多次, 模块找不到 internal/modules/cjs/loader.js:818throw err;^ Error: Cannot find module ‘/my-yapi/vendors/server/app.js’at Function.Module._resolveFilename (internal/modules/cjs/loader.js:815:15)at Function.Module._load (internal/modules/cjs/loader.js:667:27)at Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:60:12)at internal/main/run_main_module.js:17:47 {code: ‘MODULE_NOT_FOUND’,requireStack: []} 第一次修改docker-compose.yml里的command指令： 由 123456789yapi:build:context: ./dockerfile: Dockerfileimage: yapi# 第一次启动使用# command: \"yapi server\"# 之后使用下面的命令command: \"node /my-yapi/vendors/server/app.js\" 修改成 123456789yapi:build:context: ./dockerfile: Dockerfileimage: yapi# 第一次启动使用command: \"yapi server\"# 之后使用下面的命令# command: \"node /my-yapi/vendors/server/app.js\" Operation not permitted. 此错误在web配置页面中显示为： Error: 连接数据库失败 Error: getaddrinfo ENOTFOUND mongo at GetAddrInfoReqWrap.onlookup [as oncomplete] (dns.js:66:26) { name: ‘MongoError’ }] Error: 连接数据库失败, failed to connect to server [mongo:27017] 查询一下docker中与mongo相关的环境（此处镜像为mongo:4，docker-yapi起的容器名为docker-yapi_mongo_1）： 12docker psdocker ps -a 发现docker-yapi的mongo环境没有启动成功。 这是因为Windows和OS X上的默认Docker设置使用VirtualBox VM来托管Docker守护程序。不幸的是，VirtualBox用于在主机系统和Docker容器之间共享文件夹的机制与MongoDB使用的内存映射文件不兼容（请参阅vbox bug，docs.mongodb.org和相关的jira.mongodb.org错误）。这意味着无法运行映射到主机的数据目录的MongoDB容器。原文见Docker Hub中mongoDB官方镜像对此的描述： WARNING (Windows &amp; OS X): The default Docker setup on Windows and OS X uses a VirtualBox VM to host the Docker daemon. Unfortunately, the mechanism VirtualBox uses to share folders between the host system and the Docker container is not compatible with the memory mapped files used by MongoDB (see vbox bug, docs.mongodb.org and related jira.mongodb.org bug). This means that it is not possible to run a MongoDB container with the data directory mapped to the host. 解决方案是创建docker数据卷（Volume）作为保存持久化数据的目录，数据卷Volume可理解为虚拟磁盘。 12345# 创建Volume虚拟磁盘docker volume create --name &lt;名称&gt;# 删除Volume虚拟磁盘docker volume rm &lt;名称&gt; 例如此处可以创建名为mongodata的数据卷，并与docker-yapi中配置的mongo数据目录建立映射： 12docker volume create --name mongodatadocker run --name mongodb -v mongodata:/data/db -p 27017:27017 -d mongo:latest “msg”:”Authentication failed”,”attr”:{“mechanism”:”SCRAM-SHA-1”,”speculative”:false,”principalName”:”yapi”,”authenticationDatabase”:”yapi”,”error”:”UserNotFound: Could not find user \\”yapi\\” for db \\”yapi\\””} 此错误在web配置页面中显示为： Error: 连接数据库失败, Authentication failed. 这是因为新版本的MongoDB权限管理更加严格，可手动登入docker中的mongo环境配置用户yapi的权限（根据docker-yapi自带的配置文件进行配置即可）","raw":null,"content":null,"categories":[{"name":"memo","slug":"memo","permalink":"https://e99net.github.io/categories/memo/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://e99net.github.io/tags/Golang/"},{"name":"Microservice","slug":"Microservice","permalink":"https://e99net.github.io/tags/Microservice/"}]},{"title":"记录几个玩Golang微服务生态时踩的坑","slug":"the_problem_of_play_go-related_framework","date":"2021-06-12T09:40:26.784Z","updated":"2021-06-12T11:10:28.320Z","comments":false,"path":"2021/06/12/the_problem_of_play_go-related_framework/","link":"","permalink":"https://e99net.github.io/2021/06/12/the_problem_of_play_go-related_framework/","excerpt":"go-micro invalid character ‘\\‘’ looking for beginning of value go micro官方文档给的实例里面 Make an RPC call via the CLI. The query is sent as json.","keywords":null,"text":"go-micro invalid character ‘\\‘’ looking for beginning of value go micro官方文档给的实例里面 Make an RPC call via the CLI. The query is sent as json. 1micro call go.micro.srv.example Example.Call '&#123;\"name\": \"John\"&#125;' 在windows控制台中执行会返回: invalid character ‘\\‘’ looking for beginning of value 经过测试，正确写法是： 1micro call go.micro.srv.example Example.Call \"&#123;\\\"name\\\":\\\"John\\\"&#125;\" consul + go-micro Go-Micro客户端请求报500错误和408错误 {“id”:”go.micro.client”,”code”:500,”detail”:”service not found”} {“id”:”go.micro.client”,”code”:408,”detail”:”call timeout: context deadline exceeded”,”status”:”Request Timeout”} 查看一下服务列表和服务详细信息 1234micro list services比如得到结果：go.micro.srv.examplemicro get service go.micro.srv.example 此现象有可能是因为服务没有在consul中注册成功所导致，这里提供一种解决思路： 确保在“告诉consul即将注册的服务的配置信息”时有以下配置项 12345678910111213registerService:=api.AgentServiceRegistration&#123; ID:\"xxx\", Tags:[]string&#123;\"grpc\",\"consul\"&#125;, Name:\"grpc And Consul\", Address:\"127.0.0.1\", Port:8800, Check:&amp;api.AgentServiceCheck&#123; CheckID:\"consul grpc test\", TCP:\"127.0.0.1:8800\", Timeout:\"1s\", Interval:\"5s\", &#125;,&#125; docker VBoxManage.exe: error: Details: code E_FAIL (0x80004005)…… windows7利用DockerToolBox安装Docker出现此问题，经测试，以下方法能解决此问题： 卸载掉VirtualBox，然后从https://www.virtualbox.org/wiki/Downloads 更新最新版本安装，安装完成后再启动docker的客户端 elasticsearch post 中文数据到elasticsearch restful接口报json_parse_exception 问题 {“error”:{“root_cause”:[{“type”:”json_parse_exception”,”reason”:”Invalid UTF-8 middle byte…… 在windows7 cmd命令行下执行会报此错误，可尝试通过专业的postman工具进行操作","raw":null,"content":null,"categories":[{"name":"memo","slug":"memo","permalink":"https://e99net.github.io/categories/memo/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://e99net.github.io/tags/Golang/"},{"name":"Microservice","slug":"Microservice","permalink":"https://e99net.github.io/tags/Microservice/"}]},{"title":"手写堆(以小根堆为例)","slug":"write_a_heap","date":"2021-06-12T08:19:51.992Z","updated":"2021-06-12T11:14:20.092Z","comments":false,"path":"2021/06/12/write_a_heap/","link":"","permalink":"https://e99net.github.io/2021/06/12/write_a_heap/","excerpt":"基础准备一个数据结构堆其实是一棵完全二叉树， 用一个一维数组保存堆元素， 下标从1开始存（根节点是1），x的左儿子是2x，x的右儿子是2x+1。","keywords":null,"text":"基础准备一个数据结构堆其实是一棵完全二叉树， 用一个一维数组保存堆元素， 下标从1开始存（根节点是1），x的左儿子是2x，x的右儿子是2x+1。 1int h[N], size; 两个关键(heapify堆化) up 123456void up(int u) &#123; while(u/2 &amp;&amp; h[u/2]&gt;h[u]) &#123; swap(h[u/2],h[u]); u/=2; &#125;&#125; down 12345678void down(int u) &#123; if(u*2&lt;=size &amp;&amp; h[t]&gt;h[u*2]) t=u*2; if(u*2+1&lt;=size &amp;&amp; h[t]&gt;h[u*2+1]) t=u*2+1; if(t!=u) &#123; swap(h[t],h[u]); down(t); &#125;&#125; 五个操作 插入一个数 1heap[++size]=x; up(size); 求集合当中的最小值 1heap[1]; 删除最小值 1heap[1]=heap[size];size--;down(1); 删除任意一个元素 1heap[k]=heap[size];size--;up(k);down(k); 修改任意一个元素 1heap[k]=x;up(k);down(k); 来做几道题练练手堆排序 描述： 输入一个长度为 n 的整数数列，从小到大输出前 m 小的数。 输入： 第一行包含整数 n 和 m。 第二行包含 n 个整数，表示整数数列。 输出： 共一行，包含 m 个整数，表示整数数列中前 m 小的数。 数据范围： $1≤m≤n≤10^5.$ $1≤数列中元素≤10^9$ 样例输入： 5 3 4 5 1 3 2 样例输出： 1 2 3 样例解释： 参考代码: 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N=100010;int n,m;int h[N],size;void down(int u) &#123; int t=u; if(u*2&lt;=size &amp;&amp; h[t]&gt;h[u*2]) t=u*2; if(u*2+1&lt;=size &amp;&amp; h[t]&lt;h[u*2+1]) t=u*2+1; if(t!=u) &#123; swap(h[u],h[t]); down(t); &#125;&#125;void up(int u) &#123; while(u/2 &amp;&amp; h[u/2]&gt;h[u]) &#123; swap(h[u/2],h[u]); u/=2; &#125;&#125;int main() &#123; scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;h[i]); size=n; // 一种建堆方式：从n/2开始down，一直到1，时间复杂度是O(n) for(int i=n/2;i;i--) down(i); while(m--) &#123; printf(\"%d \",h[1]); h[1]=h[size]; size--; down(1); &#125; return 0;&#125; 模拟堆 描述： 维护一个集合，初始时集合为空，支持如下几种操作： “I x”，插入一个数x； “PM”，输出当前集合中的最小值； “DM”，删除当前集合中的最小值（当最小值不唯一时，删除最早插入的最小值）； “D k”，删除第k个插入的数； “C k x”，修改第k个插入的数，将其变为x； 现在要进行N次操作，对于所有第2个操作，输出当前集合的最小值。 输入： 第一行包含整数N。接下来N行，每行包含一个操作指令，操作指令为“I x”，“PM”，“DM”，“D k”或“C k x”中的一种。 输出： 对于每个输出指令“PM”，输出一个结果，表示当前集合中的最小值。每个结果占一行。 数据范围： $1\\le N \\le 10^5$ $-10^9 \\le x \\le 10^9$ 数据保证合法。 样例输入： 10I -10PMI -10D 1C 2 8I 6PMDM 样例输出： -10 6 参考代码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283// 模拟（带映射版的）堆各项操作的模板#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;using namespace std;const int N=100010;// ph[i]:第i个插入的数在堆中的位置// hp[i]:堆中第i个位置的数的插入时刻int h[N],hp[N],ph[N],size;//由于要修改或删除堆中任意位置的元素，所以变得复杂void heap_swap(int a,int b)&#123; swap(ph[hp[a]],ph[hp[b]]); swap(hp[a],hp[b]); swap(h[a],h[b]);&#125;void down(int u)&#123; int t=u; if(u*2&lt;=size &amp;&amp; h[u*2]&lt;h[t]) t=u*2; if(u*2+1&lt;=size &amp;&amp; h[u*2+1]&lt;h[t]) t=u*2+1; if(u!=t) &#123; heap_swap(u,t); down(t); &#125;&#125;void up(int u)&#123; while(u/2 &amp;&amp; h[u/2]&gt;h[u]) &#123; heap_swap(u/2,u); u/=2; &#125;&#125;int main()&#123; int n,m=0; scanf(\"%d\",&amp;n); while(n--) &#123; char op[10]; int k,x; scanf(\"%s\",op); if(!strcmp(op,\"I\")) &#123; scanf(\"%d\",&amp;x); size++; m++; //第m个插入的数在堆的size位置，堆中size位置上的数是第m个插入的数 ph[m]=size,hp[size]=m; // 一种建堆方式：一个一个插，时间复杂度是O(nlogn) h[size]=x; up(size); &#125; else if(!strcmp(op,\"PM\")) printf(\"%d\\n\",h[1]); else if(!strcmp(op,\"DM\")) &#123; heap_swap(1,size); size--; down(1); &#125; else if(!strcmp(op,\"D\")) &#123; scanf(\"%d\",&amp;k); k=ph[k];//找到第k个插入的数所对应的堆里面的位置 heap_swap(k,size); size--; down(k),up(k); &#125; else &#123; scanf(\"%d%d\",&amp;k,&amp;x); k=ph[k]; h[k]=x; down(k),up(k); &#125; &#125; return 0;&#125;","raw":null,"content":null,"categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://e99net.github.io/categories/Algorithm/"}],"tags":[{"name":"Heap","slug":"Heap","permalink":"https://e99net.github.io/tags/Heap/"}]},{"title":"千万级大表的MySQL优化","slug":"mysqlOptimizationOfLargeTable","date":"2021-01-19T14:52:53.672Z","updated":"2021-01-19T15:14:43.912Z","comments":false,"path":"2021/01/19/mysqlOptimizationOfLargeTable/","link":"","permalink":"https://e99net.github.io/2021/01/19/mysqlOptimizationOfLargeTable/","excerpt":"SQL语句优化 避免select * 在解析的过程中，会将“*”依次转换成所有的列名，这个工作是通过查询数据字典完成的，这意味着将耗费更多的时间 应该养成一个需要什么就取什么的好习惯","keywords":null,"text":"SQL语句优化 避免select * 在解析的过程中，会将“*”依次转换成所有的列名，这个工作是通过查询数据字典完成的，这意味着将耗费更多的时间 应该养成一个需要什么就取什么的好习惯 ORDER BY语句优化 任何在ORDER BY语句的非索引项或者有计算表达式都将降低查询速度 方法： 重写ORDER BY语句以使用索引 为所使用的列建立另外一个索引 绝对避免在ORDER BY子句中使用表达式 GROUP BY语句优化 提高GROUP BY语句的效率, 可以通过将不需要的记录在GROUP BY 之前过滤掉（如下例，先用where语句过滤掉一部分数据） 低效： 12345SELECT JOB, AVG(SAL)FROM EMPGROUP by JOBHAVING JOB = 'PRESIDENT'OR JOB = 'MANAGER' 高效： 12345SELECT JOB, AVG(SAL)FROM EMPWHERE JOB = 'PRESIDENT'OR JOB = 'MANAGER'GROUP by JOB 用exists代替in 很多时候用exists代替in是一个好的选择，如 1select num from a where num in(select num from b) 用下面的语句替换： 1select num from a where exists(select 1 from b where num=a.num) 尽量使用varchar/nvarchar代替char/nchar 变长字段存储空间小，可以节省存储空间 对于查询来说，在一个相对较小的字段内搜索效率显然要高些 能用DISTINCT的就不用GROUP BY 1SELECT OrderID FROM Details WHERE UnitPrice &gt; 10 GROUP BY OrderID 可改为： 1SELECT DISTINCT OrderID FROM Details WHERE UnitPrice &gt; 10 能用UNION ALL就不要用UNION UNION ALL不执行SELECT DISTINCT函数，这样就会减少很多不必要的资源。（UNION ALL允许重复） 在join表的时候使用相同类型的字段，并将其索引 如果应用程序有很多join查询，应该确认两个表中join的字段是被建过索引的。这样，MySQL内部会启动优化join的SQL语句的机制 被用来join的字段应该具有相同的类型。例如，如果把DECIMAL字段和一个INT字段join在一起，MySQL将无法使用它们的索引。对于那些STRING类型，还需要有相同的字符集才行（两个表的字符集有可能不一样） 索引优化 在适合建索引的地方建立索引（索引并非越多越好） 适合建索引的情况 主键会自动建立唯一索引 频繁作为 where 条件语句查询的字段 关联字段，例如外键字段 排序字段，因为排序字段若通过索引去访问将大大提高排序速度（索引干两件事：检索和排序） 分组字段，因为分组的前提是排序 统计字段，例如 count()、max() 高并发下倾向于创建组合索引，而不是单键索引。组合索引是由多个字段构成的索引，组合索引中的字段顺序是非常重要的，越是唯一的字段越是要靠前（根据最左前缀准则）。 不适合建索引的情况 表记录太少的情况下 频繁更新的字段、经常增删改的字段，因为修改性能和检索性能是互相矛盾的，每次更新不仅会更新记录还会更新索引 where 条件中用不到的字段，在查询中很少使用或参考的列 数据重复且分布比较均匀的字段，即唯一性太差的字段，例如性别、真假值 参与计算的列 避免有索引但未被用到的情况（索引失效时，MySQL 会进行全表扫描） 无查询条件 一些关键字会导致索引失效 where 语句中使用&lt;&gt;、!=、not in、not exist、is null、is not unll（使用&gt;或&lt;会比较高效） where 语句中使用 or（注意：or 中所有的字段都加上索引才会使用索引） 以通配符“%”开头的 like 查询（注意：以“%”结尾的 like 查询会使用索引） 避免 where 条件不符合最左前缀原则，最左前缀原则：mysql 会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如 a = 1 and b = 2 and c &gt; 3 and d= 4 如果建立(a,b,c,d)顺序的索引，d 是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d 的顺序可以任意调整（IN 和=可以乱序）。（多列索引没有遵循最左匹配原则，未使用第一个） 如果列类型是字符串，那一定要在条件中将数据用引号引起来,否则不使用索引 隐式转换会导致索引失效，比如数据库中的 id 是 number 类型，在查询时却出现“……where id=”123””。 对索引字段应用内部函数 对索引字段进行运算","raw":null,"content":null,"categories":[{"name":"Database","slug":"Database","permalink":"https://e99net.github.io/categories/Database/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://e99net.github.io/tags/MySQL/"}]},{"title":"Go语言做的不好的几个地方","slug":"weaknessOfGolang","date":"2021-01-19T14:22:08.223Z","updated":"2021-01-19T14:44:07.044Z","comments":false,"path":"2021/01/19/weaknessOfGolang/","link":"","permalink":"https://e99net.github.io/2021/01/19/weaknessOfGolang/","excerpt":"浮点型比其他语言要差 运算时，计算结果不准 四舍五入时，用的是银行舍入法，和其他语言四舍五入的值对不上。解决方法如下： 123456//四舍五入 取精度func ToFixed(f float64,places int) float64&#123; shift := math.Pow(10, float64(places)) fv := 0.0000000001 + f //对浮点数产生.xxx999999999 计算不准进行处理 return math.Floor(fv * shift + .5) / shift&#125;","keywords":null,"text":"浮点型比其他语言要差 运算时，计算结果不准 四舍五入时，用的是银行舍入法，和其他语言四舍五入的值对不上。解决方法如下： 123456//四舍五入 取精度func ToFixed(f float64,places int) float64&#123; shift := math.Pow(10, float64(places)) fv := 0.0000000001 + f //对浮点数产生.xxx999999999 计算不准进行处理 return math.Floor(fv * shift + .5) / shift&#125; 自带的json不好用 Golang中自带的json包可以用来解析json数据，但是Golang自带的json解析是通过反射机制实现json数据的解析的，这样就造成了解析性能的低下 json包在解析本地配置文件的场景下使用的较多，但在一些高并发的场景下就显得不足 对于json的解析，可以选择使用easyjson包，避免使用反射，从而提高解析的性能，在众多Golang高性能解析json的框架中，easyjson名列前茅，比go语言自带的json序列化快几倍 easyjson在解析json数据的时候，并不是使用反射机制，而只针对预先定义好的json结构体对输入的json字符串进行纯字符串的截取，并将对应的json字段赋值给结构体 easyjson在解析json数据的时候虽然并不会使用反射机制，但是在使用easyjson生成解析代码的时候，easyjson还是会使用反射机制的，所以我们需要为每个解析字段指定FieldTag，否则easyjson就会将变量名当作解析字段生成解析代码，当然解析代码生成之后，easyjson解析json数据就和反射机制没有关系了 使用Benchmark测试Golang内置的json包以及eashjson包的性能，解析相同的json数据并对解析好的Struct进行json转换， 测试结果表明，easyjson的运行时间大约是json包的三分之一，easyjson在单次运行占用内存和内存分配次数上也要比Golang内置的json包表现好很多","raw":null,"content":null,"categories":[{"name":"memo","slug":"memo","permalink":"https://e99net.github.io/categories/memo/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://e99net.github.io/tags/Go/"}]},{"title":"macOS新手上路","slug":"new_to_macOS","date":"2020-10-04T18:46:33.000Z","updated":"2020-10-04T18:46:33.000Z","comments":true,"path":"2020/10/05/new_to_macOS/","link":"","permalink":"https://e99net.github.io/2020/10/05/new_to_macOS/","excerpt":"安装软件 Hands Off! Proxifier The Unarchiver Itsycal BetterTouchTool Alfred 4 HandShaker","keywords":null,"text":"安装软件 Hands Off! Proxifier The Unarchiver Itsycal BetterTouchTool Alfred 4 HandShaker","raw":null,"content":null,"categories":[{"name":"memo","slug":"memo","permalink":"https://e99net.github.io/categories/memo/"}],"tags":[{"name":"Water","slug":"Water","permalink":"https://e99net.github.io/tags/Water/"}]},{"title":"前n小的和","slug":"first_n_small_sum","date":"2020-03-15T05:07:25.941Z","updated":"2020-03-15T05:21:42.235Z","comments":false,"path":"2020/03/15/first_n_small_sum/","link":"","permalink":"https://e99net.github.io/2020/03/15/first_n_small_sum/","excerpt":"两序列前n小的两数和 描述：有两个长度都是N的序列A和B，在A和B中各取一个数相加可以得到$N^2$个和，求这$N^2$个和中最小的N个。","keywords":null,"text":"两序列前n小的两数和 描述：有两个长度都是N的序列A和B，在A和B中各取一个数相加可以得到$N^2$个和，求这$N^2$个和中最小的N个。 输入： 第一行输入一个正整数N，$1 \\le N \\le 100000$，表示序列长度； 第二行输入N个整数$A_i$，满足$A_i \\le A_{i+1}$且$A_i \\le 10^9$； 第二行输入N个整数$B_i$，满足$B_i \\le B_{i+1}$且$B_i \\le 10^9$。 输出： 输出仅一行，包含N个整数，从小到大输出这N个最小的和，相邻数字之间用空格隔开。 样例输入： 32 6 61 4 8 样例输出： 3 6 7 解题思路： 由题意可得A和B是两个升序排列的序列，其中： A[1]+B[1] &lt;= A[2]+B[1] &lt;= … &lt;= A[N]+B[1] A[1]+B[2] &lt;= A[2]+B[2] &lt;= … &lt;= A[N]+B[2] …… A[1]+B[N] &lt;= A[2]+B[N] &lt;= … &lt;= A[N]+B[N] 接下来，就相当于要将这N个有序队列进行合并排序： 首先，将这N个队列中的第一个元素放入一个堆中； 然后；每次取出堆中的最小值。若这个最小值来自于第k个队列，那么，就将第k个队列的下一个元素放入堆中。 时间复杂度：O(NlogN)。 堆可用优先队列实现，此题需要的是一个小顶堆。 参考代码:123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;#include &lt;queue&gt;using namespace std;const int N=1e5+10;typedef pair&lt;int,int&gt; PII;int n;int a[N],b[N],next_of_a[N];int i;int main()&#123; priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt; &gt; pq;//小顶堆 scanf(&quot;%d&quot;,&amp;n); for(i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); for(i=1;i&lt;=n;i++) &#123; scanf(&quot;%d&quot;,&amp;b[i]); next_of_a[i]=2; pq.push(&#123;a[1]+b[i],i&#125;); &#125; while(n--) &#123; printf(&quot;%d &quot;,pq.top().first); i=pq.top().second; pq.pop(); pq.push(&#123;a[next_of_a[i]++]+b[i],i&#125;); &#125; return 0;&#125;","raw":null,"content":null,"categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://e99net.github.io/categories/Algorithm/"}],"tags":[{"name":"Heap","slug":"Heap","permalink":"https://e99net.github.io/tags/Heap/"}]},{"title":"数组跳跃问题","slug":"simpleproblemofjump","date":"2019-11-17T06:01:03.776Z","updated":"2020-03-15T05:06:51.634Z","comments":false,"path":"2019/11/17/simpleproblemofjump/","link":"","permalink":"https://e99net.github.io/2019/11/17/simpleproblemofjump/","excerpt":"跳跃游戏 描述：给定数组arr，arr[i]=k代表可以从位置i向右跳1 ~ k个距离。比如，arr[2]=3，代表从位置2可以跳到位置3、位置4或位置5。如果从位置0出发，返回最少跳几次能跳到arr最后的位置上。如果arr长度为N，要求实现时间复杂度为O(N)、额外空间复杂度为O(1)的解法。","keywords":null,"text":"跳跃游戏 描述：给定数组arr，arr[i]=k代表可以从位置i向右跳1 ~ k个距离。比如，arr[2]=3，代表从位置2可以跳到位置3、位置4或位置5。如果从位置0出发，返回最少跳几次能跳到arr最后的位置上。如果arr长度为N，要求实现时间复杂度为O(N)、额外空间复杂度为O(1)的解法。 输入： 第一行输入一个正整数N，$1 \\le N \\le 100$，表示数组的元素数。 第二行输入N个数，用空格隔开，表示一个数组中的所有数。 输出： 输出一个整数，表示最少跳几次。 样例输入： 63 2 3 1 1 4 样例输出： 2 样例解释： arr[0]=3，选择跳到位置2；arr[2]=3，可以跳到最后的位置。所以返回2。 解题思路： 这道题是一道简单的不能再简单的“水题”，可以说是动态规划的入门题。会者不难，难者不会。 思路太简单，略，←_←。直接上代码。感觉和剑指offer上“股票的最大利润”一题有点像。 参考代码:1234567891011121314151617class Solution &#123;public: int jump(vector&lt;int&gt;&amp; arr) &#123; if(arr.empty()) return 0; int jump=0; int cur=0; int next=0; for(int i=0;i&lt;arr.size();i++) &#123; if(cur&lt;i) &#123; jump++; cur=next; &#125; next=max(next,i+arr[i]); &#125; return jump; &#125;&#125;;","raw":null,"content":null,"categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://e99net.github.io/categories/Algorithm/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://e99net.github.io/tags/Dynamic-Programming/"}]},{"title":"一道算法编程题","slug":"liulishuo","date":"2019-11-10T12:12:51.364Z","updated":"2019-11-10T12:31:33.803Z","comments":false,"path":"2019/11/10/liulishuo/","link":"","permalink":"https://e99net.github.io/2019/11/10/liulishuo/","excerpt":"火车站台数量 描述：假设已知某个火车站的所有过往列车的到达arrival和离开departure时间（同一天），如果要求所有列车都不等待直接进站，问至少需要多少个站台。无需考虑晚点等特殊情况。","keywords":null,"text":"火车站台数量 描述：假设已知某个火车站的所有过往列车的到达arrival和离开departure时间（同一天），如果要求所有列车都不等待直接进站，问至少需要多少个站台。无需考虑晚点等特殊情况。 输入： 第一行输入一个正整数N，$1 \\le N \\le 100$，表示过往列车数。 第二行输入N个字符串，每个字符串表示列车的到达时间，字符串之间用空格隔开。 第三行输入N个字符串，每个字符串表示列车的离开时间，字符串之间用空格隔开。 输出： 输出一个整数，表示最少需要的站台数。 样例输入： 69:00 9:40 9:50 11:00 15:00 18:009:10 12:00 11:20 11:30 19:00 20:00 样例输出： 3 样例解释： 最多有3辆列车同时进站（在11:00到11:20之间），所以至少需要3个火车站台。 解题思路： 题目要求找到所有时间中同时在车站的列车的最大数量。一个简单的方案是逐个检查每个车辆的停发时间段，然后看有多少个时间段区间与其有重合，记录最多的重合区间数目，即为待求解的答案。易知，此方法的时间复杂度为O(n^2)。认真思考后，其实可以有O(nlog_2 n)时间复杂度的方法。思路是将所有的事件 (到达或离开)按时间顺序排序，然后只记录当前还在车站（未离开的）列车。所有时间点中最多数量列车即待求解的答案。例如，对于上面样例输入，将所有事件按时间排序后得到： 时间 事件 需要的站台数量 9:00 Arrival 1 9:10 Departure 0 9:40 Arrival 1 9:50 Arrival 2 11:00 Arrival 3 11:20 Departure 2 11:30 Departure 1 12:00 Departure 0 15:00 Arrival 1 18:00 Arrival 2 19:00 Departure 1 20:00 Departure 0 最多需要的站台数量是3，时间段为11:00 ~ 11:20 注意，在算法实现时，只需对到达时间arr数组，和离开时间dep数组进行单独排序，然后将两个有序数组再进行归并操作。 参考代码:12345678910#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int main() &#123; return 0;&#125;","raw":null,"content":null,"categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://e99net.github.io/categories/Algorithm/"}],"tags":[{"name":"Simulation","slug":"Simulation","permalink":"https://e99net.github.io/tags/Simulation/"}]},{"title":"两道算法编程题","slug":"webank","date":"2019-11-10T11:15:19.892Z","updated":"2019-11-10T12:07:22.337Z","comments":false,"path":"2019/11/10/webank/","link":"","permalink":"https://e99net.github.io/2019/11/10/webank/","excerpt":"数组排序 描述： 你需要对一个数组进行排序（升序），每一次，你可以将一个数移动到任意位置，这一次操作的代价是这个数的大小。最少需要多少代价才能将整个数组排序？","keywords":null,"text":"数组排序 描述： 你需要对一个数组进行排序（升序），每一次，你可以将一个数移动到任意位置，这一次操作的代价是这个数的大小。最少需要多少代价才能将整个数组排序？ 输入： 第一行输入一个正整数N，$1 \\le N \\le 100$，表示数组元素个数。 第二行输入N个整数，整数之间用空格隔开。 输出： 输出一个整数，表示将整个数组排序的最小代价。 样例输入： 48 1 2 3 样例输出： 6 解题思路： 求出里面和最大的升序数组，用数组和减去它就是结果了。因为最终的数组和原来的数组，差别就在于那些移动了位置的数，要让移动位置的代价最小，当然就是让移动位置的数的和最小，等价于不移动位置的数的和最大，而最大的升序数组和就是能够不移动位置的最大子数组。最大的升序数组和可用dp求出。 参考代码:12345678910#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int main() &#123; return 0;&#125; 取棋子 描述： 西西有一个N行N列的棋盘，其中某些格子上放有棋子（黑子或白子）。西西不希望棋盘上有两个相邻的格子放 着颜色相同的棋子，与第i行 第j列的格子相邻的格子为： 第i-1行第j列的格子（当i&gt;1时）； 第i+1行第j列的格子（当i&lt;N时）； 第i行第i-1列的格子（当i&gt;1时）； 第i行第i+1列的格子（当i&lt;N时）。 现在，西西可以取走棋盘上的某些棋子，使得剩下的棋子中，任意两个颜色相同的棋子所在的格子不相邻。那么， 棋盘上最多剩下多少个棋子？ 输入： 第一行输入一个正整数N，$N \\le 50$，表示棋盘的行列数。 接下来的N行，每行有N个整数，整数之间用空格隔开，表示棋盘每行每列防止棋子的情况。整数取值只能是0、1、2，分别表示该格未放棋子、放的是黑子、放的是白子。 输出： 输出一个整数，表示棋盘上最多剩下的棋子数。 样例输入： 样例输出： 解题思路： 给每个棋子设置一个度(0 1 2 3 4)。一个棋子周围每有一个同样颜色的棋子，那就让它的度加1，最小为0，最大为4。然后从棋盘里逐个删掉度是4的并且更新棋盘(周围的同样颜色的棋子度要剪1)，然后删掉度是3的，以此类推知道所有棋子度是0，看这时候删了多少棋子。 用4个hash set分别保存度为1 2 3 4的点，每删一个度为4的点，就更新所有它周围的节点，然后再继续进行删除。对黑的进行一次删除，再对白的进行一次删除，就能求出结果了。 这个方法对相连的度为4的点还要额外讨论。图中的两个点度都为4，但删绿的总共删四个，删红的 总共删五个。所以又想出一个方法：先取连通的区域 统计如果在国际象棋棋盘中 黑格和白格点数 然后删少的。在上图中就是黑7白4，删白的。五个同色棋子，白格一个，黑格四个，删白格。但这种方法还是有badcase。 所以……我也不知道咋做！ 参考代码:12345678910#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int main() &#123; return 0;&#125;","raw":null,"content":null,"categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://e99net.github.io/categories/Algorithm/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://e99net.github.io/tags/Dynamic-Programming/"},{"name":"Greedy","slug":"Greedy","permalink":"https://e99net.github.io/tags/Greedy/"}]},{"title":"宽搜手工写队列","slug":"bytedance_2019_2","date":"2019-10-26T07:10:04.956Z","updated":"2019-10-26T07:52:46.047Z","comments":false,"path":"2019/10/26/bytedance_2019_2/","link":"","permalink":"https://e99net.github.io/2019/10/26/bytedance_2019_2/","excerpt":"二维数组区块计数 描述： 输入一个只包含0和1的二维数组，上下左右和对角相邻的1组成一个区块，0不形成区块，求数组中的区块个数。","keywords":null,"text":"二维数组区块计数 描述： 输入一个只包含0和1的二维数组，上下左右和对角相邻的1组成一个区块，0不形成区块，求数组中的区块个数。 输入： 第一行输入两个正整数N和M，N表示数组行数，M表示数组列数。 接下来N行，每行表示数组对应的一行，每行包含M个整数，整数之间用空格隔开。 输出： 输出一个整数，表示数组中区块的个数。 数据范围： $0 \\le N,M,N*M \\le 10^6$ 样例输入： 3 30 1 01 0 01 0 1 样例输出： 2 样例解释： 数组右下角的1单独构成一个区块，其他的3个1对角或上下相邻，构成另一个区块。 解题思路：宽搜/深搜 参考代码: 12345678910111213141516171819202122232425262728293031323334353637//dfs#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;typedef pair&lt;int,int&gt; PII;const int N=1000010;int n,m;int g[N];void dfs(int x,int y) &#123; g[x*m+y]=0; for(int i=-1;i&lt;=1;i++) for(int j=-1;j&lt;=1;j++) &#123; int a=x+i,b=y+j; if(a&gt;=0&amp;&amp;a&lt;n&amp;&amp;b&gt;=0&amp;&amp;b&lt;m&amp;&amp;g[a*m+b]) dfs(a,b); &#125;&#125;int main() &#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=0,k=0;i&lt;n;i++) for(int j=0;j&lt;m;j++,k++) scanf(&quot;%d&quot;,&amp;g[k]); int res=0; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++) &#123; if(g[i*m+j]) &#123; res++; dfs(i,j); &#125; &#125; printf(&quot;%d\\n&quot;,res); return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//bfs，用STL中的queue#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;typedef pair&lt;int,int&gt; PII;const int N=1000010;int n,m;int g[N];void bfs(int sx,int sy) &#123; queue&lt;PII&gt; q; q.push(&#123;sx,sy&#125;); g[sx*m+sy]=0; while(q.size()) &#123; auto t=q.front(); q.pop(); int x=t.first,y=t.second; for(int i=-1;i&lt;=1;i++) for(int j=-1;j&lt;=1;j++) &#123; int a=x+i,b=y+j; if(a&gt;=0&amp;&amp;a&lt;n&amp;&amp;b&gt;=0&amp;&amp;b&lt;m&amp;&amp;g[a*m+b]) &#123; g[a*m+b]=0; q.push(&#123;a,b&#125;); &#125; &#125; &#125;&#125;int main() &#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=0,k=0;i&lt;n;i++) for(int j=0;j&lt;m;j++,k++) scanf(&quot;%d&quot;,&amp;g[k]); int res=0; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++) if(g[i*m+j]) &#123; res++; bfs(i,j); &#125; printf(&quot;%d\\n&quot;,res); return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445//bfs，用手工写的队列#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;typedef pair&lt;int,int&gt; PII;const int N=1000010;int n,m;int g[N];PII q[N];void bfs(int sx,int sy) &#123; int hh=0,tt=0; q[0]=&#123;sx,sy&#125;; g[sx*m+sy]=0; while(hh&lt;=tt) &#123; PII t=q[hh++]; int x=t.first,y=t.second; for(int i=-1;i&lt;=1;i++) for(int j=-1;j&lt;=1;j++) &#123; int a=x+i,b=y+j; if(a&gt;=0&amp;&amp;a&lt;n&amp;&amp;b&gt;=0&amp;&amp;b&lt;m&amp;&amp;g[a*m+b]) &#123; g[a*m+b]=0; q[++tt]=&#123;a,b&#125;; &#125; &#125; &#125;&#125;int main() &#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=0,k=0;i&lt;n;i++) for(int j=0;j&lt;m;j++,k++) scanf(&quot;%d&quot;,&amp;g[k]); int res=0; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++) if(g[i*m+j]) &#123; res++; bfs(i,j); &#125; printf(&quot;%d\\n&quot;,res); return 0;&#125; 运行时间： 用dfs：1003ms 用bfs： 用STL中的queue：1932ms 用手工写的队列：1036ms","raw":null,"content":null,"categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://e99net.github.io/categories/Algorithm/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://e99net.github.io/tags/DFS/"},{"name":"BFS","slug":"BFS","permalink":"https://e99net.github.io/tags/BFS/"}]},{"title":"立方体塔","slug":"bytedance_2019_1","date":"2019-10-26T05:16:58.977Z","updated":"2019-10-26T06:23:10.941Z","comments":false,"path":"2019/10/26/bytedance_2019_1/","link":"","permalink":"https://e99net.github.io/2019/10/26/bytedance_2019_1/","excerpt":"描述： 小方有w个白色立方体和b个黑色立方体，现在小方想把它们堆成一个立方体塔。 一座高度为h的立方体塔，最底层有h个立方体，每往上一层，所需立方体减一，直到最高层只需要一个立方体。 为了让这座塔看起来美观，小方希望每一层都只能用一种颜色的立方体。 小方希望把这座塔叠的尽可能高，因此他想知道塔的最大高度是多少，以及这个高度的立方体塔能有几种。 两种立方体塔，当且仅当至少有一层的颜色是不同的，则被认为是不同的。","keywords":null,"text":"描述： 小方有w个白色立方体和b个黑色立方体，现在小方想把它们堆成一个立方体塔。 一座高度为h的立方体塔，最底层有h个立方体，每往上一层，所需立方体减一，直到最高层只需要一个立方体。 为了让这座塔看起来美观，小方希望每一层都只能用一种颜色的立方体。 小方希望把这座塔叠的尽可能高，因此他想知道塔的最大高度是多少，以及这个高度的立方体塔能有几种。 两种立方体塔，当且仅当至少有一层的颜色是不同的，则被认为是不同的。 输入： 共一行，包含两个整数w和b。 输出： 共一行，包含两个整数h和c，分别表示最高塔的高度以及此高度塔的种类数。 因为种类数可能较多，请将c对$10^9+7$取模后的值输出。 数据范围： $0 \\le w,b \\le 10^5$ 样例输入： 1 14 6 样例输出： 1 24 2 解题思路：0/1背包问题求方案数 假设用到的白色块总数是a，那么“1到h层有多少种选法使得白色块总数是a”就是最后此高度塔的种类数。1到h层有多少种选法使得白色块总数是a，即选出1 ~ h中的若干数，让这些数的加和是a。a不是确定的，还要枚举一下a。对于每个a都求一个f[a]，那么$\\sum f[a]$就是答案。 f(i,j)是在考虑前i个物品的情况下，体积是j的方案数，有$f(i,j)=f(i-1,j)+f(i-1,j-v[i])$，做恒等变形得$f(j)=f(j)+f(j-i)$，在这里v[i]就是i，第i个物品的体积就是i。 参考代码: 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N=100010,mod=1e9+7;int f[N];int main() &#123; int n,m; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); int h=1; while(h*(h+1)/2&lt;=n+m) h++; h--; //swap(n,m); f[0]=1; for(int i=1;i&lt;=h;i++) &#123; for(int j=n;j&gt;=i;j--) &#123; f[j]=(f[j]+f[j-i])%mod; &#125; &#125; int res=0; for(int i=0;i&lt;=n;i++) if(h*(h+1)/2-i&lt;=m) res=(res+f[i])%mod; printf(&quot;%d %d\\n&quot;,h,res); return 0;&#125; 上述代码是滚动数组优化之后f变成一维的情况。f[N]等同于f[N][N],123456f[0]=1;for(int i=1;i&lt;=h;i++) &#123; for(int j=n;j&gt;=i;j--) &#123; f[j]=(f[j]+f[j-i])%mod; &#125;&#125; 等同于123456f[0][0]=1;for(int i=1;i&lt;=h;i++) for(int j=0;j&lt;=n;j++) &#123; f[i][j]=f[i-1][j];//不选第i个物品 if(j&gt;=i) f[i][j]+=f[i-1][j-i];//如果体积够的话就可以选第i个物品 &#125; 二维变成一维的过程是对代码做恒等变形的过程，f[i][j]=f[i-1][j]和f[j]=f[j]就完全一样了，可以删掉（f[j]本来就等于f[j]）。 if(j&gt;=i)可以写到第二个循环里去，将for(int j=0;j&lt;=n;j++)变成for(int j=i;j&lt;=n;j++)，因为j &lt; i时循环压根不会执行。 剩下的就是对f[i][j]+=f[i-1][j-i]的变形，如果j从小到大枚举，那么f[i][j]+=f[i-1][j-i]不会等价于f[j]+=f[j-i]：i是大于0的，所以j-i一定是小于j的，从小到大枚举j的话会先算f[j-i]再算f[j]，先算f[j-i]的时候是在第i层算的，那f[j]+=f[j-i]就等价于f[i][j]+=f[i][j-i]，而不等价于f[i][j]+=f[i-1][j-i]。 将j改为从大到小枚举（for(int j=n;j&gt;=i;j–)）的话就可以了，此时j-i还是比j小，但变成f[j-i]在f[j]后面算（因为j从大到小枚举），此时f[j-i]用的就不是第i层的f[j-i]（因为还没算到），而是上一层——第i-1层的f[j-i]（还没被更新），那f[j]+=f[j-i]就和f[i][j]+=f[i-1][j-i]等价了。","raw":null,"content":null,"categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://e99net.github.io/categories/Algorithm/"}],"tags":[{"name":"Knapsack","slug":"Knapsack","permalink":"https://e99net.github.io/tags/Knapsack/"}]},{"title":"几道比较有意思的字符串题","slug":"string","date":"2019-10-21T08:41:40.209Z","updated":"2020-12-20T13:35:39.928Z","comments":false,"path":"2019/10/21/string/","link":"","permalink":"https://e99net.github.io/2019/10/21/string/","excerpt":"整数反转求和 描述： 请您写一个reverseAdd函数，该函数分别将输入的两个正整数a和b的数字按照高位在右的方式反转求和。例如，reverseAdd(123,456)=321+654=975。","keywords":null,"text":"整数反转求和 描述： 请您写一个reverseAdd函数，该函数分别将输入的两个正整数a和b的数字按照高位在右的方式反转求和。例如，reverseAdd(123,456)=321+654=975。 输入： 两个正整数a和b，以空格分隔，$1 \\le a,b \\le 70000$。 输出： 输出一个整数，表示两个正整数反转求和的结果。 样例输入： 123 456 样例输出： 975 解题思路： 按照int型来处理两个输入参数会比较麻烦，按照字符串类型来处理两个输入参数则会大大简化处理过程。 参考代码: 1234567891011121314151617#include&lt;iostream&gt;using namespace std;int main() &#123; string n,m; while(cin&gt;&gt;n&gt;&gt;m) &#123; int x=0,y=0,i; if(m[0]==&apos;0&apos;&amp;&amp;n[0]==&apos;0&apos;) break; for(i=m.size()-1;i&gt;=0;i--) x=x*10+m[i]-&apos;0&apos;; for(i=n.size()-1;i&gt;=0;i--) y=y*10+n[i]-&apos;0&apos;; cout&lt;&lt;x+y&lt;&lt;endl; &#125; return 0;&#125; 字符串计数 描述： 给定一个仅由小写字母组成且长度不超过106的字符串，将首字符移到末尾并记录所得的字符串，不断重复该操作，虽然记录了无限个字符串，但其中不同字符串的数目却是有限的，那么一共记录了多少个不同的字符串？ 输入： 给定的字符串。 输出： 记录的不同字符串数目。 输入样例： abab 输出样例： 2 解题思路： 模板题，考查KMP算法next数组的求解 参考代码：123456789101112131415161718#include&lt;bits/stdc++.h&gt;using namespace std;const int N=1000007;char s[N];int next[N];int main() &#123; scanf(&quot;%s&quot;,s); int n=strlen(s); next[0]=-1; for(int i=0,j=-1;i&lt;n;) if(j==-1||s[i]=s[j]) next[++i]=++j; else j=next[j]; if(n%(n-next[n])) printf(&quot;%d&quot;,n) else printf(&quot;%d&quot;,n-next[n]); return 0;&#125;","raw":null,"content":null,"categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://e99net.github.io/categories/Algorithm/"}],"tags":[{"name":"String","slug":"String","permalink":"https://e99net.github.io/tags/String/"}]},{"title":"背包问题总结","slug":"knapsack","date":"2019-10-21T03:51:37.001Z","updated":"2019-10-22T15:00:50.330Z","comments":false,"path":"2019/10/21/knapsack/","link":"","permalink":"https://e99net.github.io/2019/10/21/knapsack/","excerpt":"0/1背包问题 描述： 有$N$件物品和一个容量是$V$的背包。 第$i$件物品的体积是$v_i$，价值是$w_i$。 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。","keywords":null,"text":"0/1背包问题 描述： 有$N$件物品和一个容量是$V$的背包。 第$i$件物品的体积是$v_i$，价值是$w_i$。 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。 输入： 第一行两个整数$N$和$V$，$0 &lt; N,V \\le 1000$，用空格隔开，分别表示物品数量和背包容积。 接下来有$N$行，每行两个整数$v_i$和$w_i$，$0 &lt; v_i,w_i \\le 1000$，用空格隔开，分别表示第$i$件物品的体积和价值。 输出： 输出一个整数，表示最大价值。 样例输入： 4 51 22 43 44 5 样例输出： 8 参考代码: 123456789101112131415161718#include&lt;iostream&gt;using namespace std;const int N=1010;int n,m;int f[N];int main() &#123; cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++) &#123; int c,w; cin&gt;&gt;c&gt;&gt;w; for(int j=m;j&gt;=c;j--) f[j]=max(f[j],f[j-c]+w); &#125; cout&lt;&lt;f[m]&lt;&lt;endl; return 0;&#125; 完全背包问题 描述： 有$N$种物品和一个容量是$V$的背包，每种物品都有无限件可用。 第$i$种物品的体积是$v_i$，价值是$w_i$。 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。 输入： 第一行两个整数$N$和$V$，$0 &lt; N,V \\le 1000$，用空格隔开，分别表示物品种数和背包容积。 接下来有$N$行，每行两个整数$v_i$和$w_i$，$0 &lt; v_i,w_i \\le 1000$，用空格隔开，分别表示第$i$种物品的体积和价值。 输出： 输出一个整数，表示最大价值。 样例输入： 4 51 22 43 44 5 样例输出： 10 参考代码: 12345678910111213141516171819#include&lt;iostream&gt;using namespace std;const int N=1010;int n,m;int f[N];int main() &#123; cin&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++) &#123; int c,w; cin&gt;&gt;c&gt;&gt;w; for(int j=c;j&lt;=m;j++) f[j]=max(f[j],f[j-c]+w); &#125; int res=0; for(int i=0;i&lt;=m;i++) res=max(res,f[i]); cout&lt;&lt;res&lt;&lt;endl; return 0;&#125; 多重背包问题 描述： 有$N$种物品和一个容量是$V$的背包。 第$i$种物品最多有$s_i$件，每件体积是$v_i$，价值是$w_i$。 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且价值总和最大。输出最大价值。 暴力 O(N*M*S) 输入： 第一行两个整数$N$和$V$，$0 &lt; N,V \\le 100$，用空格隔开，分别表示物品种数和背包容积。 接下来有$N$行，每行三个整数$v_i$、$w_i$和$s_i$，$0 &lt; v_i,w_i,s_i \\le 100$，用空格隔开，分别表示第$i$件物品的体积、价值和数量。 输出： 输出一个整数，表示最大价值。 样例输入： 4 51 2 32 4 13 4 34 5 2 样例输出： 10 参考代码: 123456789101112131415161718192021#include&lt;iostream&gt;using namespace std;const int N=110;int n,m;int f[N];int main() &#123; cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++) &#123; int c,w,s; cin&gt;&gt;c&gt;&gt;w&gt;&gt;s; for(int j=m;j&gt;=0;j--) for(int k=1;k&lt;=s;k++) if(j&gt;=k*c) f[j]=max(f[j],f[j-k*c]+k*w); &#125; cout&lt;&lt;f[m]&lt;&lt;endl; return 0;&#125; 二进制优化 O(N*M*log S) 输入： 第一行两个整数$N$和$V$，$0 &lt; N \\le 1000$，$0 &lt; V \\le 2000$，用空格隔开，分别表示物品种数和背包容积。 接下来有$N$行，每行三个整数$v_i$、$w_i$和$s_i$，$0 &lt; v_i,w_i,s_i \\le 2000$，用空格隔开，分别表示第$i$件物品的体积、价值和数量。 输出： 输出一个整数，表示最大价值。 样例输入： 4 51 2 32 4 13 4 34 5 2 样例输出： 10 参考代码: 1234567891011121314151617181920212223242526272829303132#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;const int N=2010;int n,m;int f[N];struct Good &#123; int v,w;&#125;;int main() &#123; vector&lt;Good&gt; goods; cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++) &#123; int v,w,s; cin&gt;&gt;v&gt;&gt;w&gt;&gt;s; for(int k=1;j&lt;=s;k*=2) &#123; s-=k; goods.push_back(&#123;v*k,w*k&#125;); &#125; if(s&gt;0) goods.push_back(&#123;v*s,w*s&#125;); &#125; for(auto good:goods) for(int j=m;j&gt;=good.v;j--) f[j]=max(f[j],f[j-good.v]+good.w); cout&lt;&lt;f[m]&lt;&lt;endl; return 0;&#125; 单调队列优化 O(N*M) 输入： 第一行两个整数$N$和$V$，$0 &lt; N \\le 1000$，$0 &lt; V \\le 20000$，用空格隔开，分别表示物品种数和背包容积。 接下来有$N$行，每行三个整数$v_i$、$w_i$和$s_i$，$0 &lt; v_i,w_i,s_i \\le 20000$，用空格隔开，分别表示第$i$件物品的体积、价值和数量。 输出： 输出一个整数，表示最大价值。 样例输入： 4 51 2 32 4 13 4 34 5 2 样例输出： 10 参考代码: 1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;const int N=20010;int n,m;int f[N],g[N],q[N];int main() &#123; cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++) &#123; int c,w,s; cin&gt;&gt;c&gt;&gt;w&gt;&gt;s; memcpy(g,f,sizeof f); for(int j=0;j&lt;c;j++) &#123; int hh=0,tt=-1; for(int k=j;k&lt;=m;k+=c) &#123; f[k]=g[k]; if(hh&lt;=tt&amp;&amp;k-s*c&gt;q[hh]) hh++; if(hh&lt;=tt) f[k]=max(f[k],g[q[hh]]+(k-q[hh])/c*w); while(hh&lt;=tt&amp;&amp;g[q[tt]]-(q[tt]-j)/c*w&lt;=g[k]-(k-j)/c*w) tt--; q[++tt]=k; &#125; &#125; &#125; cout&lt;&lt;f[m]&lt;&lt;endl; return 0;&#125; 混合背包问题 描述： 有$N$种物品和一个容量是$V$的背包。 物品一共有三类： 第一类物品只能用1次（01背包） 第二类物品可以用无限次（完全背包） 第三类物品最多只能用$s_i$次（多重背包） 每种体积是$v_i$，价值是$w_i$。 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且价值总和最大。输出最大价值。 输入： 第一行两个整数$N$和$V$，$0 &lt; N,V \\le 1000$，用空格隔开，分别表示物品数量和背包容积。 接下来有$N$行，每行三个整数$v_i$、$w_i$和$s_i$，用空格隔开，分别表示第$i$件物品的体积、价值和数量。 $0 &lt; v_i,w_i \\le 1000$，$-1 \\le s_i \\le 1000$。 $s_i=-1$表示第$i$种物品只能用1次 $s_i=0$表示第$i$种物品可以用无限次 $s_i&gt;0$表示第$i$种物品可以使用$s_i$次 输出： 输出一个整数，表示最大价值。 样例输入： 4 51 2 -12 4 13 4 04 5 2 样例输出： 8 参考代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;const int N=1010;int n,m;int f[N];struct Thing &#123; int kind; int v,w;&#125;;vector&lt;Thing&gt; things;int main() &#123; cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++) &#123; int v,w,s; cin&gt;&gt;v&gt;&gt;w&gt;&gt;s; if(s&lt;0) things.push_back(&#123;-1,v,w&#125;); else if(s==0) things.push_back(&#123;0,v,w&#125;); else &#123; for(int k=1;k&lt;=s;k*=2) &#123; s-=k; things.push_back(&#123;-1,v*k,w*k&#125;); &#125; if(s&gt;0)things.push_back(&#123;-1,v*s,w*s&#125;); &#125; &#125; for(auto thing : things) &#123; if(thing.kind&lt;0) &#123; for(int j=m;j&gt;=thing.v;j--) f[j]=max(f[j],f[j-thing.v]+thing.w); &#125;else &#123; for(int j=thing.v;j&lt;=m;j++) f[j]=max(f[j],f[j-thing.v]+thing.w); &#125; &#125; cout&lt;&lt;f[m]&lt;&lt;endl; return 0;&#125; 二维费用的背包问题 描述： 有$N$件物品和一个容量是$V$的背包，背包能承受的最大重量是$M$。 每件物品只能用一次。体积是$v_i$，重量是$m_i$，价值是$w_i$。 求解将哪些物品装入背包，可使物品总体积不超过背包容量，总重量不超过背包可承受的最大重量，且价值总和最大。输出最大价值。 输入： 第一行三个整数$N$、$V$和$M$，$0 &lt; N \\le 1000$，$0 &lt; V,M \\le 100$，用空格隔开，分别表示物品件数、背包容积和背包可承受的最大重量。 接下来有$N$行，每行三个整数$v_i$、$m_i$和$w_i$，$0 &lt; v_i,m_i \\le 100$，$0 &lt; w_i \\le 1000$，用空格隔开，分别表示第$i$件物品的体积、重量和价值。 输出： 输出一个整数，表示最大价值。 样例输入： 4 5 61 2 32 4 43 4 54 5 6 样例输出： 8 参考代码: 123456789101112131415161718192021#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N=110;int n,v,m;int f[N][N];int main() &#123; cin&gt;&gt;n&gt;&gt;v&gt;&gt;m; for(int i=0;i&lt;n;i++) &#123; int a,b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; for(int j=v;j&gt;=a;j--) for(int k=m;k&gt;=b;k--) f[j][k]=max(f[j][k],f[j-a][k-b]+c); &#125; cout&lt;&lt;f[v][m]&lt;&lt;endl; return 0;&#125; 分组背包问题 描述： 有$N$组物品和一个容量是$V$的背包。 每组物品有若干个，同一组内的物品最多只能选一个。 每件物品的体积是$v_{ij}$，价值是$w_{ij}$，其中$i$是组号，$j$是组内编号。 求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。 输出最大价值。 输入： 第一行有两个整数$N$和$V$，$0 &lt; N,V \\le 100$，用空格隔开，分别表示物品组数和背包容量。 接下来有$N$组数据： 每组数据第一行有一个整数$S_i$，$0 &lt; S_i \\le 100$，表示第$i$个物品组的物品数量； 每组数据接下来有$S_i$行，每行有两个整数$v_{ij}$和$w_{ij}$，$0 &lt; v_{ij},w_{ij} \\le 100$，用空格隔开，分别表示第$i$个物品组的第$j$个物品的体积和价值。 输出： 输出一个整数，表示最大价值。 样例输入： 3 521 22 413 414 5 样例输出： 8 参考代码: 12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N=110;int n,m;int f[N],v[N],w[N];int main() &#123; cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++) &#123; int s; cin&gt;&gt;s; for(int j=0;j&lt;s;j++) cin&gt;&gt;v[j]&lt;&lt;w[j]; for(int j=m;j&gt;=0;j--) for(int k=0;k&lt;s;k++) if(j&gt;=v[k]) f[j]=max(f[j],f[j-v[k]]+w[k]); &#125; cout&lt;&lt;f[m]&lt;&lt;endl; return 0;&#125; 背包问题求方案数 描述： 有$N$件物品和一个容量是$V$的背包，每件物品只能使用一次。 第$i$件物品的体积是$v_i$，价值是$w_i$。 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。 输出最优选法的方案数，注意答案可能很大，请输出答案模$10^9+7$的结果。 输入： 第一行两个整数$N$和$V$，$0 &lt; N,V \\le 1000$，用空格隔开，分别表示物品数量和背包容积。 接下来有$N$行，每行两个整数$v_i$和$w_i$，$0 &lt; v_i,w_i \\le 1000$，用空格隔开，分别表示第$i$件物品的体积和价值。 输出： 输出一个整数，表示方案数模$10^9+7$的结果。 样例输入： 4 51 22 43 44 6 样例输出： 2 参考代码: 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N=1010,mod=1000000009,INF=1000000;int n,m;int f[N],g[N];int main() &#123; cin&gt;&gt;n&gt;&gt;m; g[0]=1; for(int i=1;i&lt;=m;i++) f[i]=-INF; for(int i=0;i&lt;n;i++) &#123; int v,w; cin&gt;&gt;v&gt;&gt;w; for(int j=m;j&gt;=v;j--) &#123; int t=max(f[j],f[j-v]+w); int s=0; if(t==f[j])s+=g[j]; if(t==f[j-v]+w)s+=g[j-v]; if(s&gt;=mod)s-=mod; f[j]=t; g[j]=s; &#125; &#125; int maxw=0; for(int i=0;i&lt;=m;i++) maxw=max(maxw,f[i]); int res=0; for(int i=0;i&lt;=m;i++) if(maxw==f[i]) &#123; res+=g[i]; if(res&gt;=mod) res-=mod; &#125; cout&lt;&lt;res&lt;&lt;endl; return 0;&#125; 求背包问题的方案 描述： 有$N$件物品和一个容量是$V$的背包，每件物品只能使用一次。 第$i$件物品的体积是$v_i$，价值是$w_i$。 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。 输出字典序最小的方案。这里的字典序是指：所选物品的编号所构成的序列。物品的编号范围是$1…N$。 输入： 第一行两个整数$N$和$V$，$0 &lt; N,V \\le 1000$，用空格隔开，分别表示物品数量和背包容积。 接下来有$N$行，每行两个整数$v_i$和$w_i$，$0 &lt; v_i,w_i \\le 1000$，用空格隔开，分别表示第$i$件物品的体积和价值。 输出： 输出一行，包含若干个用空格隔开的整数，表示最优解中所选物品的编号序列，且该编号序列的字典序最小。 物品编号范围是$1…N$。 样例输入： 4 51 22 43 44 6 样例输出： 1 4 参考代码: 1234567891011121314151617181920212223242526272829#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N=1010;int n,m;int v[N],w[N],f[N][N];int main() &#123; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) cin&gt;&gt;v[i]&gt;&gt;w[i]; for(int i=n;i&gt;=1;i--) &#123; for(int j=0;j&lt;=m;j++) &#123; f[i][j]=f[i+1][j]; if(j&gt;=v[i]) f[i][j]=max(f[i][j],f[i+1][j-v[i]]+w[i]); &#125; &#125; int vol=m; for(int i=1;i&lt;=n;i++) &#123; if(f[i][vol]==f[i+1][vol-v[i]]+w[i]) &#123; cout&lt;&lt;i&lt;&lt;&apos; &apos;; vol-=v[i]; &#125; &#125; return 0;&#125; 有依赖的背包问题非树形依赖的背包问题 描述： 金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间金明自己专用的很宽敞的房间。更让他高兴的是，妈妈昨天对他说：“你的房间需要购买哪些物品，怎么布置，你说了算，只要不超过$N$元钱就行”。今天一早，金明就开始做预算了，他把想买的物品分为两类：主件与附件，附件是从属于某个主件的，下表就是一些主件与附件的例子： |主件| 附件| |电脑| 打印机，扫描仪| |书柜| 图书| |书桌| 台灯，文具| |工作椅| 无| 如果要买归类为附件的物品，必须先买该附件所属的主件。每个主件可以有0个、1个或2个附件。附件不再有从属于自己的附件。金明想买的东西很多，肯定会超过妈妈限定的$N$元。于是，他把每件物品规定了一个重要度，分为5等：用整数1−5表示，第5等最重要。他还从因特网上查到了每件物品的价格（都是10元的整数倍）。他希望在不超过$N$元（可以等于$N$元）的前提下，使每件物品的价格与重要度的乘积的总和最大。 设第$j$件物品的价格为$v_[j]$，重要度为$w_[j]$，共选中了$k$件物品，编号依次为$j_1,j_2,…,j_k$，则所求的总和为：$$v_[j_1] \\times w_[j_1]+v_[j_2] \\times w_[j_2]+ …+v_[j_k] \\times w_[j_k]$$ 请你帮助金明设计一个满足要求的购物单。 输入： 第1行为两个正整数$n$和$m$，分别表示总钱数和希望购买物品的个数，$n&lt;32000$，$m&lt;60$，用空格隔开。 从第2行到第$m+1$行，第$j$行给出了编号为$j-1$的物品的基本数据，每行有3个非负整数$v$、$p$、$q$，分别表示该物品的价格、重要度（1-5）、是主件还是附件，$q=0$表示该物品为主件，$q&gt;0$表示该物品为附件且$q$是所属主件的编号，$v&lt;10000$。 输出： 一个正整数，为不超过总钱数的物品的价格与重要度乘积的总和的最大值。 样例输入： 1000 5800 2 0400 5 1300 5 1400 3 0500 2 0 样例输出： 2200 解题思路：分组背包 参考代码： 12 树形依赖的背包问题 描述： 有$N$个物品和一个容量是$V$的背包。 物品之间具有依赖关系，且依赖关系组成一棵树的形状。如果选择一个物品，则必须选择它的父节点。 如下图所示： 如果选择物品5，则必须选择物品1和2。这是因为2是5的父节点，1是2的父节点。 每件物品的编号是$i$，体积是$v_i$，价值是$w_i$，依赖的父节点编号是$p_i$，物品的下标范围是$1…N$。 求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。 输出最大价值。 输入： 第一行两个整数$N$和$V$，$1 \\le N,V \\le 100$，用空格隔开，分别表示物品个数和背包容量。 接下来有$N$行数据，每行数据表示一个物品。第$i$行有三个整数$v_i$,$w_i$,$p_i$，$1 &lt; v_i,w_i \\le 100$，用空格隔开，分别表示物品的体积、价值和依赖的物品编号。$p_i==-1$表示根节点，$1 \\le p_i \\le N$表示内部节点，数据保证所有物品构成一棵树。 输出： 输出一个整数，表示最大价值。 样例输入： 5 72 3 -12 2 13 5 14 7 23 6 2 样例输出： 11 解题思路：分组背包+树形dp 参考代码: 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N=110;int n,m;int h[N],e[N],ne[N],idx;int v[N],w[N],f[N][N];void add(int a,int b) &#123; e[idx]=b,ne[idx]=h[a],h[a]=idx++;&#125;void dfs(int u) &#123; for(int i=h[u];i!=-1;i=ne[i]) &#123; int son=e[i]; dfs(son); for(int j=m-v[u];j&gt;=0;j--) for(int k=0;k&lt;=j;k++) f[u][j]=max(f[u][j],f[u][j-k]+f[son][k]); &#125; for(int i=m;i&gt;=v[u];i--) f[u][i]=f[u][i-v[u]]+w[u]; for(int i=0;i&lt;v[u];i++) f[u][i]=0;&#125;int main() &#123; memset(h,-1,sizeof h); cin&gt;&gt;n&gt;&gt;m; int root; for(int i=1;i&lt;=n;i++) &#123; int p; cin&gt;&gt;v[i]&gt;&gt;w[i]&gt;&gt;p; if(p==-1) root=i; else add(p,i); &#125; dfs(root); cout&lt;&lt;f[root][m]&lt;&lt;endl; return 0;&#125;","raw":null,"content":null,"categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://e99net.github.io/categories/Algorithm/"}],"tags":[{"name":"Knapsack","slug":"Knapsack","permalink":"https://e99net.github.io/tags/Knapsack/"}]},{"title":"记一道算法编程题","slug":"meituan2019","date":"2019-10-21T03:33:49.258Z","updated":"2019-10-21T03:50:09.279Z","comments":false,"path":"2019/10/21/meituan2019/","link":"","permalink":"https://e99net.github.io/2019/10/21/meituan2019/","excerpt":"爱健身的小王 描述： 小王是一个喜欢健身的人，他每天都会围着一个n*n的场地外侧跑步。他是一个有强迫症的人，每跑n+1个单位长度，他就要在地上做一个标记。当他在一个点重复标记的时候，他就会结束当天的锻炼。显然当n一定时，他每天打标记的数量也是一定的。请你计算出来他每天要打多少标记（最后一次重复标记也要计数）。","keywords":null,"text":"爱健身的小王 描述： 小王是一个喜欢健身的人，他每天都会围着一个n*n的场地外侧跑步。他是一个有强迫症的人，每跑n+1个单位长度，他就要在地上做一个标记。当他在一个点重复标记的时候，他就会结束当天的锻炼。显然当n一定时，他每天打标记的数量也是一定的。请你计算出来他每天要打多少标记（最后一次重复标记也要计数）。 输入： 第一行包含一个正整数t，表示询问的数量。 第二行包含t个整数，中间用空格隔开，每个整数表示一个询问所给出的n，$1 \\le n \\le 1000$。 输出： 输出共t行，$1 \\le t \\le 10000$。 每行包含一个正整数，其中第i行的整数表示第i个询问的答案。 样例输入： 24 8 样例输出： 1733 样例解释： 对于4*4的场地而言，其边界上的16个点都会被标记，因为起点会被标记两次，所以共17次。 解题思路：最小公倍数 参考代码: 123456789101112131415161718#include&lt;bits/stdc++.h&gt;using namespace std;int gcd(int a,int b)&#123; return b?gcd(b,a%b):a;&#125;int main() &#123; int T; cin&gt;&gt;T; while(T--) &#123; int n; cin&gt;&gt;n; int d=gcd(4*n,n+1); cout&lt;&lt;4*n/d+1&lt;&lt;endl; &#125; return 0;&#125;","raw":null,"content":null,"categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://e99net.github.io/categories/Algorithm/"}],"tags":[{"name":"Number theory","slug":"Number-theory","permalink":"https://e99net.github.io/tags/Number-theory/"}]},{"title":"记五道2020年某企业提前批招聘笔试题","slug":"netease","date":"2019-10-07T02:44:38.279Z","updated":"2019-11-10T12:15:01.370Z","comments":false,"path":"2019/10/07/netease/","link":"","permalink":"https://e99net.github.io/2019/10/07/netease/","excerpt":"窗口点击模拟 描述： 本题需要让你模拟一下在Windows系统里窗囗和鼠标点击的操作，具体如下： 屏幕分辨率为3840 * 2160，左上角坐标为（0，0），右下角坐标为（3839，2159） 窗口是一个矩形的形状，由左上角坐标（X，Y），和宽高（W，H），四个数字来定位。左上角坐标为（X，Y）、右下角坐标为（X+W，Y+H），其中左上角坐标一定会在屏幕范围内，其他一些部分可能会超过屏幕范围。 窗囗的点击和遮挡规则同Windows，但是不考虑关闭窗囗、最大化、最小化和强制置顶的情况。即 3.1 如果发生重叠的话，后面打开的窗口会显示在前面打开的窗口上面 3.2 当鼠标发生一次点击的时候，需要判断点击到了哪个窗口，如果同个坐标有多个窗口，算点击到最上层的那个 3.3 当一个窗囗被点击的时候，会浮动到最上层","keywords":null,"text":"窗口点击模拟 描述： 本题需要让你模拟一下在Windows系统里窗囗和鼠标点击的操作，具体如下： 屏幕分辨率为3840 * 2160，左上角坐标为（0，0），右下角坐标为（3839，2159） 窗口是一个矩形的形状，由左上角坐标（X，Y），和宽高（W，H），四个数字来定位。左上角坐标为（X，Y）、右下角坐标为（X+W，Y+H），其中左上角坐标一定会在屏幕范围内，其他一些部分可能会超过屏幕范围。 窗囗的点击和遮挡规则同Windows，但是不考虑关闭窗囗、最大化、最小化和强制置顶的情况。即 3.1 如果发生重叠的话，后面打开的窗口会显示在前面打开的窗口上面 3.2 当鼠标发生一次点击的时候，需要判断点击到了哪个窗口，如果同个坐标有多个窗口，算点击到最上层的那个 3.3 当一个窗囗被点击的时候，会浮动到最上层 输入： 每个测试输入包含1个测试用例第一行为2个整数N，M。其中N表示打开的窗口数目，M表示鼠标点击的数目，0&lt;N，M&lt;1000接下来N行，每一行四个整数Xi Yi Wi Hi，分别表示第i个窗口（窗口Id为i，从1开始计数）的左上角坐标以及宽高，初始时窗口是按输入的顺序依次打开。其中0&lt;=Xi&lt;3840，0&lt;=Yi&lt;2160，0&lt;Wi&lt;3840，0&lt;Hi&lt;2160再接下来有M行，每一行两个整数xj Yj，分别表示接下来发生的鼠标点击坐标。其中0&lt;=Xj&lt;3840，0&lt;=Yj&lt;2160 输出： 对于每次鼠标点击，输出本次点击到的窗口Id。如果没有点击到窗口，输出-1 样例输入： 2 4100 100 100 10010 10 150 150105 105180 180105 1051 1 样例输出： 211-1 样例说明： 有2个窗口，第1个窗口左上角坐标为(100,100)，宽和高都是100，则其右下角坐标为(200,200)；第2个窗口左上角坐标为(10,10)，宽和高都是150，则其右下角坐标为(160,160)。 有4次鼠标点击，第1次点击的位置同时属于1号和2号窗口，但由于2号窗口在上面，所以它被选择并且被置于顶层；第2次点击的位置只属于1号窗口，因此该次点击选择了1号窗口并将其置于顶层，现在1号窗口在上，2号窗口在下；第3次点击的位置同时属于1号和2号窗口的范围，但由于1号窗口在上，所以它被选择；第4次点击的位置不属于任何窗口。 解题思路：模拟 用一个结构体数组存给出的窗口信息，根据题意，数组中越靠后的窗口优先级越高，因此，每次点击从数字后面开始扫描，扫到满足点击的窗口就输出对应的编号，并将它提到末尾。 参考代码: 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;using namespace std;const int N=1010;const int M=1010;int n,m;struct win &#123; int id,x,y,w,h;&#125;wins[N];//存窗口的结构体数组//将窗口i置于顶层void top(int i) &#123; win t=wins[i]; for(;i&lt;n-1;i++) wins[i]=wins[i+1]; wins[n-1]=t;&#125;int main() &#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=0;i&lt;n;i++) &#123; scanf(&quot;%d%d%d%d&quot;,&amp;wins[i].x,&amp;wins[i].y,&amp;wins[i].w,&amp;wins[i].h); wins[i].id=i+1; &#125; while(m--) &#123; int dx,dy,flag=0; scanf(&quot;%d%d&quot;,&amp;dx,&amp;dy); for(int i=n-1;i&gt;=0;i--) &#123; //判断鼠标点击范围 if(dx&gt;=wins[i].x&amp;&amp;dy&gt;=wins[i].y&amp;&amp;dx&lt;=wins[i].x+wins[i].w&amp;&amp;dy&lt;=wins[i].y+wins[i].h) &#123; printf(&quot;%d\\n&quot;,wins[i].id); top(i); flag=1; break; &#125; &#125; if(!flag) printf(&quot;-1&quot;); &#125; return 0;&#125; Stern-Brocot tree 描述： The Stern-Brocot tree is an infinite complete binary tree in which the vertices correspond one-for-one to the positive rational numbers, whose values are ordered from the left to the right as in a search tree. Figure 1 shows a part of the Stern-Brocot tree, which has thefirst 4 rows. Each node in the tree is marked in a red cycle. The value in the node is the mediant of the left and right fractions. The mediant of two fractions A/B and C/D is defined as(A+C)/(B+D).To construct the Stern-Brocot tree, we first define the left fraction of the root node is 0/1, and the right fraction of the root node is 1/0. So the value in the root node is the mediant of 0/1 and 1/0, which is(0+1)/(1+0)=1/1. Then the value of root node becomes the right fraction of the left child, and the left fraction of the right child. For example, the 1st node in row2 has 0/1 as its left fraction and 1/1(which is the value of its parent node) as its right fraction. So the value of the 1st node in row2 is (0+1)/(1+1)=1/2. For the same reason, the value of the 2nd node in row2 is (1+1)/(1+0)=2/1. This construction progress goes on infinitly. As a result, everypositive rational number can be found on the Stern-Brocot tree, and can be found only once.Given a rational number in form of P/Q, find the position of P/Q in the Stern-Brocot Tree. 输入： Input consists of two integers,P and Q(1&lt;=P,Q&lt;=1000), which represent the rational number P/Q. We promise P and Q are relatively prime. 输出： Output consists of two integers,R and C.R indicates the row index of P/Q in the stern-Brocot Tree,C indicates the index of P/Q in the row.Both B and C are base 1.We promise the position of P/Q is always in the first 12 rows of the Stern-Brocot tree, which means R&lt;=12. 样例输入： 5 3 样例输出： 4 6 解题思路：数学+二分 参考程序： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;string&gt;using namespace std;struct Fraction &#123; int m,n;&#125;sl,sr,input;int row,col;int main()&#123; int summ,sumn; scanf(&quot;%d%d&quot;,&amp;input.m,&amp;input.n); if(input.m!=1||input.n!=1) &#123; //string ans; sl.m=0,sr.m=1; sl.n=1,sr.n=0; row=1; col=1; while(1)&#123; summ=sl.m+sr.m; sumn=sl.n+sr.n; int temp=input.m*sumn-input.n*summ; if(temp&gt;0)&#123; // input.m/input.n&gt;summ/sumn --&gt; input.m*sumn-input.n*summ&gt;0 // ans+=&apos;R&apos;; row++; col*=2; sl.m=summ; sl.n=sumn; &#125; else if(temp==0) // input.m/input.n==summ/sumn --&gt; input.m*sumn-input.n*summ==0 break; else&#123; // input.m/input.n&lt;summ/sumn --&gt; input.m*sumn-input.n*summ&lt;0 // ans+=&apos;L&apos;; row++; col=2*col-1; sr.m=summ; sr.n=sumn; &#125; &#125; printf(&quot;%d %d\\n&quot;,row,col); &#125; return 0;&#125; 双人数字游戏 描述： 游戏规则如下 在棋盘上有N个数字（A1 ~ AN）从左到右排列成一行 A，B两个玩家轮流进行游戏，第一回合A玩家行动，第二回合B玩家行动，依次行动直到游戏结束 每回合玩家可以选择拿走棋盘上最左边或者最右边的一个数字，其余的都不能拿 拿走的数字依次从左到右排列在自己面前 棋盘上所有数字被拿走后游戏结束 最优策略的说明：在任意局面下，玩家如果取左边的数字或者取右边的数字，最终最优得分都一样，那么只能取左边的数字 当所有数字都被拿走后，A，B两个玩家面前都各有一个数列。 假设A玩家面前数字从左到右为X1，X2，X3…XM，则他的最终得分Sa计算方式如下（B玩家的得分计算Sb也类似，不赘述）：Sa=abs(X1-0)+abs(X2-X1)+abs(X3-X2)+..+abs(XM-X(M-1)) 请计算在以上的规则下，如果两个玩家都想拿到尽量多的分数，用最优策略进行游戏，计算两个人的最终得分。 输入： 第一行一个数字N，一半的测试用例（0&lt;N&lt;=50），一半的测试用例（0&lt;N&lt;=1000） 第二行N个数字Ai（0&lt;=Ai&lt;=50） 输出： 用空格隔开的两个整数Sa和Sb 样例输入： 41 2 3 4 样例输出： 7 4 解题思路：模拟 参考程序： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;int n, a, k = 1;deque&lt;int&gt; dq;int pa = 0, sa = 0, pb = 0, sb = 0;int main() &#123; scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf(&quot;%d&quot;, &amp;a); dq.push_back(a); &#125; while (dq.size()) &#123; int left = dq.front(); int right = dq.back(); if (k % 2) &#123; if (abs(left - pa) &gt;= abs(right - pa)) &#123; dq.pop_front(); sa += abs(left - pa); pa = left; &#125; else &#123; dq.pop_back(); sa += abs(right - pa); pa = right; &#125; &#125; else &#123; if (abs(left - pb) &gt;= abs(right - pb)) &#123; dq.pop_front(); sb += abs(left - pb); pb = left; &#125; else &#123; dq.pop_back(); sb += abs(right - pb); pb = right; &#125; &#125; k++; &#125; printf(&quot;%d %d\\n&quot;, sa, sb); return 0;&#125; 聊天消息排版 描述 在网游中，聊天功能是一项非常重要的功能，加上玩家可以打出游戏内置的一些表情图片，因此需要实现一个图文混排系统，如下图所示。玩家在聊天框输入的是一段utf-8编码的文字，且只会包含中文、英文、中英文的标点符号和空格（不会出现换行、回车和制表符）。按照网易游戏的传统，井号（#）是作为一个转义字符，支持下面几种转义行为： #加一个数字来表示内置的表情图片，为了简化问题，我们这里只支持20个表情图片，从0开始计数，并且数字是按最长匹配原则去匹配，比如#0表示0号表情图片、#1表示1号表情图片、#19表示19号表情图片、#20则表示2号表情图片后面加数字0。需要注意的是#00表示的是0号表情图片加后面数字0。 #r表示换行，遇到以后会自动切换到下一行开始排版。 ##表示显示出#这个符号 如果玩家不按规则输入错误的转义，则按照玩家的输入原样显示，比如#a、#、#、#啊 上图所示的玩家输入为：“Hello world#大家好#r欢迎大家参加#1祝大家取得好成绩” 排版的时候需要像上图一样，将文字从起始位置开始，依次显示在聊天窗囗里，一些显示规则如下所示： 聊天窗囗的宽度固定为W像素，起始坐标为左上角，坐标为（0，0），右上角坐标为（W-1，0），坐标向右向下增长。任何文字和表情必须显示在窗口内，不能超出窗口。但是高度可以无限向下延伸。 显示的字体均为等宽字体，英文（包括英文标点符号和空格）的字体宽度统一为XE，高度统一为YE。中文（包括中文的标点符号）的字体宽度统一为XC，高度统一为YC。 每个表情图片的宽高是独立的，0号表情图片的宽度为X0，高度Y0，依次类推，19号表情图片的宽度为×19，高度为Y19。 字符（中英文以及标点符号、空格等，下同）与字符之间、字符与表情之间、表情与表情之间都需要额外保留一个PX像素的字间距。每一行第一个字符左边，以及最后一个字符右边不需要保留字间距。 当下一个字符或者表情无法在本行W宽度的像素内完整显示的话，则会强行换到下一行首开始显示。遇到#r的时候也会自动换到下一行开始显示下一个字符或表情。 在一行里出现高度不同的中英文以及表情的时候，需要将其底部对齐。 当一行里没有任何字符或表情，直接被#r换行的时候，这一行的高度算英文字体的高度。 每一行里高度最高的字符或表情，需要同上一行的的底部保留PY像素的行间距。第一行上面与最后一行下面不需要保留行间距。 最后一个字符或表情显示显示以后，它的右下角坐标则为结束坐标。也就是本题需要求解的问题。输入保证最后不会以#r结尾。 输入： 每个测试输入包含1个测试用例第一行为7个正整数w，XE，YE，XC，YC，BX，PY第二行为40个正整数x0，Y0，X1，Y1…X19，Y19第三行为长度不超过10000的十六进制编码过的玩家输入，即玩家输入的utf-8编码的数据每个字节的数字转成大写的十六进制表示，不足两位的话前面补0（同c里printf的%x格式化），然后不同字节的十六进制编码表示依次拼接起来。比如Hello的十六进制编码表示为48656C6C6F。前两行的各个数字含义如上文描述，其中50&lt; w &lt;10000，0&lt;其他&lt;50。 输出： 输出用空格隔开的两个数字，表示结束坐标 输入样例： 60 2 4 3 4 1 37 6 7 6 7 6 7 6 7 6 7 6 7 6 7 6 7 6 7 6 7 6 7 6 7 6 7 6 7 6 7 6 7 6 7 6 7 6 7 648656C6C6F20776F726C6423E5A4A7E5AEB6E5A5BD2372E6ACA2E8BF8EE5A4A7E5AEB6E58F82E58AA0E7BD91E69893E99BB7E781ABE6A0A1E59BADE68B9BE881982331E7A59DE5A4A7E5AEB6E58F96E5BE97E5A5BDE68890E7BBA9 输出样例： 38 19 解题思路：模拟 参考程序： 12 黑客行动 描述： 钱老板家的电子保险柜被一个神秘的安保函数y=f(x)保护，每次试图开锁时，系统都会调用安保函数代码输入一个(0,1)之间的浮点数x，如果安保函数能输出正确的y数值则可以打开保险柜，否则就会报警。黑客小军想办法获取到了一份这个安保函数的测试程序，但这个程序并不能在钱老板家的系统上直接运行，必须要重新编码一份新的代码才能使用，请帮助小军实现这个安保函数代码！你可以在以下的URL下载这份测试程序的可执行文件，压缩包里包含windows、linux和macos三个平台下的可执行程序：http://guess.zip 输入： 一个(0,1)的浮点数，精确到小数点后6位 输出： 一个浮点数，精确到小数点后6位 输入样例： 0.268044 输出样例： 2.681916 备注： 本题的判题标准，如果你的代码输出的结果四舍五入到小数点后5位与标准答案四舍五入到小数点后5位一致就算正确 解题思路： 参考程序： 12","raw":null,"content":null,"categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://e99net.github.io/categories/Algorithm/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://e99net.github.io/tags/Dynamic-Programming/"},{"name":"Simulation","slug":"Simulation","permalink":"https://e99net.github.io/tags/Simulation/"}]},{"title":"洛谷的刷题日常之P1967","slug":"luogu_P1967","date":"2019-10-06T11:02:59.655Z","updated":"2019-10-06T11:54:02.534Z","comments":false,"path":"2019/10/06/luogu_P1967/","link":"","permalink":"https://e99net.github.io/2019/10/06/luogu_P1967/","excerpt":"货车运输这是一道比较综合的题，非常的niubility（我不会做的题都niubility，QWQ），用到的知识包括图论、倍增、贪心、LCA、生成树、并查集。 描述： A国有n座城市，编号从1到n，城市之间有m条双向道路。每一条道路对车辆都有重量限制，简称限重。现在有q辆货车在运输货物， 司机们想知道每辆车在不超过车辆限重的情况下，最多能运多重的货物。","keywords":null,"text":"货车运输这是一道比较综合的题，非常的niubility（我不会做的题都niubility，QWQ），用到的知识包括图论、倍增、贪心、LCA、生成树、并查集。 描述： A国有n座城市，编号从1到n，城市之间有m条双向道路。每一条道路对车辆都有重量限制，简称限重。现在有q辆货车在运输货物， 司机们想知道每辆车在不超过车辆限重的情况下，最多能运多重的货物。 输入： 第一行有两个用空格隔开的整数n和m，表示A国有n座城市和m条道路。接下来的m行，每行有3个整数x,y,z，每两个整数之间用一个空格隔开，表示从x号城市到y号城市有一条限重为z的道路。注意：x不等于 y，两座城市之间可能有多条道路。 接下来一行有一个整数q，表示有q辆货车需要运货。 接下来的q行，每行有两个整数x、y，用一个空格隔开，表示一辆货车需要从x城市运输货物到y城市。注意：x不等于y。 输出： 共有q行，每行一个整数，表示对于每一辆货车，它的最大载重是多少。如果货车不能到达目的地，输出-1。 输入样例： 4 31 2 42 3 33 1 131 31 41 3 输出样例： 3-13 解题思路： 贪心：因为要使得货车运的货物尽可能重，所以权值较小的边不会被走过。 图论：根据给出的数据建原始图，然后根据上一步的贪心策略建新图，构造最大生成树。 生成树：构造最大生成树可以使用Kruskal算法。 并查集：Kruskal算法可以用并查集维护节点的连通情况。 LCA：在最大生成树上求最近公共祖先，得到两个节点之间最小边权的最大值，即题中的最大载重。 倍增：树上倍增法求LCA。 参考代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include&lt;bits/stdc++.h&gt;using namespace std;#define INF 0x3f3f3f3fstruct road &#123; int x,y,z;&#125;roads[50010];//原始图struct edge &#123; int to,next,w;&#125;edges[50010];//存储最大生成树的新图//fa数组表示并查集中的父节点，f数组表示树上的父节点，w数组表示最大载重 int x,y,cnt,head[10010],fa[10010],f[10010][21],deep[10010],w[10010][21],n,m,q;bool vis[10010];//自定义排序规则，边权大的在前面bool cmp(road x,road y) &#123; return x.z&gt;y.z;&#125;//前向星存新图void addroad(int start,int end,int w) &#123; edges[++cnt].next=head[start]; edges[cnt].to=end; edges[cnt].w=w; head[start]=cnt;&#125;//并查集的查找操作int Find(int x) &#123; if(x!=fa[x]) fa[x]=Find(fa[x]); return fa[x];&#125;//Kruskal算法void kruskal() &#123; sort(roads+1,roads+m+1,cmp); for(int i=1;i&lt;=n;i++) fa[i]=i;//并查集的初始化操作 for(int i=1;i&lt;=m;i++) &#123; //并查集的合并操作 int a=Find(roads[i].x); int b=Find(roads[i].y); if(a!=b) &#123; fa[a]=b; //无向图，双向边 addroad(roads[i].x,roads[i].y,roads[i].z); addroad(roads[i].y,roads[i].x,roads[i].z); &#125; &#125;&#125;//预处理：从根节点进行搜索，求节点深度void dfs(int node) &#123; vis[node]=true; for(int i=head[node];i;i=edges[i].next) &#123;//前向星遍历 int to=edges[i].to; if(vis[to]) continue; deep[to]=deep[node]+1;//计算深度 f[to][0]=node;//存父节点 w[to][0]=edges[i].w;//存节点到父节点的权值 dfs(to); &#125;&#125;//树上倍增法优化求解LCA问题int lca(int x,int y) &#123; int a=Find(x); int b=Find(y); if(a!=b) return -1;//不连通输出-1 int ans=INF; if(deep[x]&gt;deep[y]) swap(x,y);//始终使得y节点更深 //将y节点提到与x节点相同的深度 for(int i=20;i&gt;=0;i--) &#123; if(deep[f[y][i]]&gt;=deep[x]) &#123; ans=min(ans,w[y][i]);//更新最大载重（最小边权） y=f[y][i];//修改y的位置 &#125; &#125; if(x==y) return ans;//如果位置已经相等，直接返回答案 //寻找公共祖先 for(int i=20;i&gt;=0;i--) &#123; if(f[x][i]!=f[y][i]) &#123; ans=min(ans,min(w[x][i],w[y][i]));//更新最大载重（最小边权） x=f[x][i];//修改x的位置 y=f[y][i];//修改y的位置 &#125; &#125; ans=min(ans,min(w[x][0],w[y][0]));//更新x,y到公共祖先的最大载重，fa[x][0]、fa[y][0]即为公共祖先 return ans;&#125;int main() &#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) &#123;//存原始图 scanf(&quot;%d%d%d&quot;,&amp;roads[i].x,&amp;roads[i].y,&amp;roads[i].z); &#125; kruskal(); for(int i=1;i&lt;=n;i++) &#123;//预处理 if(!vis[i]) &#123; deep[i]=1; dfs(i); f[i][0]=i; w[i][0]=INF; &#125; &#125; //LCA初始化 for(int i=1;i&lt;=20;i++) &#123; for(int j=1;j&lt;=n;j++) &#123; f[j][i]=f[f[j][i-1]][i-1]; w[j][i]=min(w[j][i-1],w[f[j][i-1]][i-1]); &#125; &#125; scanf(&quot;%d&quot;,&amp;q); for(int i=1;i&lt;=q;i++) &#123; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); printf(&quot;%d\\n&quot;,lca(x,y));//O(logn)复杂度回答询问 &#125; return 0;&#125;","raw":null,"content":null,"categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://e99net.github.io/categories/Algorithm/"}],"tags":[{"name":"Graph theory","slug":"Graph-theory","permalink":"https://e99net.github.io/tags/Graph-theory/"},{"name":"LCA","slug":"LCA","permalink":"https://e99net.github.io/tags/LCA/"},{"name":"Greedy","slug":"Greedy","permalink":"https://e99net.github.io/tags/Greedy/"},{"name":"Union-Find Set","slug":"Union-Find-Set","permalink":"https://e99net.github.io/tags/Union-Find-Set/"},{"name":"Spanning tree","slug":"Spanning-tree","permalink":"https://e99net.github.io/tags/Spanning-tree/"},{"name":"Doubling","slug":"Doubling","permalink":"https://e99net.github.io/tags/Doubling/"}]},{"title":"洛谷的刷题日常之P1147","slug":"luogu_P1147","date":"2019-10-04T16:15:38.897Z","updated":"2019-10-04T16:23:29.233Z","comments":false,"path":"2019/10/05/luogu_P1147/","link":"","permalink":"https://e99net.github.io/2019/10/05/luogu_P1147/","excerpt":"连续自然数和 描述： 对一个给定的自然数$M$，求出所有的连续的自然数段，这些连续的自然数段中的全部数之和为$M$。例子：1998+1999+2000+2001+2002 = 10000，所以从1998到2002的一个自然数段为$M=10000$的一个解。","keywords":null,"text":"连续自然数和 描述： 对一个给定的自然数$M$，求出所有的连续的自然数段，这些连续的自然数段中的全部数之和为$M$。例子：1998+1999+2000+2001+2002 = 10000，所以从1998到2002的一个自然数段为$M=10000$的一个解。 输入： 包含一个整数的单独一行给出M的值（$10 \\le M \\le 2000000$）。 输出： 每行两个自然数，给出一个满足条件的连续自然数段中的第一个数和最后一个数，两数之间用一个空格隔开，所有输出行的第一个按从小到大的升序排列，对于给定的输入数据，保证至少有一个解。 输入样例： 10000 输出样例： 18 142297 328388 4121998 2002 解题思路：前缀和+二分 参考代码: 123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longll sum[2000010];int main() &#123; ll m; scanf(&quot;%lld&quot;,&amp;m); for(int i=1;i&lt;=m;i++) sum[i]=sum[i-1]+i; for(int i=1;i&lt;=m-1;i++) &#123; ll l=i,r=m-1,mid; while(l&lt;=r) &#123; mid=(l+r)/2; ll t=sum[mid]-sum[i-1]; if(t==m) &#123; printf(&quot;%d %d\\n&quot;,i,mid); break; &#125;else if(t&lt;m) &#123; l=mid+1; &#125;else &#123; r=mid-1; &#125; &#125; &#125; return 0;&#125;","raw":null,"content":null,"categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://e99net.github.io/categories/Algorithm/"}],"tags":[{"name":"Prefix Sum","slug":"Prefix-Sum","permalink":"https://e99net.github.io/tags/Prefix-Sum/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"https://e99net.github.io/tags/Binary-Search/"}]},{"title":"记两道2020年某企业秋招的算法编程题","slug":"tourSohu","date":"2019-09-26T12:07:20.889Z","updated":"2019-10-13T05:46:43.123Z","comments":false,"path":"2019/09/26/tourSohu/","link":"","permalink":"https://e99net.github.io/2019/09/26/tourSohu/","excerpt":"专业题1 描述： 一个k（1&lt;=k&lt;=80）位的十进制整数n，我们称其为大整数。现在的问题是，请你设计一个程序，对于给出的某个大整数，找到满足条件p^3+p^2+3 * p&lt;=n的p的最大值。","keywords":null,"text":"专业题1 描述： 一个k（1&lt;=k&lt;=80）位的十进制整数n，我们称其为大整数。现在的问题是，请你设计一个程序，对于给出的某个大整数，找到满足条件p^3+p^2+3 * p&lt;=n的p的最大值。 输入： 一个大整数n。 输出： 一个符合条件的答案值。 样例输入1： 1908 样例输出1： 12 样例输入2： 8620110 样例输出2： 204 解题思路：高精度+二分 参考代码: 1234567891011121314151617181920212223#偷懒的Python代码def f(x): return x*x*x+x*x+3*xnum=int(input())left=0;right=num;mid=0;mark=0while left&lt;right: mid=int((left+right)/2) #print(&quot;midzhi &quot;,mid) fx=f(mid) if fx==num: ans=mid mark=1 break elif fx&gt;num: right=mid else: left=mid+1if mark==0: ans=left-1print(ans) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 2000;struct bign &#123; int len, s[MAXN]; bign () &#123; memset(s, 0, sizeof(s)); len = 1; &#125; bign (int num) &#123; *this = num; &#125; bign (const char *num) &#123; *this = num; &#125; int operator [] (int a) &#123; return s[a]; &#125; bign operator = (const int num) &#123; char s[MAXN]; sprintf(s, &quot;%d&quot;, num); *this = s; return *this; &#125; bign operator = (const char *num) &#123; for(int i = 0; num[i] == &apos;0&apos;; num++) ; len = strlen(num); for(int i = 0; i &lt; len; i++) s[i] = num[len-i-1] - &apos;0&apos;; return *this; &#125; bign operator + (const bign &amp;b) const &#123; bign c; c.len = 0; for(int i = 0, g = 0; g || i &lt; max(len, b.len); i++) &#123; int x = g; if(i &lt; len) x += s[i]; if(i &lt; b.len) x += b.s[i]; c.s[c.len++] = x % 10; g = x / 10; &#125; return c; &#125; bign operator += (const bign &amp;b) &#123; *this = *this + b; return *this; &#125; void clean() &#123; while(len &gt; 1 &amp;&amp; !s[len-1]) len--; &#125; bign operator * (const bign &amp;b) &#123; bign c; c.len = len + b.len; for(int i = 0; i &lt; len; i++) &#123; for(int j = 0; j &lt; b.len; j++) &#123; c.s[i+j] += s[i] * b.s[j]; &#125; &#125; for(int i = 0; i &lt; c.len; i++) &#123; c.s[i+1] += c.s[i]/10; c.s[i] %= 10; &#125; c.clean(); return c; &#125; bign operator *= (const bign &amp;b) &#123; *this = *this * b; return *this; &#125; bign operator - (const bign &amp;b) &#123; bign c; c.len = 0; for(int i = 0, g = 0; i &lt; len; i++) &#123; int x = s[i] - g; if(i &lt; b.len) x -= b.s[i]; if(x &gt;= 0) g = 0; else &#123; g = 1; x += 10; &#125; c.s[c.len++] = x; &#125; c.clean(); return c; &#125; bign operator -= (const bign &amp;b) &#123; *this = *this - b; return *this; &#125; bign operator / (const bign &amp;b) &#123; bign c, f = 0; for(int i = len-1; i &gt;= 0; i--) &#123; f = f*10; f.s[0] = s[i]; while(f &gt;= b) &#123; f -= b; c.s[i]++; &#125; &#125; c.len = len; c.clean(); return c; &#125; bign operator /= (const bign &amp;b) &#123; *this = *this / b; return *this; &#125; bign operator % (const bign &amp;b) &#123; bign r = *this / b; r = *this - r*b; return r; &#125; bign operator %= (const bign &amp;b) &#123; *this = *this % b; return *this; &#125; bign operator ++() &#123; return *this+=1; &#125; bign operator --() &#123; return *this-=1; &#125; bool operator &lt; (const bign &amp;b) &#123; if(len != b.len) return len &lt; b.len; for(int i = len-1; i &gt;= 0; i--) &#123; if(s[i] != b.s[i]) return s[i] &lt; b.s[i]; &#125; return false; &#125; bool operator &gt; (const bign &amp;b) &#123; if(len != b.len) return len &gt; b.len; for(int i = len-1; i &gt;= 0; i--) &#123; if(s[i] != b.s[i]) return s[i] &gt; b.s[i]; &#125; return false; &#125; bool operator == (const bign &amp;b) &#123; return !(*this &gt; b) &amp;&amp; !(*this &lt; b); &#125; bool operator != (const bign &amp;b) &#123; return !(*this == b); &#125; bool operator &lt;= (const bign &amp;b) &#123; return *this &lt; b || *this == b; &#125; bool operator &gt;= (const bign &amp;b) &#123; return *this &gt; b || *this == b; &#125; bign operator !() &#123; bign s=1; for(bign i=1;i&lt;=*this;++i) s*=i; return s; &#125; bign operator ^ (const bign&amp; b) &#123; bign s=1; for(bign i=0;i&lt;b;++i) s*=*this;return s; &#125; bign sqrt() &#123; bign c=*this/2; while((c*c)&gt;*this) c/=2; while((c*c)&lt;=*this) ++c; return c-1; &#125; /*string operator *()&#123; string op=&quot;Hello World&quot;; return op; &#125;*/ string str() const &#123; string res = &quot;&quot;; for(int i = 0; i &lt; len; i++) res = char(s[i]+&apos;0&apos;) + res; return res; &#125;&#125;;istream&amp; operator &gt;&gt; (istream &amp;in, bign &amp;x) &#123; string s; in &gt;&gt; s; x = s.c_str(); return in;&#125;ostream&amp; operator &lt;&lt; (ostream &amp;out, const bign &amp;x) &#123; out &lt;&lt; x.str(); return out;&#125;int main() &#123; // bign a,b; // cin&gt;&gt;a&gt;&gt;b; // cout&lt;&lt;a+b; bign left=0,n,mid,value,ans; int mark=0; cin&gt;&gt;n; bign right=n; while(left&lt;right) &#123; mid=(left+right)/2; value=mid*mid*mid+mid*mid+(bign)3*mid; if(value==n) &#123; ans=mid;mark=1;break; &#125;else if(value&gt;n) &#123; right=mid; &#125;else &#123; left=mid+1; &#125; &#125; if(mark==0) ans=left-1; cout&lt;&lt;ans; return 0;&#125; 专业题2 描述： 在一个棋盘上有N个处于不同位置的棋子，每个棋子所在的位置都可以用坐标(X,Y)来表示，并且任一棋子每次可以向上、下、左、右移动单位长度。如果想让所有棋子进入一个水平线，彼此靠近，即它们最后的位置是(X,Y)、(X+1,Y)、……、(X+N,Y)，水平线上棋子的最后顺序是任意的，那么最少需要移动多少次棋子？注意：两个或两个以上的棋子不能在同一时间处于同一位置。 输入： 第一行是一个整数N，表示棋子数，1&lt;=N&lt;=10000。后面的N行分别是每个棋子的初始位置，包含空格分开的整数x、y，-10000&lt;=x,y&lt;=10000。 输出： 仅有一行一个值，表示使棋子移到水平线彼此相邻位置的最小移动次数。 样例输入： 51 22 21 33 -23 3 样例输出： 8 解题思路：中位数、贪心 先将棋子移动到同一水平线，这一水平线的位置应该是它们纵坐标的中位数，可通过排序后得到中位数b，这样就能使得移动的总步数$\\sum_{i=1}^{n}abs(y_i-b)$最少。 然后要让棋子彼此靠近，先对横坐标从小到大排序，假设起点是a，那么要求$\\sum_{i=1}^{n}abs(a+i-x_i)$，即$\\sum_{i=1}^{n}abs(a-(x_i-i))$，也即$\\sum_{i=1}^{n}abs((x_i-i)-a)$。当a是$x_i-i$序列的中位数时，可使移动步数最少，同样地，这个中位数可以通过排序后得到。 将上述两步的结果相加，得到的就是最后结果了。 参考代码: 12345678910111213141516#include&lt;bits/stdc++.h&gt;using namespace std;int a[10010],b[10010],n,i,x,y,ans;int main() &#123; scanf(&quot;%d&quot;,&amp;n); for(i=1;i&lt;=n;i++) scanf(&quot;%d%d&quot;,&amp;a[i],&amp;b[i]); sort(b+1,b+n+1); y=b[n+1&gt;&gt;1]; sort(a+1,a+n+1); for(i=1;i&lt;=n;i++) a[i]-=i; sort(a+1,a+n+1); x=a[n+1&gt;&gt;1]; for(i=1;i&lt;=n;i++) ans+=abs(a[i]-x)+abs(b[i]-y); printf(&quot;%d\\n&quot;,ans); return 0;&#125;","raw":null,"content":null,"categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://e99net.github.io/categories/Algorithm/"}],"tags":[{"name":"Number theory","slug":"Number-theory","permalink":"https://e99net.github.io/tags/Number-theory/"},{"name":"Greedy","slug":"Greedy","permalink":"https://e99net.github.io/tags/Greedy/"}]},{"title":"洛谷的刷题日常之P1880","slug":"luogu_P1880","date":"2019-09-24T03:16:45.340Z","updated":"2019-10-06T12:12:45.330Z","comments":false,"path":"2019/09/24/luogu_P1880/","link":"","permalink":"https://e99net.github.io/2019/09/24/luogu_P1880/","excerpt":"石子合并先看一道比luogu p1880简单的题目。 描述： 有n堆石子排成一排，每堆石子有一定的数量，将n堆石子合并成一堆。合并的规则是每次只能合并相邻的两堆石子，合并的花费为这两堆石子的总数。石子经过n-1次合并后成为一堆，求总的最小花费和最大花费。","keywords":null,"text":"石子合并先看一道比luogu p1880简单的题目。 描述： 有n堆石子排成一排，每堆石子有一定的数量，将n堆石子合并成一堆。合并的规则是每次只能合并相邻的两堆石子，合并的花费为这两堆石子的总数。石子经过n-1次合并后成为一堆，求总的最小花费和最大花费。 输入： 有多组测试数据，输入到文件结束。每组测试数据的第1行有一个整数n，表示有n堆石子，n&lt;250。接下来的一行有n个数，分别表示这n堆石子的数目。每堆石子至少一颗，最多10000颗。 输出： 总的最小花费和最大花费。 输入样例： 32 4 5 输出样例： 1720 解题思路：区间DP 参考代码: 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std;const int INF=1&lt;&lt;30;const int N=300;int n,sum[N];int Minval()&#123; int dp[N][N]； for(int i=1;i&lt;=n;i++) dp[i][i]=0; for(int len=1;len&lt;n;len++) for(int i=1;i&lt;=n-len;i++) &#123; int j=i+len; dp[i][j]=INF; for(int k=i;k&lt;j;k++) dp[i][j]=min(dp[i][j],dp[i][k]+dp[k+1][j]+sum[j]-sum[i-1]); &#125; return dp[1][n];&#125;int Maxval()&#123; int dp[N][N]; for(int i=1;i&lt;=n;i++) dp[i][i]=0; for(int len=1;len&lt;n;len++) for(int i=1;i&lt;=n-len;i++) &#123; int j=i+len; dp[i][j]=-INF; for(int k=i;k&lt;j;k++) dp[i][j]=max(dp[i][j],dp[i][k]+dp[k+1][j]+sum[j]-sum[i-1]); &#125; return dp[1][n];&#125;int main() &#123; scanf(&quot;%d&quot;,&amp;n); sum[0]=0; for(int i=1;i&lt;=n;i++) &#123; int x; scanf(&quot;%d&quot;,&amp;x); sum[i]=sum[i-1]+x; &#125; printf(&quot;%d\\n%d&quot;,Minval(),Maxval()); return 0;&#125; 环形石子合并接下来就可以着手解决luogu p1880了。如果按照上面的解法解这道题，会出现“min值永远比正确答案大1”的“奇怪”现象，这是因为没有考虑环形的缘故。 描述： 在一个圆形操场的四周摆放N堆石子,现要将石子有次序地合并成一堆.规定每次只能选相邻的2堆合并成新的一堆，并将新的一堆的石子数，记为该次合并的得分。 试设计出1个算法,计算出将N堆石子合并成1堆的最小得分和最大得分. 输入： 数据的第1行试正整数N,1≤N≤100,表示有N堆石子.第2行有N个数,分别表示每堆石子的个数. 输出： 输出共2行,第1行为最小得分,第2行为最大得分. 输入样例： 44 5 9 4 输出样例： 4354 解题思路： 区间DP 处理环形情况的通用套路：在任意位置把环断开成链，复制一倍接在末尾 参考代码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;using namespace std;const int INF=1&lt;&lt;30;const int N=240;int n,sum[N],x,arr[N];int Minval()&#123; int dp[N][N],ans=INF; for(int i=1;i&lt;=n;i++) dp[i][i]=0; for(int len=1;len&lt;n;len++) for(int i=1;i&lt;=2*n-len;i++) &#123; int j=i+len; dp[i][j]=INF; for(int k=i;k&lt;j;k++) dp[i][j]=min(dp[i][j],dp[i][k]+dp[k+1][j]+sum[j]-sum[i-1]); &#125; for(int i=1;i&lt;=n;i++) &#123; ans=ans&gt;dp[i][i+n-1]?dp[i][i+n-1]:ans; &#125; return ans;&#125;int Maxval()&#123; int dp[N][N],ans=-INF; for(int i=1;i&lt;=n;i++) dp[i][i]=0; for(int len=1;len&lt;n;len++) for(int i=1;i&lt;=2*n-len;i++) &#123; int j=i+len; dp[i][j]=-INF; for(int k=i;k&lt;j;k++) dp[i][j]=max(dp[i][j],dp[i][k]+dp[k+1][j]+sum[j]-sum[i-1]); &#125; for(int i=1;i&lt;=n;i++) &#123; ans=ans&lt;dp[i][i+n-1]?dp[i][i+n-1]:ans; &#125; return ans;&#125;int main() &#123; scanf(&quot;%d&quot;,&amp;n); sum[0]=0; for(int i=1;i&lt;=n;i++) &#123; scanf(&quot;%d&quot;,&amp;arr[i]); arr[i+n]=arr[i]; &#125; for(int i=1;i&lt;=2*n;i++) &#123; sum[i]=sum[i-1]+arr[i]; &#125; printf(&quot;%d\\n%d&quot;,Minval(),Maxval()); return 0;&#125; 相似题目： hdu 3506 “Monkey Party”","raw":null,"content":null,"categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://e99net.github.io/categories/Algorithm/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://e99net.github.io/tags/Dynamic-Programming/"}]},{"title":"记三道2020年某企业秋招笔试题","slug":"cmbcc","date":"2019-09-24T02:30:06.499Z","updated":"2019-10-12T02:12:55.595Z","comments":false,"path":"2019/09/24/cmbcc/","link":"","permalink":"https://e99net.github.io/2019/09/24/cmbcc/","excerpt":"1 ~ n 中每位数字乘积最大的值 描述： 99°是一位爱好爬山的小青年，他每次在爬山过程中都会遇到很多小猴子，小猴子们喜欢向他提这样一种问题：在1 ~ n中找一个数字m，使得m的各个数位乘积最大。99°不擅长回答这种问题，你能帮他写一个程序得到结果吗？","keywords":null,"text":"1 ~ n 中每位数字乘积最大的值 描述： 99°是一位爱好爬山的小青年，他每次在爬山过程中都会遇到很多小猴子，小猴子们喜欢向他提这样一种问题：在1 ~ n中找一个数字m，使得m的各个数位乘积最大。99°不擅长回答这种问题，你能帮他写一个程序得到结果吗？ 样例输入1： 100 样例输出1： 81 提示：9 * 9 = 81 样例输入2： 6 样例输出2： 6 解题思路：贪心 尽量把每一位变成9，每次都向前借一位来减 n比10小就返回n，n为0就返回1 参考代码: 1234567891011121314151617#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longll solve(int n) &#123; if(n==0) return 1; if(n&lt;10) return n; else return max(solve(n/10-1)*9,solve(n/10)*(n%10));&#125;int main() &#123; int n; scanf(&quot;%d&quot;,&amp;n); printf(&quot;%lld&quot;,solve(n)); return 0;&#125; 完成可能有前置任务的任务 描述： 99°要完成n个任务，它制定了一个计划，计划第i天完成第i个任务，每个任务可能有前置任务，在完成第i个任务时，必须先完成它的前置任务才行。问99°要想实现它的计划，每天至少要完成多少个任务？ 输入： 一个整数n，表示要完成的任务数，2&lt;=n&lt;=10000。接下来n行，每行第一个数字k表示该任务的前置任务数，剩下的k个数字分别表示前置任务编号。 输出： n个数字，每个数字以一个空格间隔，表示每天至少完成的任务数。 样例输入： 31 202 1 2 样例输出： 2 0 1 说明：任务1有1个前置任务2，第1天要想完成任务1，需先完成任务2，所以第1天至少完成2个任务。第2天计划完成任务2，因为任务2已在第一天完成，且任务2无前置任务，所以第2天至少完成0个任务。第3天计划完成任务3，任务3有两个前置任务1、2，在前两天都已完成，所以这一天只需完成任务3，至少完成1个任务即可。 样例输入： 54 2 3 4 51 12 1 201 3 样例输出： 5 0 0 0 0 说明：第1个任务有4个前置任务2、3、4、5，要想完成1，需先完成2、3、4、5，那么第1天至少完成5个任务。接下来的第2、3、4、5天每天完成0个任务，因为在第1天已完成全部5个任务。 解题思路：开哈希数组 参考程序： 123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;const int N=10005;int n,res[N],v[N];int main() &#123; int k,x; memset(res,0,sizeof res); scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) &#123; scanf(&quot;%d&quot;,&amp;k); while(k--) &#123; scanf(&quot;%d&quot;,&amp;x); if(!v[x]) &#123; v[x]=1; res[i]++; &#125; &#125; if(!v[i]) &#123; res[i]++; v[i]=1; &#125; &#125; for(int i=1;i&lt;=n;i++) &#123; printf(&quot;%d &quot;,res[i]); &#125; printf(&quot;\\n&quot;); return 0;&#125; 将数组元素变为非递减 描述 99°给出一个包含$n$个整数的数组$a_i$，99°每次可以选择数组中若干个下标不同的元素，对选中的每个元素执行下列改变：假设选中的元素为$x$，那么就将$x$替换为$(x+1) mod m$，即选中的每个元素自增1，如果变为$m$则归零。请问最少执行多少次操作，99°可以把这个数组变为一个数组元素非递减的数组。 输入： 第一行两个整数$n$和$m$，用一个空格分隔；第二行$n$个整数$a_1$,$a_2$,…,$a_n$表示数组，每两个整数之间用一个空格分隔。输入满足$1&lt;=n,m&lt;=300000;0 &lt;= a_i &lt; m$ 。 输出： 一个整数，表示最少需要的操作次数。 输入样例1： 6 87 5 6 3 2 1 输出样例1： 3 输入样例2： 3 21 0 1 输出样例2： 1 输入样例3： 3 21 0 0 输出样例3： 1 解题思路：线性dp 参考程序： 123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;#define INF 0x3f3f3f3fconst int N=300005;int n,m,a[N],dp[N];inline int move(int i,int j) &#123; int ans=j-a[i]; if(a[i]&gt;j) ans+=m; return ans;&#125;int main() &#123; int t,ans=INF; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;a[i]); for(int i=0;i&lt;m;i++) //初始化dp数组 dp[i]=move(0,i); for(int i=1;i&lt;n;i++) &#123; t=dp[0]; for(int j=0;j&lt;m;j++) &#123; t=min(t,dp[j]); dp[j]=max(t,move(i,j)); &#125; &#125; for(int i=0;i&lt;m;i++) ans=min(ans,dp[i]); printf(&quot;%d\\n&quot;,ans); return 0;&#125;","raw":null,"content":null,"categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://e99net.github.io/categories/Algorithm/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://e99net.github.io/tags/Dynamic-Programming/"},{"name":"Greedy","slug":"Greedy","permalink":"https://e99net.github.io/tags/Greedy/"}]},{"title":"记一道2020年某企业提前批招聘的机试题","slug":"spdb","date":"2019-09-21T11:20:15.013Z","updated":"2019-09-24T02:57:39.061Z","comments":false,"path":"2019/09/21/spdb/","link":"","permalink":"https://e99net.github.io/2019/09/21/spdb/","excerpt":"字符串是否由子串拼接而成 描述： 给出一个非空的字符串，判断这个字符串是否由它的一个子串进行多次首尾拼接构成。例如，“abcabcabc”满足条件，因为它是由“abc”首尾拼接而成，而“abcab”则不满足条件。","keywords":null,"text":"字符串是否由子串拼接而成 描述： 给出一个非空的字符串，判断这个字符串是否由它的一个子串进行多次首尾拼接构成。例如，“abcabcabc”满足条件，因为它是由“abc”首尾拼接而成，而“abcab”则不满足条件。 输入： abcabcabc 输出： true 参考代码: 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;int main() &#123; string str; cin&gt;&gt;str; int n=str.size(); int m,flag; for(int i=n/2;i&gt;=1;i--) &#123; flag=0; if(n%i==0)&#123; m=n/i; for(int j=0;j&lt;i;j++)&#123; for(int k=1;k&lt;m;k++) &#123; if(str[j]!=str[j+k*i]) &#123; flag=1; break; &#125; &#125; if(flag) &#123; break; &#125; &#125; if(!flag) &#123; printf(&quot;true&quot;); return 0; &#125; &#125; &#125; printf(&quot;false&quot;); return 0;&#125;","raw":null,"content":null,"categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://e99net.github.io/categories/Algorithm/"}],"tags":[{"name":"String","slug":"String","permalink":"https://e99net.github.io/tags/String/"}]},{"title":"C++的输入与输出","slug":"InputandOutputOfCpp","date":"2019-08-25T07:35:30.848Z","updated":"2019-08-25T07:38:59.207Z","comments":false,"path":"2019/08/25/InputandOutputOfCpp/","link":"","permalink":"https://e99net.github.io/2019/08/25/InputandOutputOfCpp/","excerpt":"输入时：float型输入用%f。double型输入用%lf。","keywords":null,"text":"输入时：float型输入用%f。double型输入用%lf。 输出时：最好是都用%f输出。在G++中，double类型若用%lf输出可能会错，而在C++中，double类型用%lf输出是正确的。printf() 函数中不存在 %lf。 总结：输入 double 用 %lf 输出用 %f。","raw":null,"content":null,"categories":[{"name":"memo","slug":"memo","permalink":"https://e99net.github.io/categories/memo/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://e99net.github.io/tags/C-C/"}]},{"title":"用Git进行简单有效的项目版本控制管理","slug":"git","date":"2019-03-02T11:50:07.770Z","updated":"2019-03-02T11:59:41.342Z","comments":false,"path":"2019/03/02/git/","link":"","permalink":"https://e99net.github.io/2019/03/02/git/","excerpt":"Git是一个非常强大的项目版本控制管理工具，在单机环境下，可以简单有效地使用Git","keywords":null,"text":"Git是一个非常强大的项目版本控制管理工具，在单机环境下，可以简单有效地使用Git 常用的Git命令12345678git initgit add .git commit -m &quot;[提交点名称]&quot;git statusgit loggit reset --hard HEAD^^get reset --hard [Git生成的版本号，不必写全，无歧义即可]git checkout -- [文件] 以上这些命令就足以较好地管理自己的项目目录了","raw":null,"content":null,"categories":[{"name":"memo","slug":"memo","permalink":"https://e99net.github.io/categories/memo/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://e99net.github.io/tags/Git/"}]},{"title":"makefile文件的不同写法","slug":"otherKindOfMakefile","date":"2019-02-23T03:50:46.528Z","updated":"2019-02-23T03:55:09.817Z","comments":false,"path":"2019/02/23/otherKindOfMakefile/","link":"","permalink":"https://e99net.github.io/2019/02/23/otherKindOfMakefile/","excerpt":"封装so库时的写法 12345678910111213141516CC=gccSRCS=mylib.cOBJS=$(SRCS:.c=.o)EXEC=libmylib.sostart: $(OBJS) $(CC) -o $(EXEC) $(OBJS) -shared.c.o: $(CC) -o $@ -c $&lt; -fPICclean: rm -rf $(OBJS)","keywords":null,"text":"封装so库时的写法 12345678910111213141516CC=gccSRCS=mylib.cOBJS=$(SRCS:.c=.o)EXEC=libmylib.sostart: $(OBJS) $(CC) -o $(EXEC) $(OBJS) -shared.c.o: $(CC) -o $@ -c $&lt; -fPICclean: rm -rf $(OBJS) C/C++混合编程的写法 1234567891011121314151617CC=g++SRCS=main.cpp\\ udp.cppOBJS=$(SRCS:.cpp=.o)EXEC=myudpstart: $(OBJS) $(CC) -o $(EXEC) $(OBJS).cpp.o: $(CC) -o $@ -c $&lt; -DMYLINUXclean: rm -rf $(OBJS)","raw":null,"content":null,"categories":[{"name":"memo","slug":"memo","permalink":"https://e99net.github.io/categories/memo/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://e99net.github.io/tags/C-C/"}]},{"title":"循序渐进写makefile","slug":"writeMakefile","date":"2019-02-23T03:11:15.605Z","updated":"2019-02-23T04:22:53.639Z","comments":false,"path":"2019/02/23/writeMakefile/","link":"","permalink":"https://e99net.github.io/2019/02/23/writeMakefile/","excerpt":"准备工作 main.cpp 12345678910#include &lt;iostream&gt;#include &quot;a.h&quot;using namespace std;int main()&#123; test(); cout &lt;&lt; &quot;hello world&quot; &lt;&lt; endl; return 0;&#125; a.h 12345#ifndef AH_H#define AH_Hvoid test();#endif a.cpp 123456#include &lt;stdio.h&gt;void test()&#123; printf(&quot;I am test\\n&quot;);&#125;","keywords":null,"text":"准备工作 main.cpp 12345678910#include &lt;iostream&gt;#include &quot;a.h&quot;using namespace std;int main()&#123; test(); cout &lt;&lt; &quot;hello world&quot; &lt;&lt; endl; return 0;&#125; a.h 12345#ifndef AH_H#define AH_Hvoid test();#endif a.cpp 123456#include &lt;stdio.h&gt;void test()&#123; printf(&quot;I am test\\n&quot;);&#125; 版本0 1234start: g++ -o a.o -c a.cpp g++ -o main.o -c main.cpp g++ -o myapp a.o main.o 版本1 1234567start: g++ -o a.o -c a.cpp g++ -o main.o -c main.cpp g++ -o myapp a.o main.oclean: rm -rf a.o main.o 版本2 1234567891011CC=g++EXEC=myappstart: $(CC) -o a.o -c a.cpp $(CC) -o main.o -c main.cpp $(CC) -o $(EXEC) a.o main.oclean: rm -rf a.o main.o 版本3 12345678910111213141516CC=g++SRCS=main.cpp\\ a.cppOBJS=main.o\\ a.oEXEC=myappstart: $(CC) -o $(OBJS) -c $(SRCS) $(CC) -o $(EXEC) $(OBJS)clean: rm -rf $(OBJS) 版本4 123456789101112131415161718CC=g++SRCS=main.cpp\\ a.cppOBJS=main.o\\ a.oEXEC=myappstart: a.o main.o $(CC) -o $(EXEC) $(OBJS)a.o main.o: $(CC) -o $(OBJS) -c $(SRCS)clean: rm -rf $(OBJS) 最终版本 1234567891011121314151617CC=g++SRCS=main.cpp\\ a.cppOBJS=$(SRCS:.cpp=.o)EXEC=myappstart: $(OBJS) $(CC) -o $(EXEC) $(OBJS).cpp.o: $(CC) -o $@ -c $&lt;clean: rm -rf $(OBJS)","raw":null,"content":null,"categories":[{"name":"memo","slug":"memo","permalink":"https://e99net.github.io/categories/memo/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://e99net.github.io/tags/C-C/"}]},{"title":"Win7开机界面英文转中文","slug":"EnToChOfBootloader","date":"2019-02-10T03:56:23.237Z","updated":"2019-02-10T07:44:35.550Z","comments":false,"path":"2019/02/10/EnToChOfBootloader/","link":"","permalink":"https://e99net.github.io/2019/02/10/EnToChOfBootloader/","excerpt":"打开cmd命令提示符并执行如下命令 将操作系统启动选择菜单的显示语言修改为简体中文1bcdedit /set &#123;bootmgr&#125; locale zh-CN","keywords":null,"text":"打开cmd命令提示符并执行如下命令 将操作系统启动选择菜单的显示语言修改为简体中文1bcdedit /set &#123;bootmgr&#125; locale zh-CN 将当前Windows操作系统F8高级启动菜单的显示语言修改为简体中文 1bcdedit /set &#123;current&#125; locale zh-CN 将Windows内存诊断工具的显示语言修改为简体中文 1bcdedit /set &#123;memdiag&#125; locale zh-CN 将休眠恢复时的显示语言修改为简体中文 1bcdedit /set &#123;视机器而定的一段字符&#125; locale zh-CN 注意：视机器而定的一段字符形如526bf864-88ef-11de-9b8c-e613e975374f，这段字符可通过以下命令进行查看1bcdedit /enum all","raw":null,"content":null,"categories":[{"name":"memo","slug":"memo","permalink":"https://e99net.github.io/categories/memo/"}],"tags":[{"name":"Water","slug":"Water","permalink":"https://e99net.github.io/tags/Water/"}]},{"title":"用UltraISO制作Ubuntu18.04的启动U盘","slug":"USBofUbuntu","date":"2019-02-02T14:41:58.789Z","updated":"2019-09-21T11:54:52.784Z","comments":true,"path":"2019/02/02/USBofUbuntu/","link":"","permalink":"https://e99net.github.io/2019/02/02/USBofUbuntu/","excerpt":"从Ubuntu官网下载18.04系统的iso文件，并安装UltraISO软件 确保用来制作启动盘的U盘是FAT32格式的，否则，可将U盘格式化为FAT32格式","keywords":null,"text":"从Ubuntu官网下载18.04系统的iso文件，并安装UltraISO软件 确保用来制作启动盘的U盘是FAT32格式的，否则，可将U盘格式化为FAT32格式 点击UltraISO的红色框内按钮 找到Ubuntu ISO文件并选中，点击打开打开后的界面如下图所示 点击“启动→写入硬盘映像…” 写入方式选择USB-HDD+或者USB-HDD都可以 点击“便捷启动→写入新的驱动器引导扇区→Syslinux”,选择“是”，完成后“确定” 点击“写入”，选择“是”。 写入需要等待一段时间，完成后如下图。此时，选择“返回”并退出UltraISO即可","raw":null,"content":null,"categories":[{"name":"memo","slug":"memo","permalink":"https://e99net.github.io/categories/memo/"}],"tags":[{"name":"Water","slug":"Water","permalink":"https://e99net.github.io/tags/Water/"}]},{"title":"Ubuntu上的各种软件问题解决之道","slug":"SolofMatlabOnUbuntu","date":"2019-02-02T14:17:20.516Z","updated":"2019-02-02T14:41:36.433Z","comments":true,"path":"2019/02/02/SolofMatlabOnUbuntu/","link":"","permalink":"https://e99net.github.io/2019/02/02/SolofMatlabOnUbuntu/","excerpt":"","keywords":null,"text":"Ubuntu上的Matlab无法以普通用户身份运行给“/home/用户名/.matlab”这个文件目录递归授予超级权限1sudo chmod 777 .matlab -R CLion无法用快捷方式启动先在Terminal中启动CLion，然后点击菜单栏Tools下面的Create Desktop Entry即可","raw":null,"content":null,"categories":[{"name":"memo","slug":"memo","permalink":"https://e99net.github.io/categories/memo/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://e99net.github.io/tags/Linux/"},{"name":"Matlab","slug":"Matlab","permalink":"https://e99net.github.io/tags/Matlab/"}]},{"title":"强化学习介绍","slug":"A_intro_to_RL","date":"2018-11-12T12:10:15.619Z","updated":"2019-01-05T12:11:57.067Z","comments":false,"path":"2018/11/12/A_intro_to_RL/","link":"","permalink":"https://e99net.github.io/2018/11/12/A_intro_to_RL/","excerpt":"蒙特卡罗 VS TD学习方法我们有两种学习方式： 在episode的最后收集奖励并计算最大期望将来奖励：蒙特卡罗方法 估计每一步的奖励：时序差分学习","keywords":null,"text":"蒙特卡罗 VS TD学习方法我们有两种学习方式： 在episode的最后收集奖励并计算最大期望将来奖励：蒙特卡罗方法 估计每一步的奖励：时序差分学习 蒙特卡罗当episode结束时（智能体到达一个“终止状态”），智能体视其总共的累计奖励来知晓它做的怎么样。在蒙特卡罗方法中，只有在游戏的最后才会收到奖励。 然后，带着新增的知识开启一轮新游戏。智能体每次迭代会做出更好的决策。 探索/开发的权衡 探索是发现有关环境的更多信息 开发是开发已知的信息，使得奖励最大化 强化学习智能体的目标是最大化期望的累计奖励，然而，我们会陷入一个共同的陷阱。 我们必须定义一个规则帮助我们处理这种权衡。 强化学习的三种方法解决强化学习问题的三种方法是：基于值、基于策略、基于模型。 基于值在基于值的强化学习中，目标是优化值函数 值函数告知我们智能体在每个状态得到的最大期望将来奖励 每个状态的值是在那个状态的智能体期望在将来累计的奖励总数。$$V_\\pi(s)=\\mathbb{E_\\pi}[R_{t+1}+\\gamma R_{t+2}+\\gamma ^2 R_{t+3}+…|S_t =s]$$智能体会使用这个值函数去在每一步选择一个状态，选择的状态具有最大的值。 基于策略在基于策略的强化学习中，我们想不使用值函数而直接优化策略函数$\\mathtt{\\pi}(s)$。 策略是在一个给定的时间对智能体行为的定义。$$a=\\pi(s)$$我们学习一个策略函数，使每个状态映射到对应的最好动作。 我们有两种策略： 固定策略：一种在给定状态总会返回相同动作的策略。 随机策略：随动作输出分布概率。 $$\\text{Stochastic policy:} \\ \\pi(a|s)=\\mathbb{P}[A_t=a|S_t=s]$$ 策略直接表明每一步应该采取的最好动作。 基于模型在基于模型的强化学习中，我们对环境建模。这意味着我们创建了一个环境行为的模型。 问题是每个环境都需要一个不同的模型表示。","raw":null,"content":null,"categories":[{"name":"memo","slug":"memo","permalink":"https://e99net.github.io/categories/memo/"}],"tags":[{"name":"Reinforcement Learning","slug":"Reinforcement-Learning","permalink":"https://e99net.github.io/tags/Reinforcement-Learning/"}]},{"title":"Latex处理参考文献","slug":"reference_of_latex","date":"2018-11-02T13:48:12.079Z","updated":"2018-11-02T13:51:28.363Z","comments":false,"path":"2018/11/02/reference_of_latex/","link":"","permalink":"https://e99net.github.io/2018/11/02/reference_of_latex/","excerpt":"","keywords":null,"text":"使用cite宏包可以生成参考文献 12\\usepackage&#123;cite&#125;\\cite&#123;b3,b4,b5,b6,b7,b8&#125; 生成的参考文献格式为：[3]-[8]","raw":null,"content":null,"categories":[{"name":"memo","slug":"memo","permalink":"https://e99net.github.io/categories/memo/"}],"tags":[{"name":"Latex","slug":"Latex","permalink":"https://e99net.github.io/tags/Latex/"}]},{"title":"WEB框架辨析","slug":"webframe","date":"2018-10-23T05:30:52.852Z","updated":"2018-10-23T05:34:11.843Z","comments":false,"path":"2018/10/23/webframe/","link":"","permalink":"https://e99net.github.io/2018/10/23/webframe/","excerpt":"","keywords":null,"text":"bootstrap是个Web框架吗？bootstrap不能算是个完整的框架，它应该算是一个css框架+一些js组件。主要目的不是提供一个完整的前端解决方案，而只是关注前端UI呈现。","raw":null,"content":null,"categories":[{"name":"memo","slug":"memo","permalink":"https://e99net.github.io/categories/memo/"}],"tags":[{"name":"Water","slug":"Water","permalink":"https://e99net.github.io/tags/Water/"}]},{"title":"差分进化基础","slug":"basic_of_DE","date":"2018-09-28T02:10:31.334Z","updated":"2018-10-01T08:34:42.606Z","comments":false,"path":"2018/09/28/basic_of_DE/","link":"","permalink":"https://e99net.github.io/2018/09/28/basic_of_DE/","excerpt":"差分进化算法是一种自组织最小化方法，用户只需要很少的输入，它起源于遗传算法(EA)，是一种基于种群进化的算法，包括变异、交叉、选择、边界检测。","keywords":null,"text":"差分进化算法是一种自组织最小化方法，用户只需要很少的输入，它起源于遗传算法(EA)，是一种基于种群进化的算法，包括变异、交叉、选择、边界检测。 差分进化算法由Storn等人于1995年提出，是一种模拟生物进化的随机模型，保留了基于种群的全局搜索策略，降低了遗传操作的复杂性。 DE和PSO都是基于种群的算法，不同于其他演化算法的是，DE使用种群中两个随机选择的个体向量差产生一个新的候选解（个体）。DE有一个好的全局搜索能力，但通常在种群演化的后阶段收敛得很慢。PSO能够收敛得很快，但易于陷入局部最优。由于DE与PSO的互补特性，一些研究常聚焦于两者的混合应用。","raw":null,"content":null,"categories":[{"name":"EAs","slug":"EAs","permalink":"https://e99net.github.io/categories/EAs/"}],"tags":[{"name":"DE","slug":"DE","permalink":"https://e99net.github.io/tags/DE/"}]},{"title":"扫盲","slug":"Eliminate_illiteracy","date":"2018-09-23T05:26:00.771Z","updated":"2018-09-23T05:33:47.323Z","comments":false,"path":"2018/09/23/Eliminate_illiteracy/","link":"","permalink":"https://e99net.github.io/2018/09/23/Eliminate_illiteracy/","excerpt":"中国、日本和韩国的象形文字总称为CJK。","keywords":null,"text":"中国、日本和韩国的象形文字总称为CJK。 Mac OS X Mavericks(巨浪)：X表示Mac的第10个版本，“X”是罗马数字“10”的意思。 将“休眠”去掉，同时腾出C盘空间：powercfg.exe /hibernate off。 Sublime Text快捷键：Ctrl+K U 改为大写，Ctrl+K L 改为小写。 FreeBSD比Linux还要稳定，可以做到十年不关机，并且比Linux速度要快出30%。 美国军方五角大楼采用的是openBSD操作系统。 编译器图书中的”龙书“、”虎书“、”鲸书“ 分别指的是《编译原理：技术与工具（第2版）》、《高级编译器：设计与实现》、《现代编译原理：C语言描述》","raw":null,"content":null,"categories":[{"name":"memo","slug":"memo","permalink":"https://e99net.github.io/categories/memo/"}],"tags":[{"name":"Water","slug":"Water","permalink":"https://e99net.github.io/tags/Water/"}]},{"title":"JDK1.5的新特性","slug":"jdk1.5_newCharacter","date":"2018-09-23T05:13:15.352Z","updated":"2018-09-23T05:16:43.389Z","comments":false,"path":"2018/09/23/jdk1.5_newCharacter/","link":"","permalink":"https://e99net.github.io/2018/09/23/jdk1.5_newCharacter/","excerpt":"","keywords":null,"text":"jdk1.5的四个新特性如下： 自动装箱和拆箱 增强for循环 静态导入（唯一的败笔） 可变参数","raw":null,"content":null,"categories":[{"name":"memo","slug":"memo","permalink":"https://e99net.github.io/categories/memo/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://e99net.github.io/tags/Java/"}]},{"title":"TPC-H的22条查询语句","slug":"tpch","date":"2018-09-15T02:17:13.183Z","updated":"2018-09-15T02:34:26.528Z","comments":false,"path":"2018/09/15/tpch/","link":"","permalink":"https://e99net.github.io/2018/09/15/tpch/","excerpt":"TPC-H的22条查询语句中包含两个以上的表连接操作和至少一个聚集函数的有：","keywords":null,"text":"TPC-H的22条查询语句中包含两个以上的表连接操作和至少一个聚集函数的有： Q2（五表连接、一个聚集）√ Q3（三表连接、一个聚集）√ Q5（六表连接、一个聚集）√ Q7（六表连接、一个聚集） Q8（八表连接、两个聚集）√ Q9（六表连接、一个聚集） Q10（四表连接、一个聚集） Q11（三表连接、三个聚集） Q12（两表连接） Q16（两表连接） Q17（两表连接） Q18（三表连接） Q19（两表连接） Q20（两表连接） Q21（四表连接）","raw":null,"content":null,"categories":[{"name":"memo","slug":"memo","permalink":"https://e99net.github.io/categories/memo/"}],"tags":[{"name":"Database","slug":"Database","permalink":"https://e99net.github.io/tags/Database/"}]},{"title":"程序员必读书单 1.0","slug":"BookList","date":"2018-08-15T13:31:26.148Z","updated":"2018-09-15T02:32:30.224Z","comments":false,"path":"2018/08/15/BookList/","link":"","permalink":"https://e99net.github.io/2018/08/15/BookList/","excerpt":"前言程序员的工作是编程，而高编程水平不是一蹴而就的，需要耗费时间来提升。要想缩短这个提升的过程，最好的办法就是多读书。在计算机领域浸淫了很久才意识到，静下心来多读几本好书是很有必要的，远胜于看一些教程、Ctrl+c/Ctrl+v似的伪编程。 推荐以下几本“业界良心”级的必读好书，相信每一个旨在“修炼功力”的程序员都需要它。","keywords":null,"text":"前言程序员的工作是编程，而高编程水平不是一蹴而就的，需要耗费时间来提升。要想缩短这个提升的过程，最好的办法就是多读书。在计算机领域浸淫了很久才意识到，静下心来多读几本好书是很有必要的，远胜于看一些教程、Ctrl+c/Ctrl+v似的伪编程。 推荐以下几本“业界良心”级的必读好书，相信每一个旨在“修炼功力”的程序员都需要它。 进阶书籍计算机系统 深入理解计算机系统：豆瓣评分9.9分。 编程语言 C++ C++ Primer中文版第5版：此书是“教程+参考书”，扛梁之作，初学者的不二法门。 Linux多线程服务端编程：国内作品，因为这本书的名字吓退了不少潜在读者，所以我要特别说明一下。此书是C++开发的高水平作品，与其说是教你怎么用C++写服务器开发，不如说是教你如何以服务端开发为例子提升C++开发水平。前面的书都是谈C++自己的事情，碰到像iostream这样失败的标准组件也不得不硬着头皮介绍。而这本书是接地气的实践结晶，告诉你面对具体问题时应该怎样权衡，C++里什么好用，什么不好用，为什么，等等。 Effective C++ / More Effective C++：Scott Meyers的此系列永远是学习C++者必读的，只不过这本书的第4版不知道什么时候出来。 STL源码剖析：源码面前，了无秘密。 Java Java编程思想：几乎涵盖了JavaSE的所有知识点。 (未完待续……) 算法与数据结构(未完待续……)","raw":null,"content":null,"categories":[{"name":"memo","slug":"memo","permalink":"https://e99net.github.io/categories/memo/"}],"tags":[{"name":"Water","slug":"Water","permalink":"https://e99net.github.io/tags/Water/"}]},{"title":"word中插入公式行距变大的问题","slug":"docEdit","date":"2018-07-29T06:00:59.077Z","updated":"2018-07-29T06:13:07.380Z","comments":false,"path":"2018/07/29/docEdit/","link":"","permalink":"https://e99net.github.io/2018/07/29/docEdit/","excerpt":"使用Word的人难免有插入公式的时候，插入公式时容易出现段落行距变大的问题，解决方案如下。","keywords":null,"text":"使用Word的人难免有插入公式的时候，插入公式时容易出现段落行距变大的问题，解决方案如下。 选中行距变大的那一行，右键选择”段落“ 在弹出的窗口中取消勾选”如果定义了文档网络，则对齐到网格“这一项 点击确定按钮","raw":null,"content":null,"categories":[{"name":"memo","slug":"memo","permalink":"https://e99net.github.io/categories/memo/"}],"tags":[{"name":"Latex","slug":"Latex","permalink":"https://e99net.github.io/tags/Latex/"}]},{"title":"Hadoop安装记事","slug":"hadoop","date":"2018-06-26T03:40:12.526Z","updated":"2018-06-26T03:49:16.655Z","comments":false,"path":"2018/06/26/hadoop/","link":"","permalink":"https://e99net.github.io/2018/06/26/hadoop/","excerpt":"Hadoop安装过程中遇到的问题及解决思路","keywords":null,"text":"Hadoop安装过程中遇到的问题及解决思路 DataNode用jps无法查看 slaves文件中加入hadoop01 “hadoop namenode -format”虽然提示过时，但仍然是可以用的，用于初始化hadoop，将data/name下的数据清空并将新的name信息写到data/name目录下 可以在hdfs-site.xml文件中配置dfs.data.dir参数（此参数控制目录位置）","raw":null,"content":null,"categories":[{"name":"BigData","slug":"BigData","permalink":"https://e99net.github.io/categories/BigData/"}],"tags":[{"name":"Hadoop","slug":"Hadoop","permalink":"https://e99net.github.io/tags/Hadoop/"}]},{"title":"重装系统后必做的几件事","slug":"StartwithnewOperatingSystem","date":"2018-06-19T11:38:50.369Z","updated":"2018-06-19T12:07:17.222Z","comments":false,"path":"2018/06/19/StartwithnewOperatingSystem/","link":"","permalink":"https://e99net.github.io/2018/06/19/StartwithnewOperatingSystem/","excerpt":"下面是老夫重装完系统后必做的几件事：","keywords":null,"text":"下面是老夫重装完系统后必做的几件事： 锁定浏览器主页 使“Internet选项”中的主页设置不可用 进入internet选项，把主页改成你所想要的，然后按应用，千万记住不要按确认，也不要关闭选项卡。 开始—-运行—-输入gpedit.msc打开组策略。 在左边的树状结构中找到：用户配置—-管理模板—windows组件–点击“internet explorer”找到窗口右面的一项“禁用更改主页设置”—-双击打开—选为“已启用”–下面方框设置好你想要的默认主页。 确定第一步的internet选项，关闭选项卡后再次打开internet选项卡，可以发现主页那一栏变成灰色，就是不可更改主页了。 使浏览器不被篡改 找到安装目录下的exe文件，右键属性，将其设为只读。 找到exe文件对应的快捷方式，将其设为只读。 [可选操作]在快捷方式下的目标中加入自己想要的主页地址，需注意的是，此地址与前面之间要有一个空格。 安装软件 MacType Microsoft Office 2010 Visual Studio 2013 Visual Studio Code Vmware Workstation 14 QQ 8.7 Google Chrome IE 10 Everything TEXStudio + texlive WinRAR Java jdk 7&amp;8 Python 2&amp;3","raw":null,"content":null,"categories":[{"name":"memo","slug":"memo","permalink":"https://e99net.github.io/categories/memo/"}],"tags":[{"name":"Water","slug":"Water","permalink":"https://e99net.github.io/tags/Water/"}]},{"title":"粒子群算法的一些相关资源","slug":"ResourcesofPSO","date":"2018-06-13T12:59:31.764Z","updated":"2018-09-28T02:10:17.563Z","comments":false,"path":"2018/06/13/ResourcesofPSO/","link":"","permalink":"https://e99net.github.io/2018/06/13/ResourcesofPSO/","excerpt":"【转载前辈的好博文】粒子群算法资源合辑[zz]","keywords":null,"text":"【转载前辈的好博文】粒子群算法资源合辑[zz] 发信人: logpie (Yuxuan), 信区: Circuit标 题: 粒子群算法资源合辑发信站: 紫金飞鸿 (Mon Oct 16 00:22:10 2006) 忙了大半年的big paper昨天终于投掉了。写下这个合集，一方面是对这一年零星资料的总结，另一方面是为方便有兴趣的Echoer们尽早入门，少走弯路，以加快我们合作的速度。下面列出的大部分是领域经典paper以及重要资源汇总。如有遗漏，我会不断增加的。 希望这个collecion能对大家有帮助，更渴望Echoer之间能尽早合作，望各位笑纳。Any question, plz mailto:logpie@gmail.com. Books and dissertations: Kennedy, J., Eberhart, R. C., and Shi, Y., Swarm intelligence San Francisco: Morgan Kaufmann Publishers, 2001. (PSO的founders所著) van den Bergh, Frans, “An analysis of particle swarm optimizers.” PhD’s Dissertation Department of Computer Science, University of Pretoria, South Africa, 2002. (Dr.Bergh的博士论文,详尽的给出了他对PSO的分析和改进,建议通读) Papers原始论文: Kennedy J,Eberhart R C. Particle Swarm Optimization [C]. Proceedings of IEEE International Conference on Neural Networks, Perth, Australia, 1995.1942-1948. R. C. Eberhart and J. Kennedy, “A new optimizer using particle swarm theory,”in Proc. 6th Int. Symp. Micromachine Human Sci., Nagoya,Japan, 1995 理论基础: Clerc, M. and Kennedy, J., “The particle swarm-explosion, stability, and convergence in a multidimensional complex space,” IEEE Transactions on Evolutionary Computation, vol. 6, no. 1, pp. 58-73, 2002. (较完整的给出了PSO的收敛性,并发现使用压缩因子可以保证收敛,04年IEEE Trans. EVC Best paper award,必读) Ozcan, E. and Mohan, C. K. Particle swarm optimization: surfing the waves. Proceedings of the IEEE Congress on Evolutionary Computation (CEC 1999), Washington, DC, USA. 1999 relea, I. C., “The particle swarm optimization algorithm: convergence analysis and parameter selection,” Information Processing Letters, vol. 85, no. 6, pp. 317-325, Mar.2003. (另一个较小的收敛分析) 参数设置: Shi, Y. and Eberhart, R. C. Parameter selection in particle swarm optimization. Evolutionary Programming VII: Proceedings of the Seventh Annual Conference on Evolutionary Programming, New York. pp. 591-600, 1998 Shi, Y. and Eberhart, R. C. Empirical study of particle swarm optimization. Proceedings of the IEEE Congress on Evolutionary Computation (CEC 1999), Piscataway, NJ. pp. 1945-1950, 1999 (主要是对惯性权重的试验) Carlisle, A. and Dozier, G. An off-the-shelf PSO. Proceedings of the Workshop on Particle Swarm Optimization 2001, Indianapolis, IN. 2001 (各个参数设置的比较,必读) 综述: Eberhart, R. C. and Shi, Y. Comparison between genetic algorithms and particle swarm optimization. Evolutionary Programming VII: Proceedings of the Seventh Annual Conference on Evolutionary Programming, San Diego, CA. 1998 (GA与PSO比较) Eberhart, R. C. and Shi, Y. Particle swarm optimization: developments, applications and resources. Proceedings of the IEEE Congress on Evolutionary Computation (CEC 2001), Seoul, Korea. 2001 Parsopoulos, K. E. and Vrahatis, M. N., “Recent approaches to global optimization problems through particle swarm optimization,” Natural Computing, vol. 1, no. 2-3, pp. 235-306, 2002. (很长的综述,但是比较偏重作者自己提出的几个改进,呵呵) 应用: Ismail, A. and Engelbrecht, A. P. Training Product Units in Feedforward Neural Networks using Particle Swarm Optimization. Proceedings of the International Conference on Artificial Intelligence, Durban, South Africa. pp. 36-40, 1999 van den Bergh, F. and Engelbrecht, A. P., “Cooperative learning in neural networks using particle swarm optimizers,” South African Computer Journal, vol. 26 pp. 84-90, 2000. L. Messerschmidt and A. P. Engelbrecht, “Learning to play games using a PSO-based competitive learning approach,” IEEE Trans. Evol.Comput., vol. 8, pp. 280–288, Jun. 2004. Settles, M. and Rylander, B. Neural network learning using particle swarm optimizers. Advances in Information Science and Soft Computing, pp. 224-226, 2002 Tillett, J. C., Rao, R., Sahin, F., and Rao, T. M. Cluster-head identification in ad hoc sensor networks using particle swarm optimization. Proceedings of 2002 IEEE International Conference on Personal Wireless Communications, pp. 201-205, 2002 Coello Coello, C. A., Luna, E. H. n., and Aguirre, A. H. n. Use of particle swarm optimization to design combinational logic circuits. Lecture Notes in Computer Science(LNCS) No. 2606, pp. 398-409, 2003 Tillett, J. C., Rao, R. M., Sahin, F., and Rao, T. M. Particle swarm optimization for the clustering of wireless sensors. Procedings of SPIE Vol. 5100: Digital Wireless Communications V, pp. 73-83, 2003 改进与分析_离散域拓展及组合优化: Kennedy, J. and Eberhart, R. C. A discrete binary version of the particle swarm algorithm. Proceedings of the World Multiconference on Systemics,Cybernetics and Informatics 1997, Piscataway, NJ. pp. 4104-4109, 1997 (最早的离散PSO,非常聪明的改进,值得一看) Mohan, C. K. and Al-kazemi, B. Discrete particle swarm optimization. Proceedings of the Workshop on Particle Swarm Optimization 2001, Indianapolis, IN. 2001 Laskari, E. C., Parsopoulos, K. E., and Vrahatis, M. N. Particle swarm optimization for integer programming. Proceedings of the IEEE Congress on Evolutionary Computation (CEC 2002), Honolulu, Hawaii USA. 2002 (PSO for 整数规划) Schoofs, L. and Naudts, B. Swarm intelligence on the binary constraint satisfaction problem. Proceedings of the IEEE Congress on Evolutionary Computation (CEC 2002), Honolulu, Hawaii USA. 2002 Wang, K.-P., Huang, L., Zhou, C.-G., and Pang, W. Particle swarm optimization for traveling salesman problem. Proceedings of International Conference on Machine Learning and Cybernetics 2003, pp. 1583-1585, 2003 (引入几个新算子,解决TSP问题) Clerc, M., “Discrete Particle Swarm Optimization,” New Optimization Techniques in Engineering Springer-Verlag, 2004. (Clerc大拿的DPSO,同样引入了新算子) 改进与分析_参数: Shi, Y. and Eberhart, R. C. A modified particle swarm optimizer. Proceedings of the IEEE Congress on Evolutionary Computation (CEC 1998), Piscataway, NJ. pp. 69-73, 1998 (惯性权重在此文中提出) Clerc, M. The swarm and the queen: towards a deterministic and adaptive particle swarm optimization. Proceedings of the IEEE Congress on Evolutionary Computation (CEC 1999), pp. 1951-1957, 1999 (提出了queen的思想,里面还有个重力场,比较有意思) Eberhart, R. C. and Shi, Y. Comparing inertia weigthts and constriction factors in particle swarm optimization. Proceedings of the IEEE Congress on Evolutionary Computation (CEC 2000), San Diego, CA. pp. 84-88, 2000 (惯性权重与压缩因子) Shi, Y. and Eberhart, R. C. Particle swarm optimization with fuzzy adaptive inerita weight. Proceedings of the Workshop on Particle Swarm Optimization 2001, Indianapolis, IN. 2001 (为适应动态环境,提出模糊惯性权重) A. Ratnaweera, S. Halgamuge, and H. Watson, “Self-organizing hierarchical particle swarm optimizer with time varying accelerating coefficients,”IEEE Trans. Evol. Comput., vol. 8, pp. 240–255, Jun. 2004. (对几个参数做了拓展以及非常详尽的分析) 改进与分析_粒子拓扑方向: Kennedy, J. Small worlds and mega-minds: effects of neighborhood topology on particle swarm performance. Proceedings of IEEE Congress on Evolutionary Computation (CEC 1999), Piscataway, NJ. pp. 1931-1938, 1999 (小世界拓扑对结果的影响) Suganthan, P. N. Particle swarm optimiser with neighbourhood operator. Proceedings of the IEEE Congress on Evolutionary Computation (CEC 1999), Piscataway, NJ. pp. 1958-1962, 1999 (引入领域算子) Kennedy, J. Stereotyping: improving particle swarm performance with cluster analysis. Proceedings of the IEEE Congress on Evolutionary Computation (CEC 2000), San Diego, CA. pp. 1507-1512, 2000 Kennedy, J. and Mendes, R. Population structure and particle swarm performance. Proceedings of the IEEE Congress on Evolutionary Computation (CEC 2002), Honolulu, Hawaii USA. 2002 Krink, T., Vesterstroem, J. S., and Riget, J. Particle swarm optimisation with spatial particle extension. Proceedings of the IEEE Congress on Evolutionary Computation (CEC 2002), Honolulu, Hawaii USA. 2002 Janson, S. and Middendorf, M. A hierarchical particle swarm optimizer. Proceedings of IEEE Congress on Evolutionary Computation 2003 (CEC 2003), Canbella, Australia. pp. 770-776, 2003 (使粒子动态的按照树型排列) Kennedy, J. and Mendes, R. Neighborhood topologies in fully-informed and best-of-neighborhood particle swarms. Proceedings of the 2003 IEEE International Workshop on Soft Computing in Industrial Applications 2003 (SMCia/03), pp. 45-50, 2003 R. Mendes, J. Kennedy, and J. Neves, “The fully informed particle swarm: Simpler, maybe better,” IEEE Trans. Evol. Comput., vol. 8, pp. 204–210, Jun. 2004. (重要的FIPs模型,所有粒子的信息用来更新一个粒子的信息) 改进与分析_多样性提升方向: Blackwell, T. M. and Bentley, P. J. Don’t push me! collision-avoiding swarms.Proceedings of the IEEE Congress on Evolutionary Computation (CEC 2002), Honolulu, Hawaii USA. 2002 Riget, J. and Vesterstroem, J. S. A diversity-guided particle swarm optimizer- the ARPSO. Technical Report No. 2002-02. 2002. Dept. of Computer Science, University of Aarhus, EVALife. Peram, T., Veeramachaneni, K., and Mohan, C. K. Fitness-distance-ratio based particle swarm optimization. Proceedings of the IEEE Swarm Intelligence Symposium 2003 (SIS 2003), Indianapolis, Indiana, USA. pp. 174-181, 2003 comments:很多其他类里的paper都可以归类到这儿来。 改进与分析_结合其他算法思想方向: Angeline, P. J. Using selection to improve particle swarm optimization. Proceedings of the IEEE Congress on Evolutionary Computation (CEC 1998), Anchorage, Alaska, USA. 1998 (借鉴GA里的选择优秀染色体思想) Lvbjerg, M., Rasmussen, T. K., and Krink, T. Hybrid particle swarm optimiser with breeding and subpopulations. Proceedings of the Genetic and Evolutionary Computation Conference 2001 (GECCO 2001), 2001 Higashi, N. and Iba, H. Particle swarm optimization with gaussian mutation. Proceedings of the IEEE Swarm Intelligence Symposium 2003 (SIS 2003), Indianapolis, Indiana, USA. pp. 72-79, 2003 (同样也是GA里的思想) Y.X.Wang, Z.D.Zhao, R.Ren. Hybrid Particle swarm optimizer with tabu strategy. In submission. (禁忌搜索的思想) Juang, C.-F., “A hybrid of genetic algorithm and particle swarm optimization for recurrent network design,” IEEE Transactions on Systems, Man, and Cubernetics - Part B: Cybernetics, vol. accepted 2003. SHi, X., Lu, Y., Zhou, C., Lee, H., Lin, W., and Liang, Y. Hybrid evolutionary algorithms based on PSO and GA. Proceedings of IEEE Congress on Evolutionary Computation 2003 (CEC 2003), Canbella, Australia. pp. 2393-2399, 2003 Stacey, A., Jancic, M., and Grundy, I. Particle swarm optimization with mutation. Proceedings of IEEE Congress on Evolutionary Computation 2003 (CEC 2003), Canbella, Australia. pp. 1425-1430, 2003 (GA also) 改进与分析_其他 K. E. Parsopoulos, V. P. Plagianakos, G. D. Magoulas, and M. N. Vrahatis, “Stretching technique for obtaining global minimizers through particle swarm optimization,” in Proc. Particle Swarm Optimization Workshop, Indianapolis, IN, 2001, pp. 22–29.(对目标函数的变换) K.E. Parsopoulos, M.N. Vrahatis, On the computation of all global minimizers through particle swarm optimization. IEEE Trans. on Evolutionary Computation, 2004,8(3):211-224. (上文的拓展,可以检测多全局最优,如Nash均衡点) “UPSO—A unified particle swarm optimization scheme,” in Lecture Serieson Computational Sciences, 2004, pp. 868–873. (将全局拓扑和局部拓扑结合) Al-kazemi, B. and Mohan, C. K. Multi-phase generalization of the particle swarm optimization algorithm. Proceedings of the IEEE Congress on Evolutionary Computation (CEC 2002), Honolulu, Hawaii USA. 2002 (搜索方向改进) Xie, X., Zhang, W., and Yang, Z. A dissipative particle swarm optimization. Proceedings of the IEEE Congress on Evolutionary Computation (CEC 2002), Honolulu, Hawaii USA. 2002 (类比为耗散系统,加入负熵使系统脱离平衡态) Van den Bergh F, Engelbrecht A P. A Cooperative Approach to Particle Swarm Optimization [J]. IEEE Transaction on Evolutionary Computation,2004, 8(3):225-239. (多粒子群协同优化) J. J. Liang, A. K. Qin, P. N. Suganthan and S. Baskar, “Comprehensive Learning Particle Swarm Optimizer for Global Optimization of Multimodal Functions”, IEEE Trans. on Evolutionary Computation, Vol. 10, No. 3, pp. 281-295, June 2006. (新的粒子搜索及合作策略) comments:PSO的应用以及改进方向并不止我列出的这些,比如多目标优化这里就没有给出。但这些paper已经足够入门了,各位如有兴趣可以自己搜索.04年之前一个比较全的bibliography在 http://www.swarmintelligence.org/bibliography.php 可以找到,大约300多篇。 Websites: http://www.swarmintelligence.org/ http://www.particleswarm.info/ http://clerc.maurice.free.fr/pso/ comments:这三个网站关于PSO的资源非常丰富.第3个是clerc大拿的,里面更偏重对算法数学上的分析。 Leading Journals and Confs: Evolutionary Computation (MIT press) IEEE Transactions on Evolutionary Computation IEEE Transactions on Neural Network IEEE Transactions on Systems, Man, and Cubernetics Part:A,B Genetic and Evolutionary Computation Conference (GECCO, ACM SIGEVO) IEEE Congress on Evolutionary Computation(CEC) Parallel Problem Solving from Nature (PPSN) Homepages http://www.adaptivebox.net/research/ (Dr.Xiaofeng Xie, TSU) http://www.ntu.edu.sg/home/EPNSugan/ (Prof.Suganthan, NYU) http://goanna.cs.rmit.edu.au/~xiaodong/ (Prof. XiaoDong, RMIT) http://clerc.maurice.free.fr/ (Dr.Clerc, France Telecom, Strongly recommend) comments:上面是我常去的一些page,主要的PSO学者在 http://www.particleswarm.info/people.html 上可以找到 Benchmarks http://www-optima.amp.i.kyoto-u.ac.jp/member/student/hedar/Hedar_files/TestGO_files/Page364.htm http://www2.imm.dtu.dk/~km/GlobOpt/testex/testproblems.html#07 http://www.cs.cmu.edu/afs/cs/project/jair/pub/volume24/ortizboyer05a-html/node6.html http://www.geatbx.com/docu/fcnindex.html http://www.maths.uq.edu.au/CEToolBox/node2.html J. G. DIGALAKIS and K. G. MARGARITIS. ON BENCHMARKING FUNCTIONS OR GENETIC ALGORITHMS. Inter J Computer Math., Vol. 00, pp. 1-27 (给出了大多数标准无约束测试函数的性态分析) Comments:改进或提出一个优化算法需要对其作出性能评测,这里提供一些标准的测试集,包括DeJong系列函数,Rastrigin系列函数等,以及其他有约束,离散,组合优化标准测试问题. 最近Prof.Suganthan等提出了一套Composition functions,具体参见他的homepage,同样CEC05上也提出了大约30个测试函数.对这些函数进行rotate,shift,distortion等操作可以变换为更复杂的函数,具体请参加相关paper。 code、software、projects、implementations http://xps-swarm.essex.ac.uk (有些类似与以前的EVALife project, 同样有Santa Fe的参与, 重视学科交叉) http://cilib.sourceforge.net (计算智能库, written in java) http://clerc.maurice.free.fr/pso/ http://www.particleswarm.info/Programs.html#Standard_PSO_2006 (一些PSO的项目) http://www.mathworks.com/matlabcentral/fileexchange/loadFile.do?objectId=7506 (pso matlab toolbox) ftp://www.china2china.com/ user:pso, passwd:pso (一些paper可以在这里直接下载) comments:各位如果需要几个重要PSO改进的matlab实现,请联系prof.suganthan或直接发邮件给我. Future work2004 年IEEE Transactions on Evolutionary Computation出版了Special issue on PSO,卷首语中指出了当前研究的几个主要方向及热点: 算法分析. PSO在实际应用中被证明是有效的, 但目前还没有给出完整收敛性、收敛速度估计等方面的数学证明,已有的工作还远远不够。 粒子群拓扑结构.不同的粒子群邻居拓扑结构是对不同类型社会的模拟,研究不同拓扑结构的适用范围,对PSO算法推广和使用有重要意义。 参数选择与优化.参数w、φ1、φ2的选择分别关系粒子速度的3个部分:惯性部分、社会部分和感知部分在搜索中的作用.如何选择、优化和调整参数,使得算法既能避免早熟又能比较快速地收敛,对工程实践有着重要意义。 与其他演化计算的融合.如何将其它演化的优点和PSO的优点相结合,构造出新的混合算法是当前算法改进的一个重要方向。 算法应用.算法的有效性必须在应用中才能体现,广泛地开拓PSO的应用领域,也对深化研究PSO算法非常有意义。 我在以前的帖子里曾经提到过,PSO是很适合演化计算方向入门的.特别是其算法实现非常简单,因此建议大家能够先实现基础算法.如果想进一步了解乃至研究,上面列出的除了应用的几十篇paper基本都是需要看的.PSO从提出到现在已经11年了,大小坑挖的也不少了,各位如果想在这个领域出新,出好结果,还是需要有一定功力的.对于我们目前的情况,我认为大家可以主要将精力集中在第(5)点。http://www.particleswarm.info/Problems.html 也列出了一些有意思的open problems。当然,都是有一定难度的 :-) 对于PSO的改进与分析,如何有能力的话,我仍然坚持认为一个突破口是学科交叉,比如粒子搜索的混沌行为,粒子进化以及合作策略中的博弈,统计物理学在群智能中的应用等等.这也是我接下来的研究内容.另外Clerc大拿网站上也有一篇经常更新的paper,”Some ideas about Particle Swarm Optimisation”,里面记录了很多他对PSO的理解,同样非常值得一看。 –logpie=0.497 ※ 来源:·紫金飞鸿 bbs.njupt.edu.cn·","raw":null,"content":null,"categories":[{"name":"EAs","slug":"EAs","permalink":"https://e99net.github.io/categories/EAs/"}],"tags":[{"name":"PSO","slug":"PSO","permalink":"https://e99net.github.io/tags/PSO/"}]},{"title":"在Ubuntu上完美安装oh-my-zsh","slug":"install_oh-my-zsh_of_ubuntu","date":"2018-06-07T12:25:27.582Z","updated":"2018-06-07T13:54:52.383Z","comments":false,"path":"2018/06/07/install_oh-my-zsh_of_ubuntu/","link":"","permalink":"https://e99net.github.io/2018/06/07/install_oh-my-zsh_of_ubuntu/","excerpt":"前戏查看系统当前使用的shell","keywords":null,"text":"前戏查看系统当前使用的shell12$ echo $SHELL/bin/bash 查看系统是否安装了zsh12345$ cat /etc/shells/bin/sh/bin/bash/usr/bin/sh/usr/bin/bash 安装zsh一般来说，直接运行 sudo apt-get install zsh 即可。当然也可以下载源Download zsh source，使用curl安装 curl -L https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh | sh 把zsh设为默认终端 chsh -s $(which zsh) 重启系统，可使用 reboot 重启后，查看当前shell 12$ echo $SHELL/bin/zsh 安装oh-my-zsh1wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh 配置123$ vim ~/.zshrcZSH_THEME=&quot;agnoster&quot;$ source ~/.zshrc agnoster主题终端乱码的解决方案123$ git clone https://github.com/powerline/fonts$ cd ~/fonts$ ./install.sh 然后在配置终端，依次选择“编辑”-&gt;“配置文件首选项”，选择“自定义字体”，字体为“Ubuntu Mono derivative Powerline Regular”即可。 另外一种解决方案来自csdn：CoderMannul的博客还有一种解决方案是1$ vi ~/.zshrc 在文件中添加内容：1export LC_ALL=en_US.UTF-8 并解除注释1export LANG=en_US.UTF-8 接着重启终端，或输入 source ~/.zshrc 即可。以上两种解决方案一般不用，只有在第一种方案不行时才尝试一下。 小彩蛋：在~/.zshrc中添加1export DEFAULT_USER=&quot;[你的username]&quot; 即可隐藏固定的username@hostname信息。另外，1$ vim ~/.oh-my-zsh/themes/agnoster.zsh-theme 注释掉最下面1234567891011## Main promptbuild_prompt() &#123; RETVAL=$? prompt_status prompt_virtualenv prompt_context prompt_dir prompt_git prompt_hg prompt_end&#125; 中的一句 prompt_context 也能实现相同的效果。（一般不采用此方法） 启用插件oh-my-zsh自带了一些默认主题，存放在~/.oh-my-zsh/plugins目录中，我们可以查看这些插件。oh-my-zsh默认只启用git插件1plugins=(git) 如需启用更多插件，只需加入需启用的插件名称即可，如1plugins=(git history-substring-search) 小技巧设置自动更新oh-my-zsh。默认情况下，当oh-my-zsh有更新时，都会给你提示。如果希望让oh-my-zsh自动更新，在~/.zshrc 中添加下面这句1DISABLE_UPDATE_PROMPT=true 要手动更新，可以执行1$ upgrade_oh_my_zsh 卸载oh-my-zsh，直接在终端中运行如下命令即可。1uninstall_oh_my_zsh 安装没带的插件 安装zsh-syntax-highlighting语法高亮插件 123$ git clone https://github.com/zsh-users/zsh-syntax-highlighting.git$ echo &quot;source $&#123;(q-)PWD&#125;/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh&quot; &gt;&gt; $&#123;ZDOTDIR:-$HOME&#125;/.zshrc$ source ~/.zshrc 安装zsh-autosuggestions语法历史记录插件 12345$ git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions$ vim ~/.zshrcplugins=(git zsh-autosuggestions)source $ZSH_CUSTOM/plugins/zsh-autosuggestions/zsh-autosuggestions.zsh（加在zshrc文件最后一行）$ source ~/.zshrc 安装incr补全插件 12$ wget http://mimosa-pudica.net/src/incr-0.2.zsh$ mv ~/incr-0.2.zsh ~/.oh-my-zsh/plugins/ 将 source ~/.oh-my-zsh/plugins/incr/incr*.zsh 一句加在zshrc文件末尾，然后1$ source ~/.zshrc 与vim的提示冲突的解决方案使用自动补全插件可能会与vim的提示功能相冲突，如会报以下错误：12$ vim t_arguments:451: _vim_files: function definition file not found 此时，将~/.zcompdump*删除即可12$ rm -rf ~/.zcompdump*$ exec zsh 让Windows下的putty、secureCRT等工具支持Powerline，使得oh-my-zsh正常显示、不出现乱码 将这些工具的编码改为UTF-8 下载支持Powerline的字体（DejaVu for Powerline.zip），将解压后的tty文件拖入“C:\\Windows\\Fonts”下，重启工具更改设置，选择终端窗口使用的字体为“DejaVu for Powerline”即可。","raw":null,"content":null,"categories":[{"name":"memo","slug":"memo","permalink":"https://e99net.github.io/categories/memo/"}],"tags":[{"name":"Water","slug":"Water","permalink":"https://e99net.github.io/tags/Water/"}]},{"title":"pip3版本8升级到版本10后，Pycharm装包出错的解决方案","slug":"pipofpycharm","date":"2018-06-02T06:15:43.535Z","updated":"2018-06-02T06:23:44.889Z","comments":false,"path":"2018/06/02/pipofpycharm/","link":"","permalink":"https://e99net.github.io/2018/06/02/pipofpycharm/","excerpt":"Python3的pip从版本8升级到版本10之后，在Pycharm中安装package，会出现如下问题: AttributeError: module ‘pip’ has no attribute ‘main’ 解决方案如下：找到安装目录下的helpers/packaging_tool.py文件，将如下代码","keywords":null,"text":"Python3的pip从版本8升级到版本10之后，在Pycharm中安装package，会出现如下问题: AttributeError: module ‘pip’ has no attribute ‘main’ 解决方案如下：找到安装目录下的helpers/packaging_tool.py文件，将如下代码12345678910111213def do_install(pkgs): try: import pip except ImportError: error_no_pip() return pip.main([&apos;install&apos;] + pkgs)def do_uninstall(pkgs): try: import pip except ImportError: error_no_pip() return pip.main([&apos;uninstall&apos;, &apos;-y&apos;] + pkgs) 修改为如下代码12345678910111213141516171819202122def do_install(pkgs): try: # import pip try: from pip._internal import main except Exception: from pip import main except ImportError: error_no_pip() return main([&apos;install&apos;] + pkgs)def do_uninstall(pkgs): try: # import pip try: from pip._internal import main except Exception: from pip import main import pip except ImportError: error_no_pip() return main([&apos;uninstall&apos;, &apos;-y&apos;] + pkgs)","raw":null,"content":null,"categories":[{"name":"memo","slug":"memo","permalink":"https://e99net.github.io/categories/memo/"}],"tags":[{"name":"Water","slug":"Water","permalink":"https://e99net.github.io/tags/Water/"}]},{"title":"自定义右键菜单","slug":"define_rightmenu_byyourself","date":"2018-05-27T09:37:00.765Z","updated":"2018-06-18T04:27:05.485Z","comments":false,"path":"2018/05/27/define_rightmenu_byyourself/","link":"","permalink":"https://e99net.github.io/2018/05/27/define_rightmenu_byyourself/","excerpt":"许多绿色版的软件无法像那些安装版的软件一样添加到右键菜单，导致很不方便，这时可以自己将其添加到右键菜单，提高工作效率。下面以Sublime Text为例加以说明：","keywords":null,"text":"许多绿色版的软件无法像那些安装版的软件一样添加到右键菜单，导致很不方便，这时可以自己将其添加到右键菜单，提高工作效率。下面以Sublime Text为例加以说明： 打开注册表 找到HKEY_CLASSESS_ROOT-&gt; * -&gt;Shell，在下面新建项，命名为“Sublime Text”。 在项“Sublime Text”下新建字符串值，命名为“Icon”，将其值设为“X:\\path\\to\\sublime_text.exe,0”。其中，0前面的是Sublime Text在你电脑上的安装路径。 在项“Sublime Text”下再新建项“Command”，Command项下的默认值修改为“X:\\path\\to\\sublime_text.exe %1”。 设置完成后，关闭注册表，右键菜单即会出现“Sublime Text”。","raw":null,"content":null,"categories":[{"name":"memo","slug":"memo","permalink":"https://e99net.github.io/categories/memo/"}],"tags":[{"name":"Water","slug":"Water","permalink":"https://e99net.github.io/tags/Water/"}]},{"title":"C语言核心技术","slug":"cinanutshell","date":"2018-05-26T13:22:02.348Z","updated":"2018-05-26T13:25:00.204Z","comments":false,"path":"2018/05/26/cinanutshell/","link":"","permalink":"https://e99net.github.io/2018/05/26/cinanutshell/","excerpt":"宽字符为了更好地支持Unicode，C11引入额外的宽字符类型char16_t和char32_t。在头文件uchar.h中，它们被定义为无符号整数类型。","keywords":null,"text":"宽字符为了更好地支持Unicode，C11引入额外的宽字符类型char16_t和char32_t。在头文件uchar.h中，它们被定义为无符号整数类型。","raw":null,"content":null,"categories":[{"name":"memo","slug":"memo","permalink":"https://e99net.github.io/categories/memo/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://e99net.github.io/tags/C-C/"}]},{"title":"Latex设置行间距","slug":"linespace_of_latex","date":"2018-05-26T03:23:07.926Z","updated":"2018-05-26T03:26:41.783Z","comments":false,"path":"2018/05/26/linespace_of_latex/","link":"","permalink":"https://e99net.github.io/2018/05/26/linespace_of_latex/","excerpt":"全局设置行间距像Word一样设置单倍间距、1.5倍间距、2倍间距等。 12\\usepackage&#123;setspace&#125;\\renewcommand&#123;\\baselinestretch&#125;&#123;1.0&#125;","keywords":null,"text":"全局设置行间距像Word一样设置单倍间距、1.5倍间距、2倍间距等。 12\\usepackage&#123;setspace&#125;\\renewcommand&#123;\\baselinestretch&#125;&#123;1.0&#125; 局部设置行间距12345678910111213%使用行距宏包，该宏包自带三个选项：singlespacing（默认）, onehalfspacing和doublespacing\\usepackage&#123;setspace&#125;\\begin&#123;document&#125;%行间距变为double-space\\begin&#123;spacing&#125;&#123;2.0&#125;双倍行距的段落内容。\\end&#123;spacing&#125;%行间距变为single-space\\begin&#123;spacing&#125;&#123;1.0&#125;单倍行距的段落内容。\\end&#123;spacing&#125;\\end&#123;document&#125;","raw":null,"content":null,"categories":[{"name":"memo","slug":"memo","permalink":"https://e99net.github.io/categories/memo/"}],"tags":[{"name":"Latex","slug":"Latex","permalink":"https://e99net.github.io/tags/Latex/"}]},{"title":"Latex的beamer中显示图片编号","slug":"beamer_showfigid","date":"2018-05-24T13:50:37.038Z","updated":"2018-05-24T13:54:48.324Z","comments":false,"path":"2018/05/24/beamer_showfigid/","link":"","permalink":"https://e99net.github.io/2018/05/24/beamer_showfigid/","excerpt":"在beamer幻灯片中如果插入图形，一般不会显示图形编号，这是其默认模式，但我们可以通过设置给图形编号，在导言区加上如下命令即可。","keywords":null,"text":"在beamer幻灯片中如果插入图形，一般不会显示图形编号，这是其默认模式，但我们可以通过设置给图形编号，在导言区加上如下命令即可。1\\setbeamertemplate&#123;caption&#125;[numbered] 这样在正文的某页写入123456\\begin&#123;frame&#125; \\begin&#123;figure&#125; \\includegraphics[width=0.5\\textwidth]&#123;letter.pdf&#125; \\caption&#123;26个英文字母表&#125; \\end&#123;figure&#125;\\end&#123;frame&#125; 运行后就能显示图1,图2等编号了。","raw":null,"content":null,"categories":[{"name":"memo","slug":"memo","permalink":"https://e99net.github.io/categories/memo/"}],"tags":[{"name":"Latex","slug":"Latex","permalink":"https://e99net.github.io/tags/Latex/"}]},{"title":"XeLatex在window上编译很慢的解决方法","slug":"texslow","date":"2018-05-24T12:57:03.015Z","updated":"2018-05-24T12:58:38.731Z","comments":false,"path":"2018/05/24/texslow/","link":"","permalink":"https://e99net.github.io/2018/05/24/texslow/","excerpt":"环境：win7 + texlive 2017 + TeXstudio","keywords":null,"text":"环境：win7 + texlive 2017 + TeXstudio 解决方法： A. 以管理员身份运行fc-cache B. 在texlive安装路径bin/win32下，设置xelatex.exe以管理员身份启动。 C. 启动TeXstudio时以管理员身份启动","raw":null,"content":null,"categories":[{"name":"memo","slug":"memo","permalink":"https://e99net.github.io/categories/memo/"}],"tags":[{"name":"Latex","slug":"Latex","permalink":"https://e99net.github.io/tags/Latex/"}]},{"title":"“ES连不上电脑了，一直卡在登陆界面”问题的解决方案","slug":"esconn","date":"2018-05-24T09:00:51.674Z","updated":"2018-05-24T09:02:23.423Z","comments":false,"path":"2018/05/24/esconn/","link":"","permalink":"https://e99net.github.io/2018/05/24/esconn/","excerpt":"本地策略，安全选项","keywords":null,"text":"本地策略，安全选项网络访问: 本地帐户的共享和安全模型,属性改为”经典 - 本地用户以自己的身份验证”.","raw":null,"content":null,"categories":[{"name":"memo","slug":"memo","permalink":"https://e99net.github.io/categories/memo/"}],"tags":[{"name":"Water","slug":"Water","permalink":"https://e99net.github.io/tags/Water/"}]},{"title":"作为一位计算机专业的大学生，大学四年毕业时怎样才算合格？","slug":"tremble","date":"2018-05-23T12:51:14.149Z","updated":"2018-05-23T12:56:30.748Z","comments":false,"path":"2018/05/23/tremble/","link":"","permalink":"https://e99net.github.io/2018/05/23/tremble/","excerpt":"写得了算法翻得了墙 搭得了网站查得了虫","keywords":null,"text":"写得了算法翻得了墙 搭得了网站查得了虫 博客300篇，篇篇有心得 框架善应用，源码常思量 文能OJ秒AC，武能项目撸万行 博览中外群书，夜寐常访论坛 数据结构在心间，抬头代码扫两行 linux玩转于手间，语言专攻有余粮","raw":null,"content":null,"categories":[{"name":"memo","slug":"memo","permalink":"https://e99net.github.io/categories/memo/"}],"tags":[{"name":"Water","slug":"Water","permalink":"https://e99net.github.io/tags/Water/"}]},{"title":"Windows下icwb2-data的评估用法","slug":"icwb2-data","date":"2018-05-19T07:01:39.425Z","updated":"2018-05-21T08:02:14.646Z","comments":false,"path":"2018/05/19/icwb2-data/","link":"","permalink":"https://e99net.github.io/2018/05/19/icwb2-data/","excerpt":"利用icwb2-data工具包对中文分词预测结果进行评估工具包下载地址http://sighan.cs.uchicago.edu/bakeoff2005/","keywords":null,"text":"利用icwb2-data工具包对中文分词预测结果进行评估工具包下载地址http://sighan.cs.uchicago.edu/bakeoff2005/ 安装ActivePerl，先能识别后缀名为.pl的文件 安装diffUtil工具包。 http://gnuwin32.sourceforge.net/packages/diffutils.htm 直接下载setup格式的安装包 修改icwb2-data/scripts/score脚本 把46行的代码修改成： 1$diff = “E:/GnuWin32/bin/diff”;(该目录为安装目录) 把52,53行的代码修改成：(注意E:/GnuWin32/tmp目录要存在) 12tmp1=“E:/GnuWin32/tmp/comp01$”;tmp2=“E:/GnuWin32/tmp/comp02$”; 将diffUtil下的bin目录加到环境变量中。 运行1234//进入前面预测、测试的生成文件目录下perl score 训练文件 测试文件名 输出结果名 &gt;输出到的文件名//例如:perl score maxtrain11.txt maxtest11.txt maxoutput.txt &gt; o.txt 在输出的文件“o.txt”下即可查看正确率、召回率等。","raw":null,"content":null,"categories":[{"name":"memo","slug":"memo","permalink":"https://e99net.github.io/categories/memo/"}],"tags":[{"name":"Natural Language Processing","slug":"Natural-Language-Processing","permalink":"https://e99net.github.io/tags/Natural-Language-Processing/"}]},{"title":"前端框架之AngularJS","slug":"AngularJS","date":"2018-05-18T12:25:34.851Z","updated":"2018-05-18T13:05:47.515Z","comments":false,"path":"2018/05/18/AngularJS/","link":"","permalink":"https://e99net.github.io/2018/05/18/AngularJS/","excerpt":"AngularJS应用的指令标签中的ng-app是AngularJS的一个内置指令（实际上，可以出现在任意位置，但通常情况下，我们会把ng-app指令放在标签中，让AngularJS管理整个页面），有两个作用，一个是启动AngularJS框架，另一个是告诉AngularJS框架从ng-app指令所在标签的开始标签到结束标签之间的所有SOM元素由AngularJS框架进行管理。当AngularJS遇到ng-app指令时就会创建一个名为$rootScope的作用域，该作用域为AngularJS应用的根作用域。 ng-init指令用于初始化作用域。","keywords":null,"text":"AngularJS应用的指令标签中的ng-app是AngularJS的一个内置指令（实际上，可以出现在任意位置，但通常情况下，我们会把ng-app指令放在标签中，让AngularJS管理整个页面），有两个作用，一个是启动AngularJS框架，另一个是告诉AngularJS框架从ng-app指令所在标签的开始标签到结束标签之间的所有SOM元素由AngularJS框架进行管理。当AngularJS遇到ng-app指令时就会创建一个名为$rootScope的作用域，该作用域为AngularJS应用的根作用域。 ng-init指令用于初始化作用域。 AngularJS应用构成元素 模型（Model） 视图（View）：从AngularJS应用的角度来说，视图则是AngularJS指令与表达式经过解析后的DOM元素。 控制器（Controller） 作用域（Scope） 指令（Directives） 表达式（Expressions） 模板（Template）：AngularJS以HTML作为模板语言，AngularJS模板实际上就是HTML片段。 双向数据绑定ng-model1&lt;input type=&quot;text&quot; name=&quot;uname&quot; ng-model=&quot;uname&quot; /&gt; ng-bind指令ng-bind指令在AngularJS没有加载完毕的时候是不会解析执行的，只有AngularJS加载完毕才会执行。","raw":null,"content":null,"categories":[{"name":"memo","slug":"memo","permalink":"https://e99net.github.io/categories/memo/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://e99net.github.io/tags/Web/"}]},{"title":"Windows编程","slug":"WindowsProgramming","date":"2018-05-16T12:48:44.619Z","updated":"2019-01-05T12:22:20.080Z","comments":false,"path":"2018/05/16/WindowsProgramming/","link":"","permalink":"https://e99net.github.io/2018/05/16/WindowsProgramming/","excerpt":"头文件Windows.h是主要的包含文件，它包含了其他Windows头文件，这些头文件的某些也包含了其他头文件。这些头文件中最重要的和最基本的是： WINDEF.H 基本类型定义 WINNT.H 支持Unicode的类型定义 WINBASE.H 内核函数 WINUSER.H 用户接口函数 WINGDI.H 图形设备接口函数这些头文件定义了Windows的所有数据类型、函数调用、数据结构和常数标识符。","keywords":null,"text":"头文件Windows.h是主要的包含文件，它包含了其他Windows头文件，这些头文件的某些也包含了其他头文件。这些头文件中最重要的和最基本的是： WINDEF.H 基本类型定义 WINNT.H 支持Unicode的类型定义 WINBASE.H 内核函数 WINUSER.H 用户接口函数 WINGDI.H 图形设备接口函数这些头文件定义了Windows的所有数据类型、函数调用、数据结构和常数标识符。 Windows程序的入口点是WinMain，在WINBASE.H中声明如下：12345678intWINAPIWinMain(HINSTANCE hInstance,HINSTANCE hPrevInstance,LPSTR lpCmdLine,int nShowCmd);","raw":null,"content":null,"categories":[{"name":"memo","slug":"memo","permalink":"https://e99net.github.io/categories/memo/"}],"tags":[{"name":"Windows Programming","slug":"Windows-Programming","permalink":"https://e99net.github.io/tags/Windows-Programming/"}]},{"title":"Mendeley插入引用和参考文献","slug":"mendeley","date":"2018-05-12T05:39:14.601Z","updated":"2019-09-21T11:53:09.713Z","comments":false,"path":"2018/05/12/mendeley/","link":"","permalink":"https://e99net.github.io/2018/05/12/mendeley/","excerpt":"首先在word里点击insert citation，选择回到mendeley 然后选择要插入文档，点击select the document 回到word点击citation style,生成引用 最后文章写完了,新起一行,点击insert bibliography生成参考文献","keywords":null,"text":"首先在word里点击insert citation，选择回到mendeley 然后选择要插入文档，点击select the document 回到word点击citation style,生成引用 最后文章写完了,新起一行,点击insert bibliography生成参考文献","raw":null,"content":null,"categories":[{"name":"memo","slug":"memo","permalink":"https://e99net.github.io/categories/memo/"}],"tags":[{"name":"Paper","slug":"Paper","permalink":"https://e99net.github.io/tags/Paper/"}]},{"title":"Powershell执行脚本文件","slug":"Powershell","date":"2018-05-08T10:25:29.987Z","updated":"2018-05-09T03:02:26.627Z","comments":false,"path":"2018/05/08/Powershell/","link":"","permalink":"https://e99net.github.io/2018/05/08/Powershell/","excerpt":"Powershell拥有自己的脚本，扩展名为“.ps1”","keywords":null,"text":"Powershell拥有自己的脚本，扩展名为“.ps1” 默认情况下ps1文件不能被执行，这导致在初次执行脚本时可能会碰到一个异常。原因是powershell的默认安全设置禁用了执行脚本，要启用这个功能必须要拥有管理员的权限。在powershell中执行以下命令方可执行本地的ps1脚本文件： set-executionpolicy remotesigned","raw":null,"content":null,"categories":[{"name":"memo","slug":"memo","permalink":"https://e99net.github.io/categories/memo/"}],"tags":[{"name":"Water","slug":"Water","permalink":"https://e99net.github.io/tags/Water/"}]},{"title":"搭建Hadoop过程中的虚拟机相关问题","slug":"VirtualMachineOfHadoop","date":"2018-04-13T04:50:18.570Z","updated":"2018-05-09T03:04:04.793Z","comments":false,"path":"2018/04/13/VirtualMachineOfHadoop/","link":"","permalink":"https://e99net.github.io/2018/04/13/VirtualMachineOfHadoop/","excerpt":"用多个CentOS6.5系统作为Hadoop集群的平台，在Vmware虚拟机中安装好一个CentOS6.5系统后再多复制几个即可模拟Hadoop集群的多个节点。","keywords":null,"text":"用多个CentOS6.5系统作为Hadoop集群的平台，在Vmware虚拟机中安装好一个CentOS6.5系统后再多复制几个即可模拟Hadoop集群的多个节点。 在操作过程中遇到了几个虚拟机的相关问题，先整理如下：一、新安装好的CentOS6.5系统无法连接网络解决方法：二、复制的CentOS6.5系统无法连接网络解决方法：","raw":null,"content":null,"categories":[{"name":"memo","slug":"memo","permalink":"https://e99net.github.io/categories/memo/"}],"tags":[{"name":"Hadoop","slug":"Hadoop","permalink":"https://e99net.github.io/tags/Hadoop/"}]},{"title":"Ubuntu16.04安装WPS","slug":"WpsofUbuntu","date":"2018-04-13T04:50:18.570Z","updated":"2018-05-09T03:04:13.451Z","comments":false,"path":"2018/04/13/WpsofUbuntu/","link":"","permalink":"https://e99net.github.io/2018/04/13/WpsofUbuntu/","excerpt":"下载安装 下载：WPS For Linux 安装命令 sudo dpkg -i wps-office_10.1.0.5672_a21_amd64.deb 字体缺失问题 下载wps_symbol_fonts.zip 创建目录：","keywords":null,"text":"下载安装 下载：WPS For Linux 安装命令 sudo dpkg -i wps-office_10.1.0.5672_a21_amd64.deb 字体缺失问题 下载wps_symbol_fonts.zip 创建目录： sudo mkdir /usr/share/fonts/wps-office 将下载的字体复制到创建的目录： sudo cp -r wps_symbol_fonts.zip /usr/share/fonts/wps-office 切换到创建的目录： cd /usr/share/fonts/wps-office 解压字体包： sudo unzip wps_symbol_fonts.zip 解压后删除字体包： sudo rm -r wps_symbol_fonts.zip","raw":null,"content":null,"categories":[{"name":"memo","slug":"memo","permalink":"https://e99net.github.io/categories/memo/"}],"tags":[{"name":"Water","slug":"Water","permalink":"https://e99net.github.io/tags/Water/"}]},{"title":"Ubuntu16.04更换漂亮的主题","slug":"ThemeofUbuntu","date":"2018-04-13T04:50:18.539Z","updated":"2018-05-09T03:03:55.260Z","comments":false,"path":"2018/04/13/ThemeofUbuntu/","link":"","permalink":"https://e99net.github.io/2018/04/13/ThemeofUbuntu/","excerpt":"更新 sudo apt-get updatesudo apt-get upgrade","keywords":null,"text":"更新 sudo apt-get updatesudo apt-get upgrade 安装unity-tweak-tool sudo apt-get install unity-tweak-tool 安装Flatabulous主题 sudo add-apt-repository ppa:noobslab/themessudo apt-get updatesudo apt-get install flatabulous-theme 安装Flatabulous主题的配套图标 sudo add-apt-repository ppa:noobslab/iconssudo apt-get updatesudo apt-get install ultra-flat-icons 打开Unity Tweak Tool，选择“主题”里面的Flatabulous，然后选择“图标”里面的Ultra-flat。 至此，美化结束。","raw":null,"content":null,"categories":[{"name":"memo","slug":"memo","permalink":"https://e99net.github.io/categories/memo/"}],"tags":[{"name":"Water","slug":"Water","permalink":"https://e99net.github.io/tags/Water/"}]},{"title":"Ubuntu16.04安装texlive+texstudio搭建Latex","slug":"TexofUbuntu","date":"2018-04-13T04:50:18.523Z","updated":"2018-05-09T03:03:48.679Z","comments":false,"path":"2018/04/13/TexofUbuntu/","link":"","permalink":"https://e99net.github.io/2018/04/13/TexofUbuntu/","excerpt":"1.安装texlive","keywords":null,"text":"1.安装texlive sudo apt-get install texlive-full 2.安装中文字体包 sudo apt-get install latex-cjk-all 3.安装texstudio sudo apt-get install texstudio","raw":null,"content":null,"categories":[{"name":"memo","slug":"memo","permalink":"https://e99net.github.io/categories/memo/"}],"tags":[{"name":"Water","slug":"Water","permalink":"https://e99net.github.io/tags/Water/"}]},{"title":"关于高校资助管理系统的一点思考","slug":"SugOfSch","date":"2018-04-13T04:50:18.507Z","updated":"2018-05-09T03:03:39.555Z","comments":false,"path":"2018/04/13/SugOfSch/","link":"","permalink":"https://e99net.github.io/2018/04/13/SugOfSch/","excerpt":"此处的高校资助管理系统是基于Web的管理系统。","keywords":null,"text":"此处的高校资助管理系统是基于Web的管理系统。 点击左侧相应条目，就会在右边的内容区域新建标签页以使用户进行操作。但设计者竟然没有在标签页区域做任何“文章”，用户体验极差：同时打开多个标签页之后若想关闭，还得一个一个手动关闭。。。。建议：在系统里引进jQuery的标签页插件，可以在标签页区域加入鼠标右键单击事件，供用户选择的选项有“关闭其他标签页”“关闭标签页”“关闭全部标签页”等，这样可以更人性化一点。","raw":null,"content":null,"categories":[{"name":"memo","slug":"memo","permalink":"https://e99net.github.io/categories/memo/"}],"tags":[{"name":"Water","slug":"Water","permalink":"https://e99net.github.io/tags/Water/"}]},{"title":"ConEmu的些许设置","slug":"SettingsOfConemu","date":"2018-04-13T04:50:18.492Z","updated":"2018-05-09T03:03:21.611Z","comments":false,"path":"2018/04/13/SettingsOfConemu/","link":"","permalink":"https://e99net.github.io/2018/04/13/SettingsOfConemu/","excerpt":"添加ConEmu到Windows右键菜单进行ConEmu界面,打开设置,如下图:","keywords":null,"text":"添加ConEmu到Windows右键菜单进行ConEmu界面,打开设置,如下图: 然后,打开Integreation,将“cmd -cur_console:n”改为“cmd -cur_console:n %P”,如图操作: 点击”Save settings”,回到Windows桌面或是TotalCommander界面就可以看到右键菜单里已经有ConEmu选项了.","raw":null,"content":null,"categories":[{"name":"memo","slug":"memo","permalink":"https://e99net.github.io/categories/memo/"}],"tags":[{"name":"Water","slug":"Water","permalink":"https://e99net.github.io/tags/Water/"}]},{"title":"Latex中的空格","slug":"SpaceofLatex","date":"2018-04-13T04:50:18.492Z","updated":"2018-05-09T03:03:29.881Z","comments":false,"path":"2018/04/13/SpaceofLatex/","link":"","permalink":"https://e99net.github.io/2018/04/13/SpaceofLatex/","excerpt":"两个quad空格 \\qquad 两个m的宽度 quad空格 \\quad 一个m的宽度","keywords":null,"text":"两个quad空格 \\qquad 两个m的宽度 quad空格 \\quad 一个m的宽度 大空格 \\ 1/3m的宽度 中等空格 \\; 2/7m的宽度 小空格 \\, 1/6m的宽度 没有空格 紧贴 ! 缩进1/6m的宽度","raw":null,"content":null,"categories":[{"name":"memo","slug":"memo","permalink":"https://e99net.github.io/categories/memo/"}],"tags":[{"name":"Latex","slug":"Latex","permalink":"https://e99net.github.io/tags/Latex/"}]},{"title":"关于Windows通过远程桌面访问Ubuntu","slug":"RemoteAccess","date":"2018-04-13T04:50:18.492Z","updated":"2018-05-09T03:03:09.739Z","comments":false,"path":"2018/04/13/RemoteAccess/","link":"","permalink":"https://e99net.github.io/2018/04/13/RemoteAccess/","excerpt":"从Ubuntu13.10开始，据说是由于xrdp、gnome和unity之间的兼容性问题，在Ubuntu中无法使用xrdp登录gnome或unity的远程桌面，现象是登录后只有黑白点为背景，无图标也无法操作。","keywords":null,"text":"从Ubuntu13.10开始，据说是由于xrdp、gnome和unity之间的兼容性问题，在Ubuntu中无法使用xrdp登录gnome或unity的远程桌面，现象是登录后只有黑白点为背景，无图标也无法操作。 解决办法是：使用xrdp登录xfce的远程桌面，或者也可以使用xrdp登录Mate的远程桌面。","raw":null,"content":null,"categories":[{"name":"memo","slug":"memo","permalink":"https://e99net.github.io/categories/memo/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"https://e99net.github.io/tags/Machine-Learning/"}]},{"title":"技术面试","slug":"Questions","date":"2018-04-13T04:50:18.476Z","updated":"2018-05-09T03:02:59.035Z","comments":false,"path":"2018/04/13/Questions/","link":"","permalink":"https://e99net.github.io/2018/04/13/Questions/","excerpt":"基础打牢了吗？常问问题（Java） HashTable与HashMap有什么区别？ Servlet是线程安全的吗？","keywords":null,"text":"基础打牢了吗？常问问题（Java） HashTable与HashMap有什么区别？ Servlet是线程安全的吗？ JSP中@include跟jsp：include的区别。 HTTP的respomse code 403和500分别代表什么？ 这些问题都很简单，但一些基础不牢的程序员往往会在这个时候露馅。 曾经碰到过一个在简历中说自己精通C++的应聘者，连成员变量的初始化顺序这样的问题都被问得一头雾水，那最终结果也就可想而知了。 技术深度够吗？我们现在做项目时都会大量使用框架，这能使我们的开发效率和质量都得到提升和保障，但同时也降低了对程序员开发技能的要求。因此一般会询问面试者下面的问题，来考察对使用框架的掌握程度： 请你描述一下，在这个项目中，从一个HTTP请求发起，到最终的Response返回，它在你的系统和框架内部是如何流转的？ 这个问题往往能够判断出面试者对于相关技术的掌握深度。较初级的开发人员描述的层级往往比较浅。比如，使用Spring MVC框架的，只能说到实现一个Controller继承BaseCommandController（甚至很多开发人员只知道继承了一个公司内部框架的基类），至于再往下Spring框架是如何进行内部流转的，就再也说不清楚了；而更资深的开发人员，往往能够说出框架内部的实现机制，以及如何调用和处理的。在面试者描述的过程中，会被穿插询问一些比较有深度的问题，比如，框架中某个类这样设计是哪一种设计模式的体现，采用这样的设计有什么好处，等等。这比让面试者默写一个设计模式代码要有效，也自然得多。除了技术层面上的考察之外，对于资深开发人员，还需要考察他们的设计能力。说到软件设计，大部分面试者都能熟练地背出面向对象的3个基本特性：继承、封装、多态，也能把它们的概念描述清楚。但一般被问及下面的这个问题来考察面向对象设计能力： 请用一段程序代码描述我们所在的这间房间。 至少有一半都很难准确使用Interface和Class来给房间建模，也有一些人会将最基本的代码语法或关键字写错。 适合所在企业文化让我们看看GitHub负责人的一段话： 我们很严肃地看待我们自己关于招聘流程的哲学。我们希望每一个GitHub员工都了解他们所要面对的环境，并保证他们是能够很好适应的。这包括我们所创造的文化、哲学、计划、错误甚至是晚餐。比起他们的技能是否满足要求，我们更看重他们的潜力，以及是否能够适应我们的企业文化。 虚拟任务 写一个小程序：将一个以特定格式（如CSV）存储的文本文件转换为XML格式，并存储为另一个文件。 开发基于Spring Boot及其他第三方库所提供的API来开发出基于REST的服务；然后，在前端利用AngularJS将应用分为几个模块（UserManager，ResourceManger，FeedbackManager）分别开发；最后，通过$http调用后端服务来进行业务处理和数据交互。在整个开发过程中，仍需要去解决一些问题： * 前后端分离之后，如何进行Session的管理 * 如何实现安全的跨域请求。 * 在Spring Boot中如何整合MyBatis框架。 * 如何利用Spring Security来构建安全的REST服务。 * 如何利用云服务实现图片的上传与处理。 重构——系统改善之道* 引入构建工具 对于后端Java程序来说，最常使用的便是Groovy，也可尝试使用Gradle。而对于前端来说，Grunt或更新的Gulp都是不错的选择。 编程习惯如果应聘者先写单元测试用例，再写解决问题的函数，那么面试官定会刮目相看，因为能做到测试在前、开发在后的程序员实在是太稀缺了，他会毫不犹豫地抛出橄榄枝。 调试功底：熟练地设置断点、单步跟踪、查看内存、分析调用栈。","raw":null,"content":null,"categories":[{"name":"memo","slug":"memo","permalink":"https://e99net.github.io/categories/memo/"}],"tags":[{"name":"Water","slug":"Water","permalink":"https://e99net.github.io/tags/Water/"}]},{"title":"Mysql常用查询语句荟萃","slug":"mysql","date":"2018-04-13T04:50:18.476Z","updated":"2018-09-23T05:12:14.752Z","comments":false,"path":"2018/04/13/mysql/","link":"","permalink":"https://e99net.github.io/2018/04/13/mysql/","excerpt":"Mysql查询某个数据库的存储容量","keywords":null,"text":"Mysql查询某个数据库的存储容量 USE information_schema;SELECT CONCAT(ROUND(SUM(DATA_LENGTH/1024/1024/1024),2),’GB’) AS DATA FROM TABLES WHERE table_schema=’[数据库名]’; Mysql 设置Profiler功能 SET profiling = 1; Mysql执行操作 SELECT/EXPLAIN … Mysql查询各个阶段性能 SHOW PROFILES;SHOW PROFILE ALL FOR QUERY 1;","raw":null,"content":null,"categories":[{"name":"memo","slug":"memo","permalink":"https://e99net.github.io/categories/memo/"}],"tags":[{"name":"Database","slug":"Database","permalink":"https://e99net.github.io/tags/Database/"}]},{"title":"Win7系统全部浏览器被篡改主页成123.sogou.com等问题的一点思路","slug":"ProblemofHomePage","date":"2018-04-13T04:50:18.461Z","updated":"2018-05-09T03:02:39.297Z","comments":false,"path":"2018/04/13/ProblemofHomePage/","link":"","permalink":"https://e99net.github.io/2018/04/13/ProblemofHomePage/","excerpt":"本人win7系统，曾经有两次中招，系统中的Google Chrome、Firefox、IE三个浏览器主页全部被篡改成123.sogou.com。第一次以为下载的软件有毒，运行之后马上导致浏览器首页被篡改，查注册表、改快捷方式……自认为该试的方法都试了，期间还用360安全卫士查杀过，但是依然没有解决。此时觉得病毒应该写到dll文件里面去了，那我没辙了，只能重装操作系统。一直到现在，最近几天卸载360安全卫士之后，没多久，浏览器主页又被全部篡改了，好像和上次的主页一样，这时想到：“上一次好像也是卸载360安全卫士之后被篡改的主页”，所以初步分析应该是360安全卫士搞的鬼，TMD，临死前还要放一炮！！！其实，我卸载360安全卫士只是觉得没有必要再用它了，并无瞧不起它的意思，嘿嘿。为什么它要这么对待我！！！好了，说到这其实问题还并没有解决。即然查注册表、改快捷方式都没用，而我又不想重装系统，那只能采用网上的黑科技，在所有浏览器可执行文件文件名后加一个空格。这样凑合了好几天，实在是不舒服了。昨天晚上临睡前想起这个问题，我实在是不甘心，就在手机的浏览器上查解决办法。中国的网友们真是无所不知，眼前一亮，突然发现了一些好办法，心想明天试一下。今天，我按照如下方法操作了一遍，竟然莫名其妙的就好了，好开心！虽然和昨天网上看到的方法有些许出入，但我认为本质是一样的。特记录于此。","keywords":null,"text":"本人win7系统，曾经有两次中招，系统中的Google Chrome、Firefox、IE三个浏览器主页全部被篡改成123.sogou.com。第一次以为下载的软件有毒，运行之后马上导致浏览器首页被篡改，查注册表、改快捷方式……自认为该试的方法都试了，期间还用360安全卫士查杀过，但是依然没有解决。此时觉得病毒应该写到dll文件里面去了，那我没辙了，只能重装操作系统。一直到现在，最近几天卸载360安全卫士之后，没多久，浏览器主页又被全部篡改了，好像和上次的主页一样，这时想到：“上一次好像也是卸载360安全卫士之后被篡改的主页”，所以初步分析应该是360安全卫士搞的鬼，TMD，临死前还要放一炮！！！其实，我卸载360安全卫士只是觉得没有必要再用它了，并无瞧不起它的意思，嘿嘿。为什么它要这么对待我！！！好了，说到这其实问题还并没有解决。即然查注册表、改快捷方式都没用，而我又不想重装系统，那只能采用网上的黑科技，在所有浏览器可执行文件文件名后加一个空格。这样凑合了好几天，实在是不舒服了。昨天晚上临睡前想起这个问题，我实在是不甘心，就在手机的浏览器上查解决办法。中国的网友们真是无所不知，眼前一亮，突然发现了一些好办法，心想明天试一下。今天，我按照如下方法操作了一遍，竟然莫名其妙的就好了，好开心！虽然和昨天网上看到的方法有些许出入，但我认为本质是一样的。特记录于此。 Win7系统全部浏览器的主页被篡改成123.sogou.com问题的一个解决方法 取消“隐藏系统文件”（1）打开“计算机”－点击菜单“组织”－点击“文件夹和搜索选项”－点击“查看”－点选“隐藏受保护的系统文件”（把前面的勾去掉）－弹出提示选择“是”（2）点选下面“显示隐藏的文件、文件夹和驱动器” 找到“C:\\Users\\用户名\\AppData\\Roaming”路径，删除此路径下所有和“360”有关的文件夹！！！ 检验修正结果 网文链接：解决“123.sogou.com/?*”浏览器起始页恶意跳转 我表示以后再也不会装360安全卫士了！！！","raw":null,"content":null,"categories":[{"name":"memo","slug":"memo","permalink":"https://e99net.github.io/categories/memo/"}],"tags":[{"name":"Water","slug":"Water","permalink":"https://e99net.github.io/tags/Water/"}]},{"title":"《演化计算》_读书笔记","slug":"NoteofBook3","date":"2018-04-13T04:50:18.429Z","updated":"2018-05-09T03:02:15.358Z","comments":false,"path":"2018/04/13/NoteofBook3/","link":"","permalink":"https://e99net.github.io/2018/04/13/NoteofBook3/","excerpt":"目前, 演化计算与神经网络、模糊系统一起已形成一个新的研究方向———计算智能(computational intelligence)。人工智能已从传统的基于符号处理的符号主义向以神经网络为代表的连接主义和以演化计算为代表的演化主义方向发展。 演化算法从一个群体即多个点而不是从一个点开始搜索, 这是它能以较大的概找到整体最优解的主要原因之一。","keywords":null,"text":"目前, 演化计算与神经网络、模糊系统一起已形成一个新的研究方向———计算智能(computational intelligence)。人工智能已从传统的基于符号处理的符号主义向以神经网络为代表的连接主义和以演化计算为代表的演化主义方向发展。 演化算法从一个群体即多个点而不是从一个点开始搜索, 这是它能以较大的概找到整体最优解的主要原因之一。","raw":null,"content":null,"categories":[{"name":"memo","slug":"memo","permalink":"https://e99net.github.io/categories/memo/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"https://e99net.github.io/tags/Machine-Learning/"}]},{"title":"《统计学习方法(李航 著)》_读书笔记","slug":"NoteofBook1","date":"2018-04-13T04:50:18.414Z","updated":"2018-05-09T03:01:42.588Z","comments":false,"path":"2018/04/13/NoteofBook1/","link":"","permalink":"https://e99net.github.io/2018/04/13/NoteofBook1/","excerpt":"1.3统计学习三要素本书中称由决策函数表示的模型为非概率模型，由条件概率表示的模型为概率模型。损失函数度量模型一次预测的好坏，风险函数度量平均意义下模型预测的好坏。","keywords":null,"text":"1.3统计学习三要素本书中称由决策函数表示的模型为非概率模型，由条件概率表示的模型为概率模型。损失函数度量模型一次预测的好坏，风险函数度量平均意义下模型预测的好坏。监督学习的两个基本策略：经验风险最小化和结构风险最小化。当样本容量足够大时，经验风险最小化(empirical risk minimization, ERM)能保证有很好的学习效果，在现实中被广泛使用。但是，当样本容量很小时，经验风险最小化学习的效果就未必很好，会产生“过拟合(over-fitting)”现象。结构风险最小化(structural risk minimization, SRM)是为了防止过拟合而提出来的策略。 2.3.3感知机学习算法的对偶形式实例点更新次数越多，意味着它距离分离超平面越近，也就越难正确分类。","raw":null,"content":null,"categories":[{"name":"memo","slug":"memo","permalink":"https://e99net.github.io/categories/memo/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"https://e99net.github.io/tags/Machine-Learning/"}]},{"title":"《模式识别与机器学习 中文版(马春鹏 译)》_读书笔记","slug":"NoteofBook2","date":"2018-04-13T04:50:18.414Z","updated":"2018-05-09T03:02:01.864Z","comments":false,"path":"2018/04/13/NoteofBook2/","link":"","permalink":"https://e99net.github.io/2018/04/13/NoteofBook2/","excerpt":"","keywords":null,"text":"","raw":null,"content":null,"categories":[{"name":"memo","slug":"memo","permalink":"https://e99net.github.io/categories/memo/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"https://e99net.github.io/tags/Machine-Learning/"}]},{"title":"Ubuntu的奇巧淫技","slug":"FunofUbuntu","date":"2018-04-13T04:50:18.398Z","updated":"2019-01-05T13:10:48.090Z","comments":false,"path":"2018/04/13/FunofUbuntu/","link":"","permalink":"https://e99net.github.io/2018/04/13/FunofUbuntu/","excerpt":"安装小工具 sudo apt install fortunesudo apt install fortune-zhsudo apt install cowsaysudo apt install lolcat","keywords":null,"text":"安装小工具 sudo apt install fortunesudo apt install fortune-zhsudo apt install cowsaysudo apt install lolcat 小牛讲道理 for i in {1..5};do echo fortune|cowsay;done 加颜色 for i in {1..5};do echo fortune|cowsay|lolcat;done","raw":null,"content":null,"categories":[{"name":"memo","slug":"memo","permalink":"https://e99net.github.io/categories/memo/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://e99net.github.io/tags/Linux/"}]},{"title":"Linux系统IO模式","slug":"IO","date":"2018-04-13T04:50:18.398Z","updated":"2018-06-21T14:24:34.932Z","comments":false,"path":"2018/04/13/IO/","link":"","permalink":"https://e99net.github.io/2018/04/13/IO/","excerpt":"Linux系统有以下五种网络模式的方案","keywords":null,"text":"Linux系统有以下五种网络模式的方案 阻塞I/O（blocking IO） 非阻塞I/O（nonblocking IO） I/O多路复用（IO multiplexing） 信号驱动I/O（signal driven IO） 异步I/O（asynchronous IO） 注：signal driven IO在实际中并不常用","raw":null,"content":null,"categories":[{"name":"memo","slug":"memo","permalink":"https://e99net.github.io/categories/memo/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://e99net.github.io/tags/Linux/"}]},{"title":"Markdown语法","slug":"KnowledOfMarkdown","date":"2018-04-13T04:50:18.398Z","updated":"2018-05-09T03:01:16.031Z","comments":false,"path":"2018/04/13/KnowledOfMarkdown/","link":"","permalink":"https://e99net.github.io/2018/04/13/KnowledOfMarkdown/","excerpt":"Markdown原生语法 中划线。语法如下： 要划除的行内内容","keywords":null,"text":"Markdown原生语法 中划线。语法如下： 要划除的行内内容 Markdown中的转义字符为\\，可以转义的有： \\ 反斜杠` 反引号* 星号_ 下划线{} 大括号[] 中括号() 小括号# 井号+ 加号- 减号. 英文句号! 感叹号 使用Markdown时，如何为文字加下划线 Markdown并无下划线的原生语法，因为会和链接的默认样式产生混淆。这里可以使用行内样式HTML使其产生下划线效果，如下： Underlined Text 使用html的span标签、设置行内CSS的border-bottom属性 来添加下划线。这种方式自定义程度最高。语法如下： 所添加的需要加下划线的行内文字 用数学公式： #上划线$\\overline{X}$#下划线$\\underline{X}$","raw":null,"content":null,"categories":[{"name":"memo","slug":"memo","permalink":"https://e99net.github.io/categories/memo/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://e99net.github.io/tags/Markdown/"}]},{"title":"如何知道自己是什么级别的程序员","slug":"level","date":"2018-04-13T04:50:18.398Z","updated":"2018-05-09T03:01:25.159Z","comments":false,"path":"2018/04/13/level/","link":"","permalink":"https://e99net.github.io/2018/04/13/level/","excerpt":"你们按照下面自行对号入座吧。","keywords":null,"text":"你们按照下面自行对号入座吧。 level 1: 被人带着做事的level 2: 不需要人带就能做事的level 3: 比level 2做得快的level 4: 可以带人的level 5: 可以带三个人的level 6: 可以带七个人的level 7: 可以带很多人的level 8: 带带人的人的level 9: 带level 8的","raw":null,"content":null,"categories":[{"name":"memo","slug":"memo","permalink":"https://e99net.github.io/categories/memo/"}],"tags":[{"name":"Water","slug":"Water","permalink":"https://e99net.github.io/tags/Water/"}]},{"title":"函数式编程初探","slug":"FuncProgExp","date":"2018-04-13T04:50:18.367Z","updated":"2018-05-09T03:00:42.224Z","comments":false,"path":"2018/04/13/FuncProgExp/","link":"","permalink":"https://e99net.github.io/2018/04/13/FuncProgExp/","excerpt":"函数式编程的应用虽然在很长时间内都处于不温不火的状态，但他们的用途却非常广泛，常见的领域有人工智能、定理证明、无线通信、金融数据分析系统等。","keywords":null,"text":"函数式编程的应用虽然在很长时间内都处于不温不火的状态，但他们的用途却非常广泛，常见的领域有人工智能、定理证明、无线通信、金融数据分析系统等。 面向对象语言有很大的优势，各种设计模式在商业开发的路上也发展得非常成熟，而函数式编程的优势在于程序的严谨与可靠性，程序正确性的证明与测试时的简易型，另外，还有开发周期相对短，编写并发程序十分简洁且运行稳定。 Haskell实现了很多软件中的精品，如窗口管理器XMonad、Perl6的Haskell实现Pugs以及高性能的网页框架Yesod、Snap等。 map-reduce框架的灵感就来自于函数式编程语言，Erlang的分布式编程模型也利用了很多诸如不可变数据、高阶函数等函数式编程的特性。","raw":null,"content":null,"categories":[{"name":"memo","slug":"memo","permalink":"https://e99net.github.io/categories/memo/"}],"tags":[{"name":"Haskell","slug":"Haskell","permalink":"https://e99net.github.io/tags/Haskell/"}]},{"title":"Latex中设置字体大小","slug":"FontsizeofLatex","date":"2018-04-13T04:50:18.367Z","updated":"2019-01-07T13:17:14.034Z","comments":false,"path":"2018/04/13/FontsizeofLatex/","link":"","permalink":"https://e99net.github.io/2018/04/13/FontsizeofLatex/","excerpt":"Latex设置字体大小的命令由小到大依次为","keywords":null,"text":"Latex设置字体大小的命令由小到大依次为 \\tiny \\scriptsize \\footnotesize \\small \\normalsize(注：此为默认的正文字体大小) \\large \\Large \\LARGE \\huge \\Huge Latex打勾和叉 首先在导言区调用bbding包 \\usepackage{bbding} 然后使用如下命令，5种命令分别代表不同样式的勾和叉 \\Checkmark %标准的勾\\XSolidBrush\\XSolid %标准的叉\\CheckmarkBold\\XSolidBold","raw":null,"content":null,"categories":[{"name":"memo","slug":"memo","permalink":"https://e99net.github.io/categories/memo/"}],"tags":[{"name":"Latex","slug":"Latex","permalink":"https://e99net.github.io/tags/Latex/"}]},{"title":"语录","slug":"Quotations","date":"2018-04-13T04:50:18.351Z","updated":"2018-09-23T05:24:15.963Z","comments":false,"path":"2018/04/13/Quotations/","link":"","permalink":"https://e99net.github.io/2018/04/13/Quotations/","excerpt":"","keywords":null,"text":"人的差别在于业余时间。——爱因斯坦 Good designers copy. Great designers steal.(能工摹形，巧匠窃意。) 简单性和模块化是软件工程的基石，分布式和容错性是互联网的生命。——WWW的发明人蒂姆·伯纳斯·李在谈到设计原理时说 运动，是身体的知己；营养，是健康的知音。 骏马前头无沟壑，怂人面前全是坎。 如果想飞得高，就该把地平线忘掉。 广厦万间，夜眠七尺；良田千顷，日仅三餐。","raw":null,"content":null,"categories":[{"name":"memo","slug":"memo","permalink":"https://e99net.github.io/categories/memo/"}],"tags":[{"name":"Water","slug":"Water","permalink":"https://e99net.github.io/tags/Water/"}]},{"title":"谷歌浏览器的黑科技","slug":"BlackTechOfChrome","date":"2018-04-13T04:50:18.320Z","updated":"2018-05-09T02:58:50.083Z","comments":false,"path":"2018/04/13/BlackTechOfChrome/","link":"","permalink":"https://e99net.github.io/2018/04/13/BlackTechOfChrome/","excerpt":"关于Windows操作系统下MacType无法渲染新版本Google Chrome的问题在Google Chrome的快捷方式中添加“–disable-directwrite-for-ui”启动参数，注意参数前有空格","keywords":null,"text":"关于Windows操作系统下MacType无法渲染新版本Google Chrome的问题在Google Chrome的快捷方式中添加“–disable-directwrite-for-ui”启动参数，注意参数前有空格","raw":null,"content":null,"categories":[{"name":"memo","slug":"memo","permalink":"https://e99net.github.io/categories/memo/"}],"tags":[{"name":"Water","slug":"Water","permalink":"https://e99net.github.io/tags/Water/"}]},{"title":"一个无法在Chrome中更改默认搜索引擎的问题","slug":"AProbOfDefSearchEngine","date":"2018-04-13T04:50:18.320Z","updated":"2018-05-09T03:00:08.303Z","comments":false,"path":"2018/04/13/AProbOfDefSearchEngine/","link":"","permalink":"https://e99net.github.io/2018/04/13/AProbOfDefSearchEngine/","excerpt":"在大多数情况下会看到一个未知的网站被分配为默认引擎，并且无卸载按钮可以更改。","keywords":null,"text":"在大多数情况下会看到一个未知的网站被分配为默认引擎，并且无卸载按钮可以更改。 以下是解除Chrome中的设置，最后更改浏览器中默认搜索的方法。按照步骤：1、以管理员身份运行cmd.exe2、在cmd窗口中执行以下三条命令 RD /S /Q “%WinDir%\\System32\\GroupPolicyUsers”RD /S /Q “%WinDir%\\System32\\GroupPolicy”gpupdate /force 直到出现两个通知。这样就可以关闭命令提示符窗口，更改Chrome中的默认搜索引擎了。","raw":null,"content":null,"categories":[{"name":"memo","slug":"memo","permalink":"https://e99net.github.io/categories/memo/"}],"tags":[{"name":"Water","slug":"Water","permalink":"https://e99net.github.io/tags/Water/"}]},{"title":"MATLAB 神经网络技术","slug":"Matlab","date":"2018-03-28T09:07:15.401Z","updated":"2019-01-05T12:38:07.923Z","comments":false,"path":"2018/03/28/Matlab/","link":"","permalink":"https://e99net.github.io/2018/03/28/Matlab/","excerpt":"前戏加载MATLAB自带的噪声信号进行绘图。1234&gt;&gt; clear all&gt;&gt; close all&gt;&gt; load noisdopp&gt;&gt; plot(noisdopp)","keywords":null,"text":"前戏加载MATLAB自带的噪声信号进行绘图。1234&gt;&gt; clear all&gt;&gt; close all&gt;&gt; load noisdopp&gt;&gt; plot(noisdopp) 绘制三元函数s=x²+y²+z²的可视化图形。12345678&gt;&gt; clear all;&gt;&gt; x=linspace(-2,2,40);&gt;&gt; y=x;&gt;&gt; z=x;&gt;&gt; [X,Y,Z]=meshgrid(x,y,z);&gt;&gt; s=X.^2+Y.^2+Z.^2;&gt;&gt; slice(X,Y,Z,s,[-1,0,1],[-1,0,1],[-1,0,1]);&gt;&gt; colorbar 在MATLAB的命令窗口中输入help nnet，即可得到神经网络工具箱的有关版本信息及函数列表。 感知器神经网络单层感知器网络不能模拟异或问题，这里用二层感知器神经网络模拟异或函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&gt;&gt; clear all;%初始化随机感知器层&gt;&gt; pr1=[0 1;0 1]; %设置随机感知器层输入问题每个元素的值域&gt;&gt; net1=newp(pr1,3);%定义随机感知器层%指定随机感知器层权值初始化函数为随机函数&gt;&gt; net1.inputWeights&#123;1&#125;.initFcn=&apos;rands&apos;;%指定随机感知器层阈值初始化函数为随机函数&gt;&gt; net1.biases&#123;1&#125;.initFcn=&apos;rands&apos;;&gt;&gt; net1=init(net1);%初始化随机感知器层&gt;&gt; iw1=net1.iw&#123;1&#125;;%随机感知器层的权值向量&gt;&gt; b1=net1.b&#123;1&#125;;%随机感知器层的阈值向量%随机感知器层仿真&gt;&gt; p1=[0 0;0 1;1 0;1 1]&apos;;%随机感知器输入向量(训练样本)&gt;&gt; [a1,pf]=sim(net1,p1);%随机感知器层仿真%初始化第二感知器层&gt;&gt; pr2=[0 1;0 1;0 1];%设置第二感知器层输入向量每个元素的值域&gt;&gt; net2=newp(pr2,1);%定义第二感知器层%训练第二感知器层&gt;&gt; net2.trainParam.epochs=10;&gt;&gt; net2.trainParam.show=1;&gt;&gt; p2=ones(3,4);%初始化第二感知器层的输入向量&gt;&gt; p2=p2.*a1;%随机感知器层的仿真输出结果作为第二感知器层的输入向量&gt;&gt; t2=[0 1 1 0];%第二感知器层的目标向量%训练第二感知器层&gt;&gt; [net2,tr2]=train(net2,p2,t2);&gt;&gt; disp(&apos;输出训练过程经过的每一步长为：&apos;)输出训练过程经过的每一步长为：&gt;&gt; epoch2=tr2.epoch %输出训练过程经过的每一步长epoch2 = 0 1 2 3 4 5 6 7 8 9 10&gt;&gt; disp(&apos;输出每一步训练结果的误差为：&apos;)输出每一步训练结果的误差为：&gt;&gt; perf2=tr2.perf %输出每一步训练结果的误差perf2 = Columns 1 through 9 0.5000 0.5000 0.5000 0.2500 0.2500 0.2500 0.2500 0.2500 0.2500 Columns 10 through 11 0.2500 0.2500&gt;&gt; disp(&apos;第二感知器层的权值向量为：&apos;)第二感知器层的权值向量为：&gt;&gt; iw2=net2.iw&#123;1&#125;iw2 = -1 -1 3&gt;&gt; disp(&apos;第二感知器层的阈值向量为：&apos;)第二感知器层的阈值向量为：&gt;&gt; b2=net2.b&#123;1&#125;b2 = -1%存储训练后的网络&gt;&gt; save net36 net1 net2%下面的代码实现二层感知器网络的仿真&gt;&gt; clear all; %清除工作空间中的变量&gt;&gt; load net36 net1 net2 %加载训练后的网络%随机感知器仿真&gt;&gt; p1=[0 0;0 1;1 0;1 1]&apos;; %随机感知器层输入向量&gt;&gt; a1=sim(net1,p1); %随机感知器层仿真结果%输出感知器层仿真，并输出仿真结果&gt;&gt; p2=ones(3,4);%初始化第二感知器层的输入向量&gt;&gt; p2=p2.*a1;%随机感知器层的仿真输出结果作为第二感知器层的输入向量&gt;&gt; a2=sim(net2,p2)%运行程序，输出如下a2 = 0 1 0 0%由以上结果可看出所设计的网络可正确模拟“异或”函数的功能 设计一个感知器神经网络，完成下列分类，已知：p1=(0.5 -1)T，t1=0; p2=(1 0.5)T,t2=1;p3=(-1 0.5)T,t3=1;p4=(-1 -1),t4=0。此单层感知器神经网络的结构：1个输入向量，包括2个元素、1个神经元，神经元的传输函数为hardlim。123456789101112131415&gt;&gt; clear all;&gt;&gt; pr=[-1 1;-1 1];&gt;&gt; net=newp(pr,1);&gt;&gt; p=[0.5 -1;1 0.5;-1 0.5;-1 -1]&apos;;&gt;&gt; t=[0 1 1 0];&gt;&gt; [net,tr]=train(net,p,t);&gt;&gt; a = sim(net,p)a = 0 1 1 0&gt;&gt; v=[-2 2 -2 2];&gt;&gt; plotpv(p,a,v);&gt;&gt; plotpc(net.iw&#123;1&#125;,net.b&#123;1&#125;);","raw":null,"content":null,"categories":[{"name":"memo","slug":"memo","permalink":"https://e99net.github.io/categories/memo/"}],"tags":[{"name":"Matlab","slug":"Matlab","permalink":"https://e99net.github.io/tags/Matlab/"}]}]}