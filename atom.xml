<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>99°</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://e99net.github.io/"/>
  <updated>2019-10-06T11:54:02.534Z</updated>
  <id>https://e99net.github.io/</id>
  
  <author>
    <name>sqLiu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>洛谷的刷题日常之P1967</title>
    <link href="https://e99net.github.io/2019/10/06/luogu_P1967/"/>
    <id>https://e99net.github.io/2019/10/06/luogu_P1967/</id>
    <published>2019-10-06T11:02:59.655Z</published>
    <updated>2019-10-06T11:54:02.534Z</updated>
    
    <content type="html"><![CDATA[<h4 id="货车运输"><a href="#货车运输" class="headerlink" title="货车运输"></a>货车运输</h4><p>这是一道比较综合的题，非常的niubility（我不会做的题都niubility，QWQ），用到的知识包括图论、倍增、贪心、LCA、生成树、并查集。</p><ul><li>描述：</li></ul><p>A国有n座城市，编号从1到n，城市之间有m条双向道路。每一条道路对车辆都有重量限制，简称限重。现在有q辆货车在运输货物， 司机们想知道每辆车在不超过车辆限重的情况下，最多能运多重的货物。</p><a id="more"></a><ul><li>输入：</li></ul><p>第一行有两个用空格隔开的整数n和m，表示A国有n座城市和m条道路。<br>接下来的m行，每行有3个整数x,y,z，每两个整数之间用一个空格隔开，表示从x号城市到y号城市有一条限重为z的道路。<br>注意：x不等于 y，两座城市之间可能有多条道路。</p><p>接下来一行有一个整数q，表示有q辆货车需要运货。</p><p>接下来的q行，每行有两个整数x、y，用一个空格隔开，表示一辆货车需要从x城市运输货物到y城市。<br>注意：x不等于y。</p><ul><li>输出：</li></ul><p>共有q行，每行一个整数，表示对于每一辆货车，它的最大载重是多少。如果货车不能到达目的地，输出-1。</p><ul><li>输入样例：</li></ul><p>4 3<br>1 2 4<br>2 3 3<br>3 1 1<br>3<br>1 3<br>1 4<br>1 3</p><ul><li>输出样例：</li></ul><p>3<br>-1<br>3</p><ul><li><p>解题思路：</p><ul><li>贪心：因为要使得货车运的货物尽可能重，所以权值较小的边不会被走过。</li><li>图论：根据给出的数据建原始图，然后根据上一步的贪心策略建新图，构造最大生成树。</li><li>生成树：构造最大生成树可以使用Kruskal算法。</li><li>并查集：Kruskal算法可以用并查集维护节点的连通情况。</li><li>LCA：在最大生成树上求最近公共祖先，得到两个节点之间最小边权的最大值，即题中的最大载重。</li><li>倍增：树上倍增法求LCA。</li></ul></li><li><p>参考代码：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define INF 0x3f3f3f3f</span><br><span class="line"></span><br><span class="line">struct road &#123;</span><br><span class="line">    int x,y,z;</span><br><span class="line">&#125;roads[50010];//原始图</span><br><span class="line"></span><br><span class="line">struct edge &#123;</span><br><span class="line">    int to,next,w;</span><br><span class="line">&#125;edges[50010];//存储最大生成树的新图</span><br><span class="line"></span><br><span class="line">//fa数组表示并查集中的父节点，f数组表示树上的父节点，w数组表示最大载重 </span><br><span class="line">int x,y,cnt,head[10010],fa[10010],f[10010][21],deep[10010],w[10010][21],n,m,q;</span><br><span class="line">bool vis[10010];</span><br><span class="line"></span><br><span class="line">//自定义排序规则，边权大的在前面</span><br><span class="line">bool cmp(road x,road y) &#123;</span><br><span class="line">    return x.z&gt;y.z;</span><br><span class="line">&#125;</span><br><span class="line">//前向星存新图</span><br><span class="line">void addroad(int start,int end,int w) &#123;</span><br><span class="line">    edges[++cnt].next=head[start];</span><br><span class="line">    edges[cnt].to=end;</span><br><span class="line">    edges[cnt].w=w;</span><br><span class="line">    head[start]=cnt;</span><br><span class="line">&#125;</span><br><span class="line">//并查集的查找操作</span><br><span class="line">int Find(int x) &#123;</span><br><span class="line">    if(x!=fa[x]) fa[x]=Find(fa[x]);</span><br><span class="line">    return fa[x];</span><br><span class="line">&#125;</span><br><span class="line">//Kruskal算法</span><br><span class="line">void kruskal() &#123;</span><br><span class="line">    sort(roads+1,roads+m+1,cmp);</span><br><span class="line">    for(int i=1;i&lt;=n;i++) fa[i]=i;//并查集的初始化操作</span><br><span class="line">    for(int i=1;i&lt;=m;i++) &#123;</span><br><span class="line">        //并查集的合并操作</span><br><span class="line">        int a=Find(roads[i].x);</span><br><span class="line">        int b=Find(roads[i].y);</span><br><span class="line">        if(a!=b) &#123;</span><br><span class="line">            fa[a]=b;</span><br><span class="line">            //无向图，双向边</span><br><span class="line">            addroad(roads[i].x,roads[i].y,roads[i].z);</span><br><span class="line">            addroad(roads[i].y,roads[i].x,roads[i].z);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//预处理：从根节点进行搜索，求节点深度</span><br><span class="line">void dfs(int node) &#123;</span><br><span class="line">    vis[node]=true;</span><br><span class="line">    for(int i=head[node];i;i=edges[i].next) &#123;//前向星遍历</span><br><span class="line">        int to=edges[i].to;</span><br><span class="line">        if(vis[to]) continue;</span><br><span class="line">        deep[to]=deep[node]+1;//计算深度</span><br><span class="line">        f[to][0]=node;//存父节点</span><br><span class="line">        w[to][0]=edges[i].w;//存节点到父节点的权值</span><br><span class="line">        dfs(to);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//树上倍增法优化求解LCA问题</span><br><span class="line">int lca(int x,int y) &#123;</span><br><span class="line">    int a=Find(x);</span><br><span class="line">    int b=Find(y);</span><br><span class="line">    if(a!=b) return -1;//不连通输出-1</span><br><span class="line">    int ans=INF;</span><br><span class="line">    if(deep[x]&gt;deep[y]) swap(x,y);//始终使得y节点更深</span><br><span class="line">    //将y节点提到与x节点相同的深度</span><br><span class="line">    for(int i=20;i&gt;=0;i--) &#123;</span><br><span class="line">        if(deep[f[y][i]]&gt;=deep[x]) &#123;</span><br><span class="line">            ans=min(ans,w[y][i]);//更新最大载重（最小边权）</span><br><span class="line">            y=f[y][i];//修改y的位置</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(x==y) return ans;//如果位置已经相等，直接返回答案</span><br><span class="line">    //寻找公共祖先</span><br><span class="line">    for(int i=20;i&gt;=0;i--) &#123;</span><br><span class="line">        if(f[x][i]!=f[y][i]) &#123;</span><br><span class="line">            ans=min(ans,min(w[x][i],w[y][i]));//更新最大载重（最小边权）</span><br><span class="line">            x=f[x][i];//修改x的位置</span><br><span class="line">            y=f[y][i];//修改y的位置</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans=min(ans,min(w[x][0],w[y][0]));//更新x,y到公共祖先的最大载重，fa[x][0]、fa[y][0]即为公共祖先 </span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">    for(int i=1;i&lt;=m;i++) &#123;//存原始图</span><br><span class="line">        scanf(&quot;%d%d%d&quot;,&amp;roads[i].x,&amp;roads[i].y,&amp;roads[i].z);</span><br><span class="line">    &#125;</span><br><span class="line">    kruskal();</span><br><span class="line">    for(int i=1;i&lt;=n;i++) &#123;//预处理</span><br><span class="line">        if(!vis[i]) &#123;</span><br><span class="line">            deep[i]=1;</span><br><span class="line">            dfs(i);</span><br><span class="line">            f[i][0]=i;</span><br><span class="line">            w[i][0]=INF;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //LCA初始化</span><br><span class="line">    for(int i=1;i&lt;=20;i++) &#123;</span><br><span class="line">        for(int j=1;j&lt;=n;j++) &#123;</span><br><span class="line">            f[j][i]=f[f[j][i-1]][i-1];</span><br><span class="line">            w[j][i]=min(w[j][i-1],w[f[j][i-1]][i-1]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;q);</span><br><span class="line">    for(int i=1;i&lt;=q;i++) &#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;x,&amp;y);</span><br><span class="line">        printf(&quot;%d\n&quot;,lca(x,y));//O(logn)复杂度回答询问</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;货车运输&quot;&gt;&lt;a href=&quot;#货车运输&quot; class=&quot;headerlink&quot; title=&quot;货车运输&quot;&gt;&lt;/a&gt;货车运输&lt;/h4&gt;&lt;p&gt;这是一道比较综合的题，非常的niubility（我不会做的题都niubility，QWQ），用到的知识包括图论、倍增、贪心、LCA、生成树、并查集。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;描述：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A国有n座城市，编号从1到n，城市之间有m条双向道路。每一条道路对车辆都有重量限制，简称限重。现在有q辆货车在运输货物， 司机们想知道每辆车在不超过车辆限重的情况下，最多能运多重的货物。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://e99net.github.io/categories/Algorithm/"/>
    
    
      <category term="Graph theory" scheme="https://e99net.github.io/tags/Graph-theory/"/>
    
      <category term="LCA" scheme="https://e99net.github.io/tags/LCA/"/>
    
      <category term="Greedy" scheme="https://e99net.github.io/tags/Greedy/"/>
    
      <category term="Union-Find Set" scheme="https://e99net.github.io/tags/Union-Find-Set/"/>
    
      <category term="Spanning tree" scheme="https://e99net.github.io/tags/Spanning-tree/"/>
    
      <category term="Doubling" scheme="https://e99net.github.io/tags/Doubling/"/>
    
  </entry>
  
  <entry>
    <title>洛谷的刷题日常之P1147</title>
    <link href="https://e99net.github.io/2019/10/05/luogu_P1147/"/>
    <id>https://e99net.github.io/2019/10/05/luogu_P1147/</id>
    <published>2019-10-04T16:15:38.897Z</published>
    <updated>2019-10-04T16:23:29.233Z</updated>
    
    <content type="html"><![CDATA[<h4 id="连续自然数和"><a href="#连续自然数和" class="headerlink" title="连续自然数和"></a>连续自然数和</h4><ul><li>描述：</li></ul><p>对一个给定的自然数$M$，求出所有的连续的自然数段，这些连续的自然数段中的全部数之和为$M$。<br>例子：1998+1999+2000+2001+2002 = 10000，所以从1998到2002的一个自然数段为$M=10000$的一个解。</p><a id="more"></a><ul><li>输入：</li></ul><p>包含一个整数的单独一行给出M的值（$10 \le M \le 2000000$）。</p><ul><li>输出：</li></ul><p>每行两个自然数，给出一个满足条件的连续自然数段中的第一个数和最后一个数，两数之间用一个空格隔开，所有输出行的第一个按从小到大的升序排列，对于给定的输入数据，保证至少有一个解。</p><ul><li>输入样例：</li></ul><p>10000</p><ul><li>输出样例：</li></ul><p>18 142<br>297 328<br>388 412<br>1998 2002</p><ul><li><p>解题思路：前缀和+二分</p></li><li><p>参考代码:</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define ll long long</span><br><span class="line">ll sum[2000010];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    ll m;</span><br><span class="line">    scanf(&quot;%lld&quot;,&amp;m);</span><br><span class="line">    for(int i=1;i&lt;=m;i++)  sum[i]=sum[i-1]+i;</span><br><span class="line">    for(int i=1;i&lt;=m-1;i++) &#123;</span><br><span class="line">        ll l=i,r=m-1,mid;</span><br><span class="line">        while(l&lt;=r) &#123;</span><br><span class="line">            mid=(l+r)/2;</span><br><span class="line">            ll t=sum[mid]-sum[i-1];</span><br><span class="line">            if(t==m) &#123;</span><br><span class="line">                printf(&quot;%d %d\n&quot;,i,mid);</span><br><span class="line">                break;</span><br><span class="line">            &#125;else if(t&lt;m) &#123;</span><br><span class="line">                l=mid+1;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                r=mid-1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;连续自然数和&quot;&gt;&lt;a href=&quot;#连续自然数和&quot; class=&quot;headerlink&quot; title=&quot;连续自然数和&quot;&gt;&lt;/a&gt;连续自然数和&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;描述：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对一个给定的自然数$M$，求出所有的连续的自然数段，这些连续的自然数段中的全部数之和为$M$。&lt;br&gt;例子：1998+1999+2000+2001+2002 = 10000，所以从1998到2002的一个自然数段为$M=10000$的一个解。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://e99net.github.io/categories/Algorithm/"/>
    
    
      <category term="Prefix Sum" scheme="https://e99net.github.io/tags/Prefix-Sum/"/>
    
      <category term="Binary Search" scheme="https://e99net.github.io/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>记两道2020年某企业秋招的算法编程题</title>
    <link href="https://e99net.github.io/2019/09/26/tourSohu/"/>
    <id>https://e99net.github.io/2019/09/26/tourSohu/</id>
    <published>2019-09-26T12:07:20.889Z</published>
    <updated>2019-09-26T12:38:02.545Z</updated>
    
    <content type="html"><![CDATA[<h4 id="专业题1"><a href="#专业题1" class="headerlink" title="专业题1"></a>专业题1</h4><ul><li>描述：</li></ul><p>一个k（1&lt;=k&lt;=80）位的十进制整数n，我们称其为大整数。现在的问题是，请你设计一个程序，对于给出的某个大整数，找到满足条件p^3+p^2+3 * p&lt;=n的p的最大值。</p><a id="more"></a><ul><li>输入：</li></ul><ul><li>输出：</li></ul><ul><li>样例输入：</li></ul><ul><li>样例输出：</li></ul><ul><li>参考代码:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="专业题2"><a href="#专业题2" class="headerlink" title="专业题2"></a>专业题2</h4><ul><li>描述：</li></ul><p>在一个棋盘上有N个处于不同位置的棋子，每个棋子所在的位置都可以用坐标(X,Y)来表示，并且任一棋子每次可以向上、下、左、右移动单位长度。如果想让所有棋子进入一个水平线，彼此靠近，即它们最后的位置是(X,Y)、(X+1,Y)、……、(X+N,Y)，水平线上棋子的最后顺序是任意的，那么最少需要移动多少次棋子？<br>注意：两个或两个以上的棋子不能在同一时间处于同一位置。</p><ul><li>输入：</li></ul><p>第一行是一个整数N，表示棋子数，1&lt;=N&lt;=10000。后面的N行分别是每个棋子的初始位置，包含空格分开的整数x、y，-10000&lt;=x,y&lt;=10000。</p><ul><li>输出：</li></ul><p>仅有一行一个值，表示使棋子移到水平线彼此相邻位置的最小移动次数。</p><ul><li>样例输入：</li></ul><p>5<br>1 2<br>2 2<br>1 3<br>3 -2<br>3 3</p><ul><li>样例输出：</li></ul><p>8</p><ul><li>参考代码:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;专业题1&quot;&gt;&lt;a href=&quot;#专业题1&quot; class=&quot;headerlink&quot; title=&quot;专业题1&quot;&gt;&lt;/a&gt;专业题1&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;描述：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一个k（1&amp;lt;=k&amp;lt;=80）位的十进制整数n，我们称其为大整数。现在的问题是，请你设计一个程序，对于给出的某个大整数，找到满足条件p^3+p^2+3 * p&amp;lt;=n的p的最大值。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://e99net.github.io/categories/Algorithm/"/>
    
    
      <category term="Number theory" scheme="https://e99net.github.io/tags/Number-theory/"/>
    
  </entry>
  
  <entry>
    <title>洛谷的刷题日常之P1880</title>
    <link href="https://e99net.github.io/2019/09/24/luogu_P1880/"/>
    <id>https://e99net.github.io/2019/09/24/luogu_P1880/</id>
    <published>2019-09-24T03:16:45.340Z</published>
    <updated>2019-10-06T12:12:45.330Z</updated>
    
    <content type="html"><![CDATA[<h4 id="石子合并"><a href="#石子合并" class="headerlink" title="石子合并"></a>石子合并</h4><p>先看一道比luogu p1880简单的题目。</p><ul><li>描述：</li></ul><p>有n堆石子排成一排，每堆石子有一定的数量，将n堆石子合并成一堆。合并的规则是每次只能合并相邻的两堆石子，合并的花费为这两堆石子的总数。石子经过n-1次合并后成为一堆，求总的最小花费和最大花费。</p><a id="more"></a><ul><li>输入：</li></ul><p>有多组测试数据，输入到文件结束。每组测试数据的第1行有一个整数n，表示有n堆石子，n&lt;250。接下来的一行有n个数，分别表示这n堆石子的数目。每堆石子至少一颗，最多10000颗。</p><ul><li>输出：</li></ul><p>总的最小花费和最大花费。</p><ul><li>输入样例：</li></ul><p>3<br>2 4 5</p><ul><li>输出样例：</li></ul><p>17<br>20</p><ul><li><p>解题思路：区间DP</p></li><li><p>参考代码:</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int INF=1&lt;&lt;30;</span><br><span class="line">const int N=300;</span><br><span class="line">int n,sum[N];</span><br><span class="line"></span><br><span class="line">int Minval()&#123;</span><br><span class="line">    int dp[N][N]；</span><br><span class="line">    for(int i=1;i&lt;=n;i++) dp[i][i]=0;</span><br><span class="line">    for(int len=1;len&lt;n;len++)</span><br><span class="line">        for(int i=1;i&lt;=n-len;i++) &#123;</span><br><span class="line">            int j=i+len;</span><br><span class="line">            dp[i][j]=INF;</span><br><span class="line">            for(int k=i;k&lt;j;k++)</span><br><span class="line">                dp[i][j]=min(dp[i][j],dp[i][k]+dp[k+1][j]+sum[j]-sum[i-1]);</span><br><span class="line">        &#125;</span><br><span class="line">    return dp[1][n];</span><br><span class="line">&#125;</span><br><span class="line">int Maxval()&#123;</span><br><span class="line">    int dp[N][N];</span><br><span class="line">    for(int i=1;i&lt;=n;i++) dp[i][i]=0;</span><br><span class="line">    for(int len=1;len&lt;n;len++)</span><br><span class="line">        for(int i=1;i&lt;=n-len;i++) &#123;</span><br><span class="line">            int j=i+len;</span><br><span class="line">            dp[i][j]=-INF;</span><br><span class="line">            for(int k=i;k&lt;j;k++)</span><br><span class="line">                dp[i][j]=max(dp[i][j],dp[i][k]+dp[k+1][j]+sum[j]-sum[i-1]);</span><br><span class="line">        &#125;</span><br><span class="line">    return dp[1][n];</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    sum[0]=0;</span><br><span class="line">    for(int i=1;i&lt;=n;i++) &#123;</span><br><span class="line">        int x;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">        sum[i]=sum[i-1]+x;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n%d&quot;,Minval(),Maxval());</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="环形石子合并"><a href="#环形石子合并" class="headerlink" title="环形石子合并"></a>环形石子合并</h4><p>接下来就可以着手解决luogu p1880了。如果按照上面的解法解这道题，会出现“min值永远比正确答案大1”的“奇怪”现象，这是因为没有考虑环形的缘故。</p><ul><li>描述：</li></ul><p>在一个圆形操场的四周摆放N堆石子,现要将石子有次序地合并成一堆.规定每次只能选相邻的2堆合并成新的一堆，并将新的一堆的石子数，记为该次合并的得分。</p><p>试设计出1个算法,计算出将N堆石子合并成1堆的最小得分和最大得分.</p><!-- more --><ul><li>输入：</li></ul><p>数据的第1行试正整数N,1≤N≤100,表示有N堆石子.第2行有N个数,分别表示每堆石子的个数.</p><ul><li>输出：</li></ul><p>输出共2行,第1行为最小得分,第2行为最大得分.</p><ul><li>输入样例：</li></ul><p>4<br>4 5 9 4</p><ul><li>输出样例：</li></ul><p>43<br>54</p><ul><li><p>解题思路：</p><ul><li>区间DP</li><li>处理环形情况的通用套路：在任意位置把环断开成链，复制一倍接在末尾</li></ul></li><li><p>参考代码:</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int INF=1&lt;&lt;30;</span><br><span class="line">const int N=240;</span><br><span class="line">int n,sum[N],x,arr[N];</span><br><span class="line"></span><br><span class="line">int Minval()&#123;</span><br><span class="line">    int dp[N][N],ans=INF;</span><br><span class="line">    for(int i=1;i&lt;=n;i++) dp[i][i]=0;</span><br><span class="line">    for(int len=1;len&lt;n;len++)</span><br><span class="line">        for(int i=1;i&lt;=2*n-len;i++) &#123;</span><br><span class="line">            int j=i+len;</span><br><span class="line">            dp[i][j]=INF;</span><br><span class="line">            for(int k=i;k&lt;j;k++)</span><br><span class="line">                dp[i][j]=min(dp[i][j],dp[i][k]+dp[k+1][j]+sum[j]-sum[i-1]);</span><br><span class="line">        &#125;</span><br><span class="line">    for(int i=1;i&lt;=n;i++) &#123;</span><br><span class="line">        ans=ans&gt;dp[i][i+n-1]?dp[i][i+n-1]:ans;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int Maxval()&#123;</span><br><span class="line">    int dp[N][N],ans=-INF;</span><br><span class="line">    for(int i=1;i&lt;=n;i++) dp[i][i]=0;</span><br><span class="line">    for(int len=1;len&lt;n;len++)</span><br><span class="line">        for(int i=1;i&lt;=2*n-len;i++) &#123;</span><br><span class="line">            int j=i+len;</span><br><span class="line">            dp[i][j]=-INF;</span><br><span class="line">            for(int k=i;k&lt;j;k++)</span><br><span class="line">                dp[i][j]=max(dp[i][j],dp[i][k]+dp[k+1][j]+sum[j]-sum[i-1]);</span><br><span class="line">        &#125;</span><br><span class="line">    for(int i=1;i&lt;=n;i++) &#123;</span><br><span class="line">        ans=ans&lt;dp[i][i+n-1]?dp[i][i+n-1]:ans;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    sum[0]=0;</span><br><span class="line">    for(int i=1;i&lt;=n;i++) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;arr[i]);</span><br><span class="line">        arr[i+n]=arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=2*n;i++) &#123;</span><br><span class="line">        sum[i]=sum[i-1]+arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n%d&quot;,Minval(),Maxval());</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>相似题目：</li></ul><p>hdu 3506 “Monkey Party”</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;石子合并&quot;&gt;&lt;a href=&quot;#石子合并&quot; class=&quot;headerlink&quot; title=&quot;石子合并&quot;&gt;&lt;/a&gt;石子合并&lt;/h4&gt;&lt;p&gt;先看一道比luogu p1880简单的题目。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;描述：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有n堆石子排成一排，每堆石子有一定的数量，将n堆石子合并成一堆。合并的规则是每次只能合并相邻的两堆石子，合并的花费为这两堆石子的总数。石子经过n-1次合并后成为一堆，求总的最小花费和最大花费。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://e99net.github.io/categories/Algorithm/"/>
    
    
      <category term="Dynamic Programming" scheme="https://e99net.github.io/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>记三道2020年某企业秋招笔试题</title>
    <link href="https://e99net.github.io/2019/09/24/cmbcc/"/>
    <id>https://e99net.github.io/2019/09/24/cmbcc/</id>
    <published>2019-09-24T02:30:06.499Z</published>
    <updated>2019-09-26T13:07:40.465Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-n-中每位数字乘积最大的值"><a href="#1-n-中每位数字乘积最大的值" class="headerlink" title="1 ~ n 中每位数字乘积最大的值"></a>1 ~ n 中每位数字乘积最大的值</h4><ul><li>描述：</li></ul><p>99°是一位爱好爬山的小青年，他每次在爬山过程中都会遇到很多小猴子，小猴子们喜欢向他提这样一种问题：在1 ~ n中找一个数字m，使得m的各个数位乘积最大。99°不擅长回答这种问题，你能帮他写一个程序得到结果吗？</p><a id="more"></a><ul><li>样例输入1：</li></ul><p>100</p><ul><li>样例输出1：</li></ul><p>81</p><p>提示：9 * 9 = 81</p><ul><li>样例输入2：</li></ul><p>6</p><ul><li>样例输出2：</li></ul><p>6</p><ul><li><p>解题思路：深度优先搜索</p></li><li><p>参考代码:</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define ll long long</span><br><span class="line"></span><br><span class="line">ll dfs(int n) &#123;</span><br><span class="line">    if(n==0) return 1;</span><br><span class="line">    if(n&lt;10) return n;</span><br><span class="line">    else return max(dfs(n/10-1)*9,dfs(n/10)*(n%10));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    printf(&quot;%lld&quot;,dfs(n));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="完成可能有前置任务的任务"><a href="#完成可能有前置任务的任务" class="headerlink" title="完成可能有前置任务的任务"></a>完成可能有前置任务的任务</h4><ul><li>描述：</li></ul><p>99°要完成n个任务，它制定了一个计划，计划第i天完成第i个任务，每个任务可能有前置任务，在完成第i个任务时，必须先完成它的前置任务才行。问99°要想实现它的计划，每天至少要完成多少个任务？</p><ul><li>输入：</li></ul><p>一个整数n，表示要完成的任务数，2&lt;=n&lt;=10000。接下来n行，每行第一个数字k表示该任务的前置任务数，剩下的k个数字分别表示前置任务编号。</p><ul><li>输出：</li></ul><p>n个数字，每个数字以一个空格间隔，表示每天至少完成的任务数。</p><ul><li>样例输入：</li></ul><p>3<br>1 2<br>0<br>2 1 2</p><ul><li>样例输出：</li></ul><p>2 0 1</p><p>说明：任务1有1个前置任务2，第1天要想完成任务1，需先完成任务2，所以第1天至少完成2个任务。第2天计划完成任务2，因为任务2已在第一天完成，且任务2无前置任务，所以第2天至少完成0个任务。第3天计划完成任务3，任务3有两个前置任务1、2，在前两天都已完成，所以这一天只需完成任务3，至少完成1个任务即可。</p><ul><li>样例输入：</li></ul><p>5<br>4 2 3 4 5<br>1 1<br>2 1 2<br>0<br>1 3</p><ul><li>样例输出：</li></ul><p>5 0 0 0 0</p><p>说明：第1个任务有4个前置任务2、3、4、5，要想完成1，需先完成2、3、4、5，那么第1天至少完成5个任务。接下来的第2、3、4、5天每天完成0个任务，因为在第1天已完成全部5个任务。</p><h4 id="将数组元素变为非递减"><a href="#将数组元素变为非递减" class="headerlink" title="将数组元素变为非递减"></a>将数组元素变为非递减</h4><ul><li>描述</li></ul><p>99°给出一个包含$n$个整数的数组$a_i$，99°每次可以选择数组中若干个下标不同的元素，对选中的每个元素执行下列改变：假设选中的元素为$x$，那么就将$x$替换为$(x+1) mod m$，即选中的每个元素自增1，如果变为$m$则归零。<br>请问最少执行多少次操作，99°可以把这个数组变为一个数组元素非递减的数组。</p><ul><li>输入：</li></ul><p>第一行两个整数$n$和$m$，用一个空格分隔；<br>第二行$n$个整数$a_1$,$a_2$,…,$a_n$表示数组，每两个整数之间用一个空格分隔。<br>输入满足$1&lt;=n,m&lt;=300000;0 &lt;= a_i &lt; m$ 。</p><ul><li>输出：</li></ul><p>一个整数，表示最少需要的操作次数。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-n-中每位数字乘积最大的值&quot;&gt;&lt;a href=&quot;#1-n-中每位数字乘积最大的值&quot; class=&quot;headerlink&quot; title=&quot;1 ~ n 中每位数字乘积最大的值&quot;&gt;&lt;/a&gt;1 ~ n 中每位数字乘积最大的值&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;描述：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;99°是一位爱好爬山的小青年，他每次在爬山过程中都会遇到很多小猴子，小猴子们喜欢向他提这样一种问题：在1 ~ n中找一个数字m，使得m的各个数位乘积最大。99°不擅长回答这种问题，你能帮他写一个程序得到结果吗？&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://e99net.github.io/categories/Algorithm/"/>
    
    
      <category term="DFS" scheme="https://e99net.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>记一道2020年某企业提前批招聘的机试题</title>
    <link href="https://e99net.github.io/2019/09/21/spdb/"/>
    <id>https://e99net.github.io/2019/09/21/spdb/</id>
    <published>2019-09-21T11:20:15.013Z</published>
    <updated>2019-09-24T02:57:39.061Z</updated>
    
    <content type="html"><![CDATA[<h4 id="字符串是否由子串拼接而成"><a href="#字符串是否由子串拼接而成" class="headerlink" title="字符串是否由子串拼接而成"></a>字符串是否由子串拼接而成</h4><ul><li>描述：</li></ul><p>给出一个非空的字符串，判断这个字符串是否由它的一个子串进行多次首尾拼接构成。<br>例如，“abcabcabc”满足条件，因为它是由“abc”首尾拼接而成，而“abcab”则不满足条件。</p><a id="more"></a><ul><li>输入：</li></ul><p>abcabcabc</p><ul><li>输出：</li></ul><p>true</p><ul><li>参考代码:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    string str;</span><br><span class="line">    cin&gt;&gt;str;</span><br><span class="line">    int n=str.size();</span><br><span class="line">    int m,flag;</span><br><span class="line">    for(int i=n/2;i&gt;=1;i--) &#123;</span><br><span class="line">        flag=0;</span><br><span class="line">        if(n%i==0)&#123;</span><br><span class="line">            m=n/i;</span><br><span class="line">            for(int j=0;j&lt;i;j++)&#123;</span><br><span class="line">                for(int k=1;k&lt;m;k++) &#123;</span><br><span class="line">                    if(str[j]!=str[j+k*i]) &#123;</span><br><span class="line">                        flag=1;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if(flag) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(!flag) &#123;</span><br><span class="line">                printf(&quot;true&quot;);</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;false&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;字符串是否由子串拼接而成&quot;&gt;&lt;a href=&quot;#字符串是否由子串拼接而成&quot; class=&quot;headerlink&quot; title=&quot;字符串是否由子串拼接而成&quot;&gt;&lt;/a&gt;字符串是否由子串拼接而成&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;描述：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;给出一个非空的字符串，判断这个字符串是否由它的一个子串进行多次首尾拼接构成。&lt;br&gt;例如，“abcabcabc”满足条件，因为它是由“abc”首尾拼接而成，而“abcab”则不满足条件。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://e99net.github.io/categories/Algorithm/"/>
    
    
      <category term="String" scheme="https://e99net.github.io/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>C++的输入与输出</title>
    <link href="https://e99net.github.io/2019/08/25/InputandOutputOfCpp/"/>
    <id>https://e99net.github.io/2019/08/25/InputandOutputOfCpp/</id>
    <published>2019-08-25T07:35:30.848Z</published>
    <updated>2019-08-25T07:38:59.207Z</updated>
    
    <content type="html"><![CDATA[<p>输入时：<br>float型输入用%f。<br>double型输入用%lf。</p><a id="more"></a><p>输出时：<br>最好是都用%f输出。<br>在G++中，double类型若用%lf输出可能会错，而在C++中，double类型用%lf输出是正确的。<br>printf() 函数中不存在 %lf。</p><p>总结：<br>输入 double 用 %lf 输出用 %f。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;输入时：&lt;br&gt;float型输入用%f。&lt;br&gt;double型输入用%lf。&lt;/p&gt;
    
    </summary>
    
      <category term="memo" scheme="https://e99net.github.io/categories/memo/"/>
    
    
      <category term="C/C++" scheme="https://e99net.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>用Git进行简单有效的项目版本控制管理</title>
    <link href="https://e99net.github.io/2019/03/02/git/"/>
    <id>https://e99net.github.io/2019/03/02/git/</id>
    <published>2019-03-02T11:50:07.770Z</published>
    <updated>2019-03-02T11:59:41.342Z</updated>
    
    <content type="html"><![CDATA[<p>Git是一个非常强大的项目版本控制管理工具，在单机环境下，可以简单有效地使用Git</p><a id="more"></a><ul><li>常用的Git命令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;[提交点名称]&quot;</span><br><span class="line">git status</span><br><span class="line">git log</span><br><span class="line">git reset --hard HEAD^^</span><br><span class="line">get reset --hard [Git生成的版本号，不必写全，无歧义即可]</span><br><span class="line">git checkout -- [文件]</span><br></pre></td></tr></table></figure></li></ul><p>以上这些命令就足以较好地管理自己的项目目录了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Git是一个非常强大的项目版本控制管理工具，在单机环境下，可以简单有效地使用Git&lt;/p&gt;
    
    </summary>
    
      <category term="memo" scheme="https://e99net.github.io/categories/memo/"/>
    
    
      <category term="Git" scheme="https://e99net.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>makefile文件的不同写法</title>
    <link href="https://e99net.github.io/2019/02/23/otherKindOfMakefile/"/>
    <id>https://e99net.github.io/2019/02/23/otherKindOfMakefile/</id>
    <published>2019-02-23T03:50:46.528Z</published>
    <updated>2019-02-23T03:55:09.817Z</updated>
    
    <content type="html"><![CDATA[<ul><li>封装so库时的写法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">CC=gcc</span><br><span class="line"></span><br><span class="line">SRCS=mylib.c</span><br><span class="line"></span><br><span class="line">OBJS=$(SRCS:.c=.o)</span><br><span class="line"></span><br><span class="line">EXEC=libmylib.so</span><br><span class="line"></span><br><span class="line">start: $(OBJS)</span><br><span class="line">    $(CC) -o $(EXEC) $(OBJS) -shared</span><br><span class="line"></span><br><span class="line">.c.o:</span><br><span class="line">    $(CC) -o $@ -c $&lt; -fPIC</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">    rm -rf $(OBJS)</span><br></pre></td></tr></table></figure><a id="more"></a><ul><li>C/C++混合编程的写法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">CC=g++</span><br><span class="line"></span><br><span class="line">SRCS=main.cpp\</span><br><span class="line">    udp.cpp</span><br><span class="line"></span><br><span class="line">OBJS=$(SRCS:.cpp=.o)</span><br><span class="line"></span><br><span class="line">EXEC=myudp</span><br><span class="line"></span><br><span class="line">start: $(OBJS)</span><br><span class="line">    $(CC) -o $(EXEC) $(OBJS)</span><br><span class="line"></span><br><span class="line">.cpp.o:</span><br><span class="line">    $(CC) -o $@ -c $&lt; -DMYLINUX</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">    rm -rf $(OBJS)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;封装so库时的写法&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;CC=gcc&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SRCS=mylib.c&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;OBJS=$(SRCS:.c=.o)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;EXEC=libmylib.so&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;start: $(OBJS)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    $(CC) -o $(EXEC) $(OBJS) -shared&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.c.o:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    $(CC) -o $@ -c $&amp;lt; -fPIC&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;clean:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    rm -rf $(OBJS)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="memo" scheme="https://e99net.github.io/categories/memo/"/>
    
    
      <category term="C/C++" scheme="https://e99net.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>循序渐进写makefile</title>
    <link href="https://e99net.github.io/2019/02/23/writeMakefile/"/>
    <id>https://e99net.github.io/2019/02/23/writeMakefile/</id>
    <published>2019-02-23T03:11:15.605Z</published>
    <updated>2019-02-23T04:22:53.639Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>准备工作</p><ul><li><p>main.cpp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;a.h&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    test();</span><br><span class="line">    cout &lt;&lt; &quot;hello world&quot; &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>a.h</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#ifndef AH_H</span><br><span class="line">#define AH_H</span><br><span class="line">void test();</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></li><li><p>a.cpp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;I am test\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><a id="more"></a><ul><li>版本0</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">start:</span><br><span class="line">    g++ -o a.o -c a.cpp</span><br><span class="line">    g++ -o main.o -c main.cpp</span><br><span class="line">    g++ -o myapp a.o main.o</span><br></pre></td></tr></table></figure><ul><li>版本1</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">start:</span><br><span class="line">    g++ -o a.o -c a.cpp</span><br><span class="line">    g++ -o main.o -c main.cpp</span><br><span class="line">    g++ -o myapp a.o main.o</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">    rm -rf a.o main.o</span><br></pre></td></tr></table></figure><ul><li>版本2</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CC=g++</span><br><span class="line"></span><br><span class="line">EXEC=myapp</span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line">    $(CC) -o a.o -c a.cpp</span><br><span class="line">    $(CC) -o main.o -c main.cpp</span><br><span class="line">    $(CC) -o $(EXEC) a.o main.o</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">    rm -rf a.o main.o</span><br></pre></td></tr></table></figure><ul><li>版本3</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">CC=g++</span><br><span class="line"></span><br><span class="line">SRCS=main.cpp\</span><br><span class="line">        a.cpp</span><br><span class="line"></span><br><span class="line">OBJS=main.o\</span><br><span class="line">        a.o</span><br><span class="line"></span><br><span class="line">EXEC=myapp</span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line">    $(CC) -o $(OBJS) -c $(SRCS)</span><br><span class="line">    $(CC) -o $(EXEC) $(OBJS)</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">    rm -rf $(OBJS)</span><br></pre></td></tr></table></figure><ul><li>版本4</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">CC=g++</span><br><span class="line"></span><br><span class="line">SRCS=main.cpp\</span><br><span class="line">        a.cpp</span><br><span class="line"></span><br><span class="line">OBJS=main.o\</span><br><span class="line">        a.o</span><br><span class="line"></span><br><span class="line">EXEC=myapp</span><br><span class="line"></span><br><span class="line">start: a.o main.o</span><br><span class="line">    $(CC) -o $(EXEC) $(OBJS)</span><br><span class="line"></span><br><span class="line">a.o main.o:</span><br><span class="line">    $(CC) -o $(OBJS) -c $(SRCS)</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">    rm -rf $(OBJS)</span><br></pre></td></tr></table></figure><ul><li>最终版本</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">CC=g++</span><br><span class="line"></span><br><span class="line">SRCS=main.cpp\</span><br><span class="line">        a.cpp</span><br><span class="line"></span><br><span class="line">OBJS=$(SRCS:.cpp=.o)</span><br><span class="line"></span><br><span class="line">EXEC=myapp</span><br><span class="line"></span><br><span class="line">start: $(OBJS)</span><br><span class="line">        $(CC) -o $(EXEC) $(OBJS)</span><br><span class="line"></span><br><span class="line">.cpp.o:</span><br><span class="line">        $(CC) -o $@ -c $&lt;</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">        rm -rf $(OBJS)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;准备工作&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;main.cpp&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;quot;a.h&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;using namespace std;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int main()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    test();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cout &amp;lt;&amp;lt; &amp;quot;hello world&amp;quot; &amp;lt;&amp;lt; endl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;a.h&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#ifndef AH_H&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#define AH_H&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void test();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#endif&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;a.cpp&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void test()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    printf(&amp;quot;I am test\n&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="memo" scheme="https://e99net.github.io/categories/memo/"/>
    
    
      <category term="C/C++" scheme="https://e99net.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>Win7开机界面英文转中文</title>
    <link href="https://e99net.github.io/2019/02/10/EnToChOfBootloader/"/>
    <id>https://e99net.github.io/2019/02/10/EnToChOfBootloader/</id>
    <published>2019-02-10T03:56:23.237Z</published>
    <updated>2019-02-10T07:44:35.550Z</updated>
    
    <content type="html"><![CDATA[<p>打开cmd命令提示符并执行如下命令</p><ul><li>将操作系统启动选择菜单的显示语言修改为简体中文<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcdedit /set &#123;bootmgr&#125; locale zh-CN</span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><ul><li><p>将当前Windows操作系统F8高级启动菜单的显示语言修改为简体中文</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcdedit /set &#123;current&#125; locale zh-CN</span><br></pre></td></tr></table></figure></li><li><p>将Windows内存诊断工具的显示语言修改为简体中文</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcdedit /set &#123;memdiag&#125; locale zh-CN</span><br></pre></td></tr></table></figure></li><li><p>将休眠恢复时的显示语言修改为简体中文</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcdedit /set &#123;视机器而定的一段字符&#125; locale zh-CN</span><br></pre></td></tr></table></figure></li></ul><p>注意：视机器而定的一段字符形如526bf864-88ef-11de-9b8c-e613e975374f，这段字符可通过以下命令进行查看<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcdedit /enum all</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;打开cmd命令提示符并执行如下命令&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将操作系统启动选择菜单的显示语言修改为简体中文&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;bcdedit /set &amp;#123;bootmgr&amp;#125; locale zh-CN&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="memo" scheme="https://e99net.github.io/categories/memo/"/>
    
    
      <category term="Water" scheme="https://e99net.github.io/tags/Water/"/>
    
  </entry>
  
  <entry>
    <title>用UltraISO制作Ubuntu18.04的启动U盘</title>
    <link href="https://e99net.github.io/2019/02/02/USBofUbuntu/"/>
    <id>https://e99net.github.io/2019/02/02/USBofUbuntu/</id>
    <published>2019-02-02T14:41:58.789Z</published>
    <updated>2019-09-21T11:54:52.784Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>从Ubuntu官网下载18.04系统的iso文件，并安装UltraISO软件</p></li><li><p>确保用来制作启动盘的U盘是FAT32格式的，否则，可将U盘格式化为FAT32格式</p></li></ol><a id="more"></a><ol start="3"><li><p>点击UltraISO的红色框内按钮<br><img src="/2019/02/02/USBofUbuntu/20170916135522757.png" alt=""></p></li><li><p>找到Ubuntu ISO文件并选中，点击打开<br><img src="/2019/02/02/USBofUbuntu/20170916135636024.png" alt=""><br>打开后的界面如下图所示<br><img src="/2019/02/02/USBofUbuntu/20170916135757851.png" alt=""></p></li><li><p>点击“启动→写入硬盘映像…”<br><img src="/2019/02/02/USBofUbuntu/20170916140000287.png" alt=""></p></li><li><p>写入方式选择USB-HDD+或者USB-HDD都可以<br><img src="/2019/02/02/USBofUbuntu/20170916140040427.png" alt=""></p></li><li><p>点击“便捷启动→写入新的驱动器引导扇区→Syslinux”,选择“是”，完成后“确定”<br><img src="/2019/02/02/USBofUbuntu/20170916140325642.png" alt=""><br><img src="/2019/02/02/USBofUbuntu/20170916140507610.png" alt=""><br><img src="/2019/02/02/USBofUbuntu/20170916140541363.png" alt=""></p></li><li><p>点击“写入”，选择“是”。<br><img src="/2019/02/02/USBofUbuntu/20170916140938127.png" alt=""></p></li><li><p>写入需要等待一段时间，完成后如下图。此时，选择“返回”并退出UltraISO即可<br><img src="/2019/02/02/USBofUbuntu/20170916141128817.png" alt=""></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;p&gt;从Ubuntu官网下载18.04系统的iso文件，并安装UltraISO软件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;确保用来制作启动盘的U盘是FAT32格式的，否则，可将U盘格式化为FAT32格式&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="memo" scheme="https://e99net.github.io/categories/memo/"/>
    
    
      <category term="Water" scheme="https://e99net.github.io/tags/Water/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu上的各种软件问题解决之道</title>
    <link href="https://e99net.github.io/2019/02/02/SolofMatlabOnUbuntu/"/>
    <id>https://e99net.github.io/2019/02/02/SolofMatlabOnUbuntu/</id>
    <published>2019-02-02T14:17:20.516Z</published>
    <updated>2019-02-02T14:41:36.433Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Ubuntu上的Matlab无法以普通用户身份运行"><a href="#Ubuntu上的Matlab无法以普通用户身份运行" class="headerlink" title="Ubuntu上的Matlab无法以普通用户身份运行"></a>Ubuntu上的Matlab无法以普通用户身份运行</h2><p>给“/home/用户名/.matlab”这个文件目录递归授予超级权限<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod 777 .matlab -R</span><br></pre></td></tr></table></figure></p><h2 id="CLion无法用快捷方式启动"><a href="#CLion无法用快捷方式启动" class="headerlink" title="CLion无法用快捷方式启动"></a>CLion无法用快捷方式启动</h2><p>先在Terminal中启动CLion，然后点击菜单栏Tools下面的Create Desktop Entry即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Ubuntu上的Matlab无法以普通用户身份运行&quot;&gt;&lt;a href=&quot;#Ubuntu上的Matlab无法以普通用户身份运行&quot; class=&quot;headerlink&quot; title=&quot;Ubuntu上的Matlab无法以普通用户身份运行&quot;&gt;&lt;/a&gt;Ubuntu上的Mat
      
    
    </summary>
    
      <category term="memo" scheme="https://e99net.github.io/categories/memo/"/>
    
    
      <category term="Linux" scheme="https://e99net.github.io/tags/Linux/"/>
    
      <category term="Matlab" scheme="https://e99net.github.io/tags/Matlab/"/>
    
  </entry>
  
  <entry>
    <title>强化学习介绍</title>
    <link href="https://e99net.github.io/2018/11/12/A_intro_to_RL/"/>
    <id>https://e99net.github.io/2018/11/12/A_intro_to_RL/</id>
    <published>2018-11-12T12:10:15.619Z</published>
    <updated>2019-01-05T12:11:57.067Z</updated>
    
    <content type="html"><![CDATA[<h4 id="蒙特卡罗-VS-TD学习方法"><a href="#蒙特卡罗-VS-TD学习方法" class="headerlink" title="蒙特卡罗 VS TD学习方法"></a>蒙特卡罗 VS TD学习方法</h4><p>我们有两种学习方式：</p><ul><li>在episode的最后收集奖励并计算最大期望将来奖励：蒙特卡罗方法</li><li>估计每一步的奖励：时序差分学习</li></ul><a id="more"></a><h5 id="蒙特卡罗"><a href="#蒙特卡罗" class="headerlink" title="蒙特卡罗"></a>蒙特卡罗</h5><p>当episode结束时（智能体到达一个“终止状态”），智能体视其总共的累计奖励来知晓它做的怎么样。在蒙特卡罗方法中，只有在游戏的最后才会收到奖励。</p><p>然后，带着新增的知识开启一轮新游戏。智能体每次迭代会做出更好的决策。</p><h4 id="探索-开发的权衡"><a href="#探索-开发的权衡" class="headerlink" title="探索/开发的权衡"></a>探索/开发的权衡</h4><ul><li>探索是发现有关环境的更多信息</li><li>开发是开发已知的信息，使得奖励最大化</li></ul><p>强化学习智能体的目标是最大化期望的累计奖励，然而，我们会陷入一个共同的陷阱。</p><p>我们必须定义一个规则帮助我们处理这种权衡。</p><h4 id="强化学习的三种方法"><a href="#强化学习的三种方法" class="headerlink" title="强化学习的三种方法"></a>强化学习的三种方法</h4><p>解决强化学习问题的三种方法是：基于值、基于策略、基于模型。</p><h5 id="基于值"><a href="#基于值" class="headerlink" title="基于值"></a>基于值</h5><p>在基于值的强化学习中，目标是优化值函数</p><blockquote><p>值函数告知我们智能体在每个状态得到的最大期望将来奖励</p></blockquote><p>每个状态的值是在那个状态的智能体期望在将来累计的奖励总数。<br>$$<br>V_\pi(s)=\mathbb{E_\pi}[R_{t+1}+\gamma R_{t+2}+\gamma ^2 R_{t+3}+…|S_t =s]<br>$$<br>智能体会使用这个值函数去在每一步选择一个状态，选择的状态具有最大的值。</p><h5 id="基于策略"><a href="#基于策略" class="headerlink" title="基于策略"></a>基于策略</h5><p>在基于策略的强化学习中，我们想不使用值函数而直接优化策略函数$\mathtt{\pi}(s)$。</p><p>策略是在一个给定的时间对智能体行为的定义。<br>$$<br>a=\pi(s)<br>$$<br>我们学习一个策略函数，使每个状态映射到对应的最好动作。</p><p>我们有两种策略：</p><ul><li>固定策略：一种在给定状态总会返回相同动作的策略。</li><li>随机策略：随动作输出分布概率。</li></ul><p>$$<br>\text{Stochastic policy:} \ \pi(a|s)=\mathbb{P}[A_t=a|S_t=s]<br>$$</p><p>策略直接表明每一步应该采取的最好动作。</p><h5 id="基于模型"><a href="#基于模型" class="headerlink" title="基于模型"></a>基于模型</h5><p>在基于模型的强化学习中，我们对环境建模。这意味着我们创建了一个环境行为的模型。</p><p>问题是每个环境都需要一个不同的模型表示。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;蒙特卡罗-VS-TD学习方法&quot;&gt;&lt;a href=&quot;#蒙特卡罗-VS-TD学习方法&quot; class=&quot;headerlink&quot; title=&quot;蒙特卡罗 VS TD学习方法&quot;&gt;&lt;/a&gt;蒙特卡罗 VS TD学习方法&lt;/h4&gt;&lt;p&gt;我们有两种学习方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在episode的最后收集奖励并计算最大期望将来奖励：蒙特卡罗方法&lt;/li&gt;
&lt;li&gt;估计每一步的奖励：时序差分学习&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="memo" scheme="https://e99net.github.io/categories/memo/"/>
    
    
      <category term="Reinforcement Learning" scheme="https://e99net.github.io/tags/Reinforcement-Learning/"/>
    
  </entry>
  
  <entry>
    <title>Latex处理参考文献</title>
    <link href="https://e99net.github.io/2018/11/02/reference_of_latex/"/>
    <id>https://e99net.github.io/2018/11/02/reference_of_latex/</id>
    <published>2018-11-02T13:48:12.079Z</published>
    <updated>2018-11-02T13:51:28.363Z</updated>
    
    <content type="html"><![CDATA[<p>使用cite宏包可以生成参考文献</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\usepackage&#123;cite&#125;</span><br><span class="line">\cite&#123;b3,b4,b5,b6,b7,b8&#125;</span><br></pre></td></tr></table></figure><p>生成的参考文献格式为：[3]-[8]</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用cite宏包可以生成参考文献&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;
      
    
    </summary>
    
      <category term="memo" scheme="https://e99net.github.io/categories/memo/"/>
    
    
      <category term="Latex" scheme="https://e99net.github.io/tags/Latex/"/>
    
  </entry>
  
  <entry>
    <title>WEB框架辨析</title>
    <link href="https://e99net.github.io/2018/10/23/webframe/"/>
    <id>https://e99net.github.io/2018/10/23/webframe/</id>
    <published>2018-10-23T05:30:52.852Z</published>
    <updated>2018-10-23T05:34:11.843Z</updated>
    
    <content type="html"><![CDATA[<h3 id="bootstrap是个Web框架吗？"><a href="#bootstrap是个Web框架吗？" class="headerlink" title="bootstrap是个Web框架吗？"></a>bootstrap是个Web框架吗？</h3><p>bootstrap不能算是个完整的框架，它应该算是一个css框架+一些js组件。主要目的不是提供一个完整的前端解决方案，而只是关注前端UI呈现。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;bootstrap是个Web框架吗？&quot;&gt;&lt;a href=&quot;#bootstrap是个Web框架吗？&quot; class=&quot;headerlink&quot; title=&quot;bootstrap是个Web框架吗？&quot;&gt;&lt;/a&gt;bootstrap是个Web框架吗？&lt;/h3&gt;&lt;p&gt;bootst
      
    
    </summary>
    
      <category term="memo" scheme="https://e99net.github.io/categories/memo/"/>
    
    
      <category term="Water" scheme="https://e99net.github.io/tags/Water/"/>
    
  </entry>
  
  <entry>
    <title>差分进化基础</title>
    <link href="https://e99net.github.io/2018/09/28/basic_of_DE/"/>
    <id>https://e99net.github.io/2018/09/28/basic_of_DE/</id>
    <published>2018-09-28T02:10:31.334Z</published>
    <updated>2018-10-01T08:34:42.606Z</updated>
    
    <content type="html"><![CDATA[<p>差分进化算法是一种自组织最小化方法，用户只需要很少的输入，它起源于遗传算法(EA)，是一种基于种群进化的算法，包括变异、交叉、选择、边界检测。</p><a id="more"></a><p>差分进化算法由Storn等人于1995年提出，是一种模拟生物进化的随机模型，保留了基于种群的全局搜索策略，降低了遗传操作的复杂性。</p><p>DE和PSO都是基于种群的算法，不同于其他演化算法的是，DE使用种群中两个随机选择的个体向量差产生一个新的候选解（个体）。DE有一个好的全局搜索能力，但通常在种群演化的后阶段收敛得很慢。PSO能够收敛得很快，但易于陷入局部最优。由于DE与PSO的互补特性，一些研究常聚焦于两者的混合应用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;差分进化算法是一种自组织最小化方法，用户只需要很少的输入，它起源于遗传算法(EA)，是一种基于种群进化的算法，包括变异、交叉、选择、边界检测。&lt;/p&gt;
    
    </summary>
    
      <category term="EAs" scheme="https://e99net.github.io/categories/EAs/"/>
    
    
      <category term="DE" scheme="https://e99net.github.io/tags/DE/"/>
    
  </entry>
  
  <entry>
    <title>扫盲</title>
    <link href="https://e99net.github.io/2018/09/23/Eliminate_illiteracy/"/>
    <id>https://e99net.github.io/2018/09/23/Eliminate_illiteracy/</id>
    <published>2018-09-23T05:26:00.771Z</published>
    <updated>2018-09-23T05:33:47.323Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>中国、日本和韩国的象形文字总称为CJK。</p><a id="more"></a></li><li><p>Mac OS X Mavericks(巨浪)：X表示Mac的第10个版本，“X”是罗马数字“10”的意思。</p></li><li><p>将“休眠”去掉，同时腾出C盘空间：powercfg.exe /hibernate off。</p></li><li><p>Sublime Text快捷键：Ctrl+K U 改为大写，Ctrl+K L 改为小写。</p></li><li><p>FreeBSD比Linux还要稳定，可以做到十年不关机，并且比Linux速度要快出30%。</p></li><li><p>美国军方五角大楼采用的是openBSD操作系统。</p></li><li><p>编译器图书中的”龙书“、”虎书“、”鲸书“ 分别指的是《编译原理：技术与工具（第2版）》、《高级编译器：设计与实现》、《现代编译原理：C语言描述》</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;中国、日本和韩国的象形文字总称为CJK。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="memo" scheme="https://e99net.github.io/categories/memo/"/>
    
    
      <category term="Water" scheme="https://e99net.github.io/tags/Water/"/>
    
  </entry>
  
  <entry>
    <title>JDK1.5的新特性</title>
    <link href="https://e99net.github.io/2018/09/23/jdk1.5_newCharacter/"/>
    <id>https://e99net.github.io/2018/09/23/jdk1.5_newCharacter/</id>
    <published>2018-09-23T05:13:15.352Z</published>
    <updated>2018-09-23T05:16:43.389Z</updated>
    
    <content type="html"><![CDATA[<p>jdk1.5的四个新特性如下：</p><ul><li>自动装箱和拆箱</li><li>增强for循环</li><li>静态导入（唯一的败笔）</li><li>可变参数</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;jdk1.5的四个新特性如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自动装箱和拆箱&lt;/li&gt;
&lt;li&gt;增强for循环&lt;/li&gt;
&lt;li&gt;静态导入（唯一的败笔）&lt;/li&gt;
&lt;li&gt;可变参数&lt;/li&gt;
&lt;/ul&gt;

      
    
    </summary>
    
      <category term="memo" scheme="https://e99net.github.io/categories/memo/"/>
    
    
      <category term="Java" scheme="https://e99net.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>TPC-H的22条查询语句</title>
    <link href="https://e99net.github.io/2018/09/15/tpch/"/>
    <id>https://e99net.github.io/2018/09/15/tpch/</id>
    <published>2018-09-15T02:17:13.183Z</published>
    <updated>2018-09-15T02:34:26.528Z</updated>
    
    <content type="html"><![CDATA[<p>TPC-H的22条查询语句中包含两个以上的表连接操作和至少一个聚集函数的有：</p><a id="more"></a><ul><li>Q2（五表连接、一个聚集）√</li><li>Q3（三表连接、一个聚集）√</li><li>Q5（六表连接、一个聚集）√</li><li>Q7（六表连接、一个聚集）</li><li>Q8（八表连接、两个聚集）√</li><li>Q9（六表连接、一个聚集）</li><li>Q10（四表连接、一个聚集）</li><li>Q11（三表连接、三个聚集）</li><li>Q12（两表连接）</li><li>Q16（两表连接）</li><li>Q17（两表连接）</li><li>Q18（三表连接）</li><li>Q19（两表连接）</li><li>Q20（两表连接）</li><li>Q21（四表连接）</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TPC-H的22条查询语句中包含两个以上的表连接操作和至少一个聚集函数的有：&lt;/p&gt;
    
    </summary>
    
      <category term="memo" scheme="https://e99net.github.io/categories/memo/"/>
    
    
      <category term="Database" scheme="https://e99net.github.io/tags/Database/"/>
    
  </entry>
  
</feed>
