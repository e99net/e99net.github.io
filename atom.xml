<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>99°</title>
  
  <subtitle>学习的本质就是重复</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://e99net.github.io/"/>
  <updated>2019-10-08T02:58:10.265Z</updated>
  <id>https://e99net.github.io/</id>
  
  <author>
    <name>sqLiu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>记五道2020年某企业提前批招聘笔试题</title>
    <link href="https://e99net.github.io/2019/10/07/netease/"/>
    <id>https://e99net.github.io/2019/10/07/netease/</id>
    <published>2019-10-07T02:44:38.279Z</published>
    <updated>2019-10-08T02:58:10.265Z</updated>
    
    <content type="html"><![CDATA[<h4 id="窗口点击模拟"><a href="#窗口点击模拟" class="headerlink" title="窗口点击模拟"></a>窗口点击模拟</h4><ul><li>描述：</li></ul><p>本题需要让你模拟一下在Windows系统里窗囗和鼠标点击的操作，具体如下：</p><ol><li>屏幕分辨率为3840 * 2160，左上角坐标为（0，0），右下角坐标为（3839，2159）</li><li>窗口是一个矩形的形状，由左上角坐标（X，Y），和宽高（W，H），四个数字来定位。左上角坐标为（X，Y）、右下角坐标为（X+W，Y+H），其中左上角坐标一定会在屏幕范围内，其他一些部分可能会超过屏幕范围。</li><li>窗囗的点击和遮挡规则同Windows，但是不考虑关闭窗囗、最大化、最小化和强制置顶的情况。即<br> 3.1 如果发生重叠的话，后面打开的窗口会显示在前面打开的窗口上面<br> 3.2 当鼠标发生一次点击的时候，需要判断点击到了哪个窗口，如果同个坐标有多个窗口，算点击到最上层的那个<br> 3.3 当一个窗囗被点击的时候，会浮动到最上层</li></ol><a id="more"></a><ul><li>输入：</li></ul><p>每个测试输入包含1个测试用例<br>第一行为2个整数N，M。其中N表示打开的窗口数目，M表示鼠标点击的数目，0&lt;N，M&lt;1000<br>接下来N行，每一行四个整数Xi Yi Wi Hi，分别表示第i个窗口（窗口Id为i，从1开始计数）的左上角坐标以及宽高，初始时窗口是按输入的顺序依次打开。其中0&lt;=Xi&lt;3840，0&lt;=Yi&lt;2160，0&lt;Wi&lt;3840，0&lt;Hi&lt;2160<br>再接下来有M行，每一行两个整数xj Yj，分别表示接下来发生的鼠标点击坐标。其中0&lt;=Xj&lt;3840，0&lt;=Yj&lt;2160</p><ul><li>输出：</li></ul><p>对于每次鼠标点击，输出本次点击到的窗口Id。如果没有点击到窗口，输出-1</p><ul><li>样例输入：</li></ul><p>2 4<br>100 100 100 100<br>10 10 150 150<br>105 105<br>180 180<br>105 105<br>1 1</p><ul><li>样例输出：</li></ul><p>2<br>1<br>1<br>-1</p><ul><li>样例说明：</li></ul><p>有2个窗口，第1个窗口左上角坐标为(100,100)，宽和高都是100，则其右下角坐标为(200,200)；<br>第2个窗口左上角坐标为(10,10)，宽和高都是150，则其右下角坐标为(160,160)。</p><p>有4次鼠标点击，第1次点击的位置同时属于1号和2号窗口，但由于2号窗口在上面，所以它被选择并且被置于顶层；<br>第2次点击的位置只属于1号窗口，因此该次点击选择了1号窗口并将其置于顶层，现在1号窗口在上，2号窗口在下；<br>第3次点击的位置同时属于1号和2号窗口的范围，但由于1号窗口在上，所以它被选择；<br>第4次点击的位置不属于任何窗口。</p><ul><li>解题思路：模拟</li></ul><p>用一个结构体数组存给出的窗口信息，根据题意，数组中越靠后的窗口优先级越高，因此，每次点击从数字后面开始扫描，扫到满足点击的窗口就输出对应的编号，并将它提到末尾。</p><ul><li>参考代码:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=1010;</span><br><span class="line">const int M=1010;</span><br><span class="line">int n,m;</span><br><span class="line"></span><br><span class="line">struct win &#123;</span><br><span class="line">    int id,x,y,w,h;</span><br><span class="line">&#125;wins[N];//存窗口的结构体数组</span><br><span class="line"></span><br><span class="line">//将窗口i置于顶层</span><br><span class="line">void top(int i) &#123;</span><br><span class="line">    win t=wins[i];</span><br><span class="line">    for(;i&lt;n-1;i++) wins[i]=wins[i+1];</span><br><span class="line">    wins[n-1]=t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">    for(int i=0;i&lt;n;i++) &#123;</span><br><span class="line">        scanf(&quot;%d%d%d%d&quot;,&amp;wins[i].x,&amp;wins[i].y,&amp;wins[i].w,&amp;wins[i].h);</span><br><span class="line">        wins[i].id=i+1;</span><br><span class="line">    &#125;</span><br><span class="line">    while(m--) &#123;</span><br><span class="line">        int dx,dy,flag=0;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;dx,&amp;dy);</span><br><span class="line">        for(int i=n-1;i&gt;=0;i--) &#123;</span><br><span class="line">            //判断鼠标点击范围</span><br><span class="line">            if(dx&gt;=wins[i].x&amp;&amp;dy&gt;=wins[i].y&amp;&amp;dx&lt;=wins[i].x+wins[i].w&amp;&amp;dy&lt;=wins[i].y+wins[i].h) &#123;</span><br><span class="line">                printf(&quot;%d\n&quot;,wins[i].id);</span><br><span class="line">                top(i);</span><br><span class="line">                flag=1;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(!flag) printf(&quot;-1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Stern-Brocot-tree"><a href="#Stern-Brocot-tree" class="headerlink" title="Stern-Brocot tree"></a>Stern-Brocot tree</h4><ul><li>描述：</li></ul><p>The Stern-Brocot tree is an infinite complete binary tree in which the vertices correspond one-for-one to the positive rational numbers, whose values are ordered from the left to the right as in a search tree.</p><p><img src="/2019/10/07/netease/pic/001.jpg" alt=""></p><p>Figure 1 shows a part of the Stern-Brocot tree, which has thefirst 4 rows. Each node in the tree is marked in a red cycle. The value in the node is the mediant of the left and right fractions. The mediant of two fractions A/B and C/D is defined as(A+C)/(B+D).<br>To construct the Stern-Brocot tree, we first define the left fraction of the root node is 0/1, and the right fraction of the root node is 1/0. So the value in the root node is the mediant of 0/1 and 1/0, which is(0+1)/(1+0)=1/1. Then the value of root node becomes the right fraction of the left child, and the left fraction of the right child. For example, the 1st node in row2 has 0/1 as its left fraction and 1/1(which is the value of its parent node) as its right fraction. So the value of the 1st node in row2 is (0+1)/(1+1)=1/2. For the same reason, the value of the 2nd node in row2 is (1+1)/(1+0)=2/1. This construction progress goes on infinitly. As a result, everypositive rational number can be found on the Stern-Brocot tree, and can be found only once.<br>Given a rational number in form of P/Q, find the position of P/Q in the Stern-Brocot Tree.</p><ul><li>输入：</li></ul><p>Input consists of two integers,P and Q<br>(1&lt;=P,Q&lt;=1000), which represent the rational number P/Q. We promise P and Q are relatively prime.</p><ul><li>输出：</li></ul><p>Output consists of two integers,R and C.<br>R indicates the row index of P/Q in the stern-Brocot Tree,C indicates the index of P/Q in the row.<br>Both B and C are base 1.<br>We promise the position of P/Q is always in the first 12 rows of the Stern-Brocot tree, which means R&lt;=12.</p><ul><li>样例输入：</li></ul><p>5 3</p><ul><li>样例输出：</li></ul><p>4 6</p><ul><li><p>解题思路：数学+二分</p></li><li><p>参考程序：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct Fraction &#123;</span><br><span class="line">    int m,n;</span><br><span class="line">&#125;sl,sr,input;</span><br><span class="line">int row,col;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int summ,sumn;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;input.m,&amp;input.n);</span><br><span class="line">    if(input.m!=1||input.n!=1) &#123;</span><br><span class="line">       //string ans;</span><br><span class="line">       sl.m=0,sr.m=1;</span><br><span class="line">       sl.n=1,sr.n=0;</span><br><span class="line">       row=1;</span><br><span class="line">       col=1;</span><br><span class="line">       while(1)&#123;</span><br><span class="line">            summ=sl.m+sr.m;</span><br><span class="line">            sumn=sl.n+sr.n;</span><br><span class="line">            int temp=input.m*sumn-input.n*summ;</span><br><span class="line">            if(temp&gt;0)&#123; // input.m/input.n&gt;summ/sumn --&gt; input.m*sumn-input.n*summ&gt;0</span><br><span class="line">                // ans+=&apos;R&apos;;</span><br><span class="line">                row++;</span><br><span class="line">                col*=2;</span><br><span class="line">                sl.m=summ;</span><br><span class="line">                sl.n=sumn;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(temp==0) // input.m/input.n==summ/sumn --&gt; input.m*sumn-input.n*summ==0</span><br><span class="line">                break;</span><br><span class="line">            else&#123; // input.m/input.n&lt;summ/sumn --&gt; input.m*sumn-input.n*summ&lt;0</span><br><span class="line">                // ans+=&apos;L&apos;;</span><br><span class="line">                row++;</span><br><span class="line">                col=2*col-1;</span><br><span class="line">                sr.m=summ;</span><br><span class="line">                sr.n=sumn;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d %d\n&quot;,row,col);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="双人数字游戏"><a href="#双人数字游戏" class="headerlink" title="双人数字游戏"></a>双人数字游戏</h4><ul><li>描述：</li></ul><p>游戏规则如下</p><ul><li><p>在棋盘上有N个数字（A1 ~ AN）从左到右排列成一行</p></li><li><p>A，B两个玩家轮流进行游戏，第一回合A玩家行动，第二回合B玩家行动，依次行动直到游戏结束</p></li><li><p>每回合玩家可以选择拿走棋盘上最左边或者最右边的一个数字，其余的都不能拿</p></li><li><p>拿走的数字依次从左到右排列在自己面前</p></li><li><p>棋盘上所有数字被拿走后游戏结束</p></li><li><p>最优策略的说明：在任意局面下，玩家如果取左边的数字或者取右边的数字，最终最优得分都一样，那么只能取左边的数字</p></li></ul><p>当所有数字都被拿走后，A，B两个玩家面前都各有一个数列。</p><p>假设A玩家面前数字从左到右为X1，X2，X3…XM，则他的最终得分Sa计算方式如下（B玩家的得分计算Sb也类似，不赘述）：<br>Sa=abs(X1-0)+abs(X2-X1)+abs(X3-X2)+..+abs(XM-X(M-1))</p><p>请计算在以上的规则下，如果两个玩家都想拿到尽量多的分数，用最优策略进行游戏，计算两个人的最终得分。</p><ul><li>输入：</li></ul><p>第一行一个数字N，一半的测试用例（0&lt;N&lt;=50），一半的测试用例（0&lt;N&lt;=1000）</p><p>第二行N个数字Ai（0&lt;=Ai&lt;=50）</p><ul><li>输出：</li></ul><p>用空格隔开的两个整数Sa和Sb</p><ul><li>样例输入：</li></ul><p>4<br>1 2 3 4</p><ul><li>样例输出：</li></ul><p>7 4</p><ul><li><p>解题思路：模拟</p></li><li><p>参考程序：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int n, a, k = 1;</span><br><span class="line">deque&lt;int&gt; dq;</span><br><span class="line">int pa = 0, sa = 0, pb = 0, sb = 0;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;a);</span><br><span class="line">        dq.push_back(a);</span><br><span class="line">    &#125;</span><br><span class="line">    while (dq.size()) &#123;</span><br><span class="line">        int left = dq.front();</span><br><span class="line">        int right = dq.back();</span><br><span class="line">        if (k % 2) &#123;</span><br><span class="line">            if (abs(left - pa) &gt;= abs(right - pa)) &#123;</span><br><span class="line">                dq.pop_front();</span><br><span class="line">                sa += abs(left - pa);</span><br><span class="line">                pa = left;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                dq.pop_back();</span><br><span class="line">                sa += abs(right - pa);</span><br><span class="line">                pa = right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            if (abs(left - pb) &gt;= abs(right - pb)) &#123;</span><br><span class="line">                dq.pop_front();</span><br><span class="line">                sb += abs(left - pb);</span><br><span class="line">                pb = left;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                dq.pop_back();</span><br><span class="line">                sb += abs(right - pb);</span><br><span class="line">                pb = right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d %d\n&quot;, sa, sb);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="聊天消息排版"><a href="#聊天消息排版" class="headerlink" title="聊天消息排版"></a>聊天消息排版</h4><ul><li>描述</li></ul><p>在网游中，聊天功能是一项非常重要的功能，加上玩家可以打出游戏内置的一些表情图片，因此需要实现一个图文混排系统，如下图所示。<br>玩家在聊天框输入的是一段utf-8编码的文字，且只会包含中文、英文、中英文的标点符号和空格（不会出现换行、回车和制表符）。按照网易游戏的传统，井号（#）是作为一个转义字符，支持下面几种转义行为：</p><ol><li>#加一个数字来表示内置的表情图片，为了简化问题，我们这里只支持20个表情图片，从0开始计数，并且数字是按最长匹配原则去匹配，比如#0表示0号表情图片、#1表示1号表情图片、#19表示19号表情图片、#20则表示2号表情图片后面加数字0。需要注意的是#00表示的是0号表情图片加后面数字0。</li><li>#r表示换行，遇到以后会自动切换到下一行开始排版。</li><li>##表示显示出#这个符号</li><li>如果玩家不按规则输入错误的转义，则按照玩家的输入原样显示，比如#a、#、#、#啊</li></ol><p><img src="/2019/10/07/netease/pic/002.jpg" alt=""></p><p>上图所示的玩家输入为：“Hello world#大家好#r欢迎大家参加#1祝大家取得好成绩”</p><p>排版的时候需要像上图一样，将文字从起始位置开始，依次显示在聊天窗囗里，一些显示规则如下所示：</p><ol><li><p>聊天窗囗的宽度固定为W像素，起始坐标为左上角，坐标为（0，0），右上角坐标为（W-1，0），坐标向右向下增长。任何文字和表情必须显示在窗口内，不能超出窗口。但是高度可以无限向下延伸。</p></li><li><p>显示的字体均为等宽字体，英文（包括英文标点符号和空格）的字体宽度统一为XE，高度统一为YE。中文（包括中文的标点符号）的字体宽度统一为XC，高度统一为YC。</p></li><li><p>每个表情图片的宽高是独立的，0号表情图片的宽度为X0，高度Y0，依次类推，19号表情图片的宽度为×19，高度为Y19。</p></li><li><p>字符（中英文以及标点符号、空格等，下同）与字符之间、字符与表情之间、表情与表情之间都需要额外保留一个PX像素的字间距。每一行第一个字符左边，以及最后一个字符右边不需要保留字间距。</p></li><li><p>当下一个字符或者表情无法在本行W宽度的像素内完整显示的话，则会强行换到下一行首开始显示。遇到#r的时候也会自动换到下一行开始显示下一个字符或表情。</p></li><li><p>在一行里出现高度不同的中英文以及表情的时候，需要将其底部对齐。</p></li><li><p>当一行里没有任何字符或表情，直接被#r换行的时候，这一行的高度算英文字体的高度。</p></li><li><p>每一行里高度最高的字符或表情，需要同上一行的的底部保留PY像素的行间距。第一行上面与最后一行下面不需要保留行间距。</p></li><li><p>最后一个字符或表情显示显示以后，它的右下角坐标则为结束坐标。也就是本题需要求解的问题。输入保证最后不会以#r结尾。</p></li></ol><ul><li>输入：</li></ul><p>每个测试输入包含1个测试用例<br>第一行为7个正整数w，XE，YE，XC，YC，BX，PY<br>第二行为40个正整数x0，Y0，X1，Y1…X19，Y19<br>第三行为长度不超过10000的十六进制编码过的玩家输入，即玩家输入的utf-8编码的数据每个字节的数字转成大写的十六进制表示，不足两位的话前面补0（同c里printf的%x格式化），然后不同字节的十六进制编码表示依次拼接起来。<br>比如Hello的十六进制编码表示为48656C6C6F。<br>前两行的各个数字含义如上文描述，其中50&lt; w &lt;10000，0&lt;其他&lt;50。</p><ul><li>输出：</li></ul><p>输出用空格隔开的两个数字，表示结束坐标</p><ul><li>输入样例：</li></ul><p>60 2 4 3 4 1 3<br>7 6 7 6 7 6 7 6 7 6 7 6 7 6 7 6 7 6 7 6 7 6 7 6 7 6 7 6 7 6 7 6 7 6 7 6 7 6 7 6<br>48656C6C6F20776F726C6423E5A4A7E5AEB6E5A5B<br>D2372E6ACA2E8BF8EE5A4A7E5AEB6E58F82E58AA0<br>E7BD91E69893E99BB7E781ABE6A0A1E59BADE68B9<br>BE881982331E7A59DE5A4A7E5AEB6E58F96E5BE97<br>E5A5BDE68890E7BBA9</p><ul><li>输出样例：</li></ul><p>38 19</p><ul><li><p>解题思路：模拟</p></li><li><p>参考程序：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="黑客行动"><a href="#黑客行动" class="headerlink" title="黑客行动"></a>黑客行动</h4><ul><li>描述：</li></ul><p>钱老板家的电子保险柜被一个神秘的安保函数y=f(x)保护，每次试图开锁时，系统都会调用安保函数代码输入一个(0,1)之间的浮点数x，如果安保函数能输出正确的y数值则可以打开保险柜，否则就会报警。黑客小军想办法获取到了一份这个安保函数的测试程序，但这个程序并不能在钱老板家的系统上直接运行，必须要重新编码一份新的代码才能使用，请帮助小军实现这个安保函数代码！<br>你可以在以下的URL下载这份测试程序的可执行文件，压缩包里包含windows、linux和macos三个平台下的可执行程序：<br><a href="http://guess.zip" target="_blank" rel="noopener">http://guess.zip</a></p><ul><li>输入：</li></ul><p>一个(0,1)的浮点数，精确到小数点后6位</p><ul><li>输出：</li></ul><p>一个浮点数，精确到小数点后6位</p><ul><li>输入样例：</li></ul><p>0.268044</p><ul><li>输出样例：</li></ul><p>2.681916</p><ul><li>备注：</li></ul><p>本题的判题标准，如果你的代码输出的结果四舍五入到小数点后5位与标准答案四舍五入到小数点后5位一致就算正确</p><ul><li><p>解题思路：</p></li><li><p>参考程序：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;窗口点击模拟&quot;&gt;&lt;a href=&quot;#窗口点击模拟&quot; class=&quot;headerlink&quot; title=&quot;窗口点击模拟&quot;&gt;&lt;/a&gt;窗口点击模拟&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;描述：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本题需要让你模拟一下在Windows系统里窗囗和鼠标点击的操作，具体如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;屏幕分辨率为3840 * 2160，左上角坐标为（0，0），右下角坐标为（3839，2159）&lt;/li&gt;
&lt;li&gt;窗口是一个矩形的形状，由左上角坐标（X，Y），和宽高（W，H），四个数字来定位。左上角坐标为（X，Y）、右下角坐标为（X+W，Y+H），其中左上角坐标一定会在屏幕范围内，其他一些部分可能会超过屏幕范围。&lt;/li&gt;
&lt;li&gt;窗囗的点击和遮挡规则同Windows，但是不考虑关闭窗囗、最大化、最小化和强制置顶的情况。即&lt;br&gt; 3.1 如果发生重叠的话，后面打开的窗口会显示在前面打开的窗口上面&lt;br&gt; 3.2 当鼠标发生一次点击的时候，需要判断点击到了哪个窗口，如果同个坐标有多个窗口，算点击到最上层的那个&lt;br&gt; 3.3 当一个窗囗被点击的时候，会浮动到最上层&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://e99net.github.io/categories/Algorithm/"/>
    
    
      <category term="Dynamic Programming" scheme="https://e99net.github.io/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>洛谷的刷题日常之P1967</title>
    <link href="https://e99net.github.io/2019/10/06/luogu_P1967/"/>
    <id>https://e99net.github.io/2019/10/06/luogu_P1967/</id>
    <published>2019-10-06T11:02:59.655Z</published>
    <updated>2019-10-06T11:54:02.534Z</updated>
    
    <content type="html"><![CDATA[<h4 id="货车运输"><a href="#货车运输" class="headerlink" title="货车运输"></a>货车运输</h4><p>这是一道比较综合的题，非常的niubility（我不会做的题都niubility，QWQ），用到的知识包括图论、倍增、贪心、LCA、生成树、并查集。</p><ul><li>描述：</li></ul><p>A国有n座城市，编号从1到n，城市之间有m条双向道路。每一条道路对车辆都有重量限制，简称限重。现在有q辆货车在运输货物， 司机们想知道每辆车在不超过车辆限重的情况下，最多能运多重的货物。</p><a id="more"></a><ul><li>输入：</li></ul><p>第一行有两个用空格隔开的整数n和m，表示A国有n座城市和m条道路。<br>接下来的m行，每行有3个整数x,y,z，每两个整数之间用一个空格隔开，表示从x号城市到y号城市有一条限重为z的道路。<br>注意：x不等于 y，两座城市之间可能有多条道路。</p><p>接下来一行有一个整数q，表示有q辆货车需要运货。</p><p>接下来的q行，每行有两个整数x、y，用一个空格隔开，表示一辆货车需要从x城市运输货物到y城市。<br>注意：x不等于y。</p><ul><li>输出：</li></ul><p>共有q行，每行一个整数，表示对于每一辆货车，它的最大载重是多少。如果货车不能到达目的地，输出-1。</p><ul><li>输入样例：</li></ul><p>4 3<br>1 2 4<br>2 3 3<br>3 1 1<br>3<br>1 3<br>1 4<br>1 3</p><ul><li>输出样例：</li></ul><p>3<br>-1<br>3</p><ul><li><p>解题思路：</p><ul><li>贪心：因为要使得货车运的货物尽可能重，所以权值较小的边不会被走过。</li><li>图论：根据给出的数据建原始图，然后根据上一步的贪心策略建新图，构造最大生成树。</li><li>生成树：构造最大生成树可以使用Kruskal算法。</li><li>并查集：Kruskal算法可以用并查集维护节点的连通情况。</li><li>LCA：在最大生成树上求最近公共祖先，得到两个节点之间最小边权的最大值，即题中的最大载重。</li><li>倍增：树上倍增法求LCA。</li></ul></li><li><p>参考代码：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define INF 0x3f3f3f3f</span><br><span class="line"></span><br><span class="line">struct road &#123;</span><br><span class="line">    int x,y,z;</span><br><span class="line">&#125;roads[50010];//原始图</span><br><span class="line"></span><br><span class="line">struct edge &#123;</span><br><span class="line">    int to,next,w;</span><br><span class="line">&#125;edges[50010];//存储最大生成树的新图</span><br><span class="line"></span><br><span class="line">//fa数组表示并查集中的父节点，f数组表示树上的父节点，w数组表示最大载重 </span><br><span class="line">int x,y,cnt,head[10010],fa[10010],f[10010][21],deep[10010],w[10010][21],n,m,q;</span><br><span class="line">bool vis[10010];</span><br><span class="line"></span><br><span class="line">//自定义排序规则，边权大的在前面</span><br><span class="line">bool cmp(road x,road y) &#123;</span><br><span class="line">    return x.z&gt;y.z;</span><br><span class="line">&#125;</span><br><span class="line">//前向星存新图</span><br><span class="line">void addroad(int start,int end,int w) &#123;</span><br><span class="line">    edges[++cnt].next=head[start];</span><br><span class="line">    edges[cnt].to=end;</span><br><span class="line">    edges[cnt].w=w;</span><br><span class="line">    head[start]=cnt;</span><br><span class="line">&#125;</span><br><span class="line">//并查集的查找操作</span><br><span class="line">int Find(int x) &#123;</span><br><span class="line">    if(x!=fa[x]) fa[x]=Find(fa[x]);</span><br><span class="line">    return fa[x];</span><br><span class="line">&#125;</span><br><span class="line">//Kruskal算法</span><br><span class="line">void kruskal() &#123;</span><br><span class="line">    sort(roads+1,roads+m+1,cmp);</span><br><span class="line">    for(int i=1;i&lt;=n;i++) fa[i]=i;//并查集的初始化操作</span><br><span class="line">    for(int i=1;i&lt;=m;i++) &#123;</span><br><span class="line">        //并查集的合并操作</span><br><span class="line">        int a=Find(roads[i].x);</span><br><span class="line">        int b=Find(roads[i].y);</span><br><span class="line">        if(a!=b) &#123;</span><br><span class="line">            fa[a]=b;</span><br><span class="line">            //无向图，双向边</span><br><span class="line">            addroad(roads[i].x,roads[i].y,roads[i].z);</span><br><span class="line">            addroad(roads[i].y,roads[i].x,roads[i].z);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//预处理：从根节点进行搜索，求节点深度</span><br><span class="line">void dfs(int node) &#123;</span><br><span class="line">    vis[node]=true;</span><br><span class="line">    for(int i=head[node];i;i=edges[i].next) &#123;//前向星遍历</span><br><span class="line">        int to=edges[i].to;</span><br><span class="line">        if(vis[to]) continue;</span><br><span class="line">        deep[to]=deep[node]+1;//计算深度</span><br><span class="line">        f[to][0]=node;//存父节点</span><br><span class="line">        w[to][0]=edges[i].w;//存节点到父节点的权值</span><br><span class="line">        dfs(to);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//树上倍增法优化求解LCA问题</span><br><span class="line">int lca(int x,int y) &#123;</span><br><span class="line">    int a=Find(x);</span><br><span class="line">    int b=Find(y);</span><br><span class="line">    if(a!=b) return -1;//不连通输出-1</span><br><span class="line">    int ans=INF;</span><br><span class="line">    if(deep[x]&gt;deep[y]) swap(x,y);//始终使得y节点更深</span><br><span class="line">    //将y节点提到与x节点相同的深度</span><br><span class="line">    for(int i=20;i&gt;=0;i--) &#123;</span><br><span class="line">        if(deep[f[y][i]]&gt;=deep[x]) &#123;</span><br><span class="line">            ans=min(ans,w[y][i]);//更新最大载重（最小边权）</span><br><span class="line">            y=f[y][i];//修改y的位置</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(x==y) return ans;//如果位置已经相等，直接返回答案</span><br><span class="line">    //寻找公共祖先</span><br><span class="line">    for(int i=20;i&gt;=0;i--) &#123;</span><br><span class="line">        if(f[x][i]!=f[y][i]) &#123;</span><br><span class="line">            ans=min(ans,min(w[x][i],w[y][i]));//更新最大载重（最小边权）</span><br><span class="line">            x=f[x][i];//修改x的位置</span><br><span class="line">            y=f[y][i];//修改y的位置</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans=min(ans,min(w[x][0],w[y][0]));//更新x,y到公共祖先的最大载重，fa[x][0]、fa[y][0]即为公共祖先 </span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">    for(int i=1;i&lt;=m;i++) &#123;//存原始图</span><br><span class="line">        scanf(&quot;%d%d%d&quot;,&amp;roads[i].x,&amp;roads[i].y,&amp;roads[i].z);</span><br><span class="line">    &#125;</span><br><span class="line">    kruskal();</span><br><span class="line">    for(int i=1;i&lt;=n;i++) &#123;//预处理</span><br><span class="line">        if(!vis[i]) &#123;</span><br><span class="line">            deep[i]=1;</span><br><span class="line">            dfs(i);</span><br><span class="line">            f[i][0]=i;</span><br><span class="line">            w[i][0]=INF;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //LCA初始化</span><br><span class="line">    for(int i=1;i&lt;=20;i++) &#123;</span><br><span class="line">        for(int j=1;j&lt;=n;j++) &#123;</span><br><span class="line">            f[j][i]=f[f[j][i-1]][i-1];</span><br><span class="line">            w[j][i]=min(w[j][i-1],w[f[j][i-1]][i-1]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;q);</span><br><span class="line">    for(int i=1;i&lt;=q;i++) &#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;x,&amp;y);</span><br><span class="line">        printf(&quot;%d\n&quot;,lca(x,y));//O(logn)复杂度回答询问</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;货车运输&quot;&gt;&lt;a href=&quot;#货车运输&quot; class=&quot;headerlink&quot; title=&quot;货车运输&quot;&gt;&lt;/a&gt;货车运输&lt;/h4&gt;&lt;p&gt;这是一道比较综合的题，非常的niubility（我不会做的题都niubility，QWQ），用到的知识包括图论、倍增、贪心、LCA、生成树、并查集。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;描述：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A国有n座城市，编号从1到n，城市之间有m条双向道路。每一条道路对车辆都有重量限制，简称限重。现在有q辆货车在运输货物， 司机们想知道每辆车在不超过车辆限重的情况下，最多能运多重的货物。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://e99net.github.io/categories/Algorithm/"/>
    
    
      <category term="Graph theory" scheme="https://e99net.github.io/tags/Graph-theory/"/>
    
      <category term="LCA" scheme="https://e99net.github.io/tags/LCA/"/>
    
      <category term="Greedy" scheme="https://e99net.github.io/tags/Greedy/"/>
    
      <category term="Union-Find Set" scheme="https://e99net.github.io/tags/Union-Find-Set/"/>
    
      <category term="Spanning tree" scheme="https://e99net.github.io/tags/Spanning-tree/"/>
    
      <category term="Doubling" scheme="https://e99net.github.io/tags/Doubling/"/>
    
  </entry>
  
  <entry>
    <title>洛谷的刷题日常之P1147</title>
    <link href="https://e99net.github.io/2019/10/05/luogu_P1147/"/>
    <id>https://e99net.github.io/2019/10/05/luogu_P1147/</id>
    <published>2019-10-04T16:15:38.897Z</published>
    <updated>2019-10-04T16:23:29.233Z</updated>
    
    <content type="html"><![CDATA[<h4 id="连续自然数和"><a href="#连续自然数和" class="headerlink" title="连续自然数和"></a>连续自然数和</h4><ul><li>描述：</li></ul><p>对一个给定的自然数$M$，求出所有的连续的自然数段，这些连续的自然数段中的全部数之和为$M$。<br>例子：1998+1999+2000+2001+2002 = 10000，所以从1998到2002的一个自然数段为$M=10000$的一个解。</p><a id="more"></a><ul><li>输入：</li></ul><p>包含一个整数的单独一行给出M的值（$10 \le M \le 2000000$）。</p><ul><li>输出：</li></ul><p>每行两个自然数，给出一个满足条件的连续自然数段中的第一个数和最后一个数，两数之间用一个空格隔开，所有输出行的第一个按从小到大的升序排列，对于给定的输入数据，保证至少有一个解。</p><ul><li>输入样例：</li></ul><p>10000</p><ul><li>输出样例：</li></ul><p>18 142<br>297 328<br>388 412<br>1998 2002</p><ul><li><p>解题思路：前缀和+二分</p></li><li><p>参考代码:</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define ll long long</span><br><span class="line">ll sum[2000010];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    ll m;</span><br><span class="line">    scanf(&quot;%lld&quot;,&amp;m);</span><br><span class="line">    for(int i=1;i&lt;=m;i++)  sum[i]=sum[i-1]+i;</span><br><span class="line">    for(int i=1;i&lt;=m-1;i++) &#123;</span><br><span class="line">        ll l=i,r=m-1,mid;</span><br><span class="line">        while(l&lt;=r) &#123;</span><br><span class="line">            mid=(l+r)/2;</span><br><span class="line">            ll t=sum[mid]-sum[i-1];</span><br><span class="line">            if(t==m) &#123;</span><br><span class="line">                printf(&quot;%d %d\n&quot;,i,mid);</span><br><span class="line">                break;</span><br><span class="line">            &#125;else if(t&lt;m) &#123;</span><br><span class="line">                l=mid+1;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                r=mid-1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;连续自然数和&quot;&gt;&lt;a href=&quot;#连续自然数和&quot; class=&quot;headerlink&quot; title=&quot;连续自然数和&quot;&gt;&lt;/a&gt;连续自然数和&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;描述：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对一个给定的自然数$M$，求出所有的连续的自然数段，这些连续的自然数段中的全部数之和为$M$。&lt;br&gt;例子：1998+1999+2000+2001+2002 = 10000，所以从1998到2002的一个自然数段为$M=10000$的一个解。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://e99net.github.io/categories/Algorithm/"/>
    
    
      <category term="Prefix Sum" scheme="https://e99net.github.io/tags/Prefix-Sum/"/>
    
      <category term="Binary Search" scheme="https://e99net.github.io/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>记两道2020年某企业秋招的算法编程题</title>
    <link href="https://e99net.github.io/2019/09/26/tourSohu/"/>
    <id>https://e99net.github.io/2019/09/26/tourSohu/</id>
    <published>2019-09-26T12:07:20.889Z</published>
    <updated>2019-10-06T16:20:53.349Z</updated>
    
    <content type="html"><![CDATA[<h4 id="专业题1"><a href="#专业题1" class="headerlink" title="专业题1"></a>专业题1</h4><ul><li>描述：</li></ul><p>一个k（1&lt;=k&lt;=80）位的十进制整数n，我们称其为大整数。现在的问题是，请你设计一个程序，对于给出的某个大整数，找到满足条件p^3+p^2+3 * p&lt;=n的p的最大值。</p><a id="more"></a><ul><li>输入：</li></ul><p>一个大整数n。</p><ul><li>输出：</li></ul><p>一个符合条件的答案值。</p><ul><li>样例输入1：</li></ul><p>1908</p><ul><li>样例输出1：</li></ul><p>12</p><ul><li>样例输入2：</li></ul><p>8620110</p><ul><li>样例输出2：</li></ul><p>204</p><ul><li><p>解题思路：高精度+二分</p></li><li><p>参考代码:</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#偷懒的Python代码</span><br><span class="line">def f(x):</span><br><span class="line">    return x*x*x+x*x+3*x</span><br><span class="line">num=int(input())</span><br><span class="line">left=0;</span><br><span class="line">right=num;</span><br><span class="line">mid=0;</span><br><span class="line">mark=0</span><br><span class="line">while left&lt;right:</span><br><span class="line">    mid=int((left+right)/2)</span><br><span class="line">    #print(&quot;midzhi &quot;,mid)</span><br><span class="line">    fx=f(mid)</span><br><span class="line">    if fx==num:</span><br><span class="line">        ans=mid</span><br><span class="line">        mark=1</span><br><span class="line">        break</span><br><span class="line">    elif fx&gt;num:</span><br><span class="line">        right=mid </span><br><span class="line">    else:</span><br><span class="line">        left=mid+1</span><br><span class="line">if mark==0:</span><br><span class="line">    ans=left-1</span><br><span class="line">print(ans)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int MAXN = 2000;</span><br><span class="line"></span><br><span class="line">struct bign &#123;</span><br><span class="line">    int len, s[MAXN];</span><br><span class="line">    bign () &#123;</span><br><span class="line">        memset(s, 0, sizeof(s));</span><br><span class="line">        len = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    bign (int num) &#123; </span><br><span class="line">        *this = num; </span><br><span class="line">    &#125;</span><br><span class="line">    bign (const char *num) &#123; </span><br><span class="line">        *this = num;</span><br><span class="line">    &#125;</span><br><span class="line">    int operator [] (int a) &#123;</span><br><span class="line">        return s[a];</span><br><span class="line">    &#125;</span><br><span class="line">    bign operator = (const int num) &#123;</span><br><span class="line">        char s[MAXN];</span><br><span class="line">        sprintf(s, &quot;%d&quot;, num);</span><br><span class="line">        *this = s;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">    bign operator = (const char *num) &#123;</span><br><span class="line">        for(int i = 0; num[i] == &apos;0&apos;; num++) ;</span><br><span class="line">        len = strlen(num);</span><br><span class="line">        for(int i = 0; i &lt; len; i++) s[i] = num[len-i-1] - &apos;0&apos;;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">    bign operator + (const bign &amp;b) const &#123;</span><br><span class="line">        bign c;</span><br><span class="line">        c.len = 0;</span><br><span class="line">        for(int i = 0, g = 0; g || i &lt; max(len, b.len); i++) &#123;</span><br><span class="line">            int x = g;</span><br><span class="line">            if(i &lt; len) x += s[i];</span><br><span class="line">            if(i &lt; b.len) x += b.s[i];</span><br><span class="line">            c.s[c.len++] = x % 10;</span><br><span class="line">            g = x / 10;</span><br><span class="line">        &#125;</span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line">    bign operator += (const bign &amp;b) &#123;</span><br><span class="line">        *this = *this + b;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">    void clean() &#123;</span><br><span class="line">        while(len &gt; 1 &amp;&amp; !s[len-1]) len--;</span><br><span class="line">    &#125;</span><br><span class="line">    bign operator * (const bign &amp;b)</span><br><span class="line">    &#123;</span><br><span class="line">        bign c;</span><br><span class="line">        c.len = len + b.len;</span><br><span class="line">        for(int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">            for(int j = 0; j &lt; b.len; j++) &#123;</span><br><span class="line">                c.s[i+j] += s[i] * b.s[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; c.len; i++) &#123;</span><br><span class="line">            c.s[i+1] += c.s[i]/10;</span><br><span class="line">            c.s[i] %= 10;</span><br><span class="line">        &#125;</span><br><span class="line">        c.clean();</span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line">    bign operator *= (const bign &amp;b) &#123;</span><br><span class="line">        *this = *this * b;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">    bign operator - (const bign &amp;b) &#123;</span><br><span class="line">        bign c;</span><br><span class="line">        c.len = 0;</span><br><span class="line">        for(int i = 0, g = 0; i &lt; len; i++) &#123;</span><br><span class="line">            int x = s[i] - g;</span><br><span class="line">            if(i &lt; b.len) x -= b.s[i];</span><br><span class="line">            if(x &gt;= 0) g = 0;</span><br><span class="line">            else &#123;</span><br><span class="line">                g = 1;</span><br><span class="line">                x += 10;</span><br><span class="line">            &#125;</span><br><span class="line">            c.s[c.len++] = x;</span><br><span class="line">        &#125;</span><br><span class="line">        c.clean();</span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line">    bign operator -= (const bign &amp;b) &#123;</span><br><span class="line">        *this = *this - b;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">    bign operator / (const bign &amp;b) &#123;</span><br><span class="line">        bign c, f = 0;</span><br><span class="line">        for(int i = len-1; i &gt;= 0; i--) &#123;</span><br><span class="line">            f = f*10;</span><br><span class="line">            f.s[0] = s[i];</span><br><span class="line">            while(f &gt;= b) &#123;</span><br><span class="line">                f -= b;</span><br><span class="line">                c.s[i]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        c.len = len;</span><br><span class="line">        c.clean();</span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line">    bign operator /= (const bign &amp;b) &#123;</span><br><span class="line">        *this = *this / b;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">    bign operator % (const bign &amp;b) &#123;</span><br><span class="line">        bign r = *this / b;</span><br><span class="line">        r = *this - r*b;</span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br><span class="line">    bign operator %= (const bign &amp;b) &#123;</span><br><span class="line">        *this = *this % b;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">    bign operator ++() &#123;</span><br><span class="line">        return *this+=1;</span><br><span class="line">    &#125;</span><br><span class="line">    bign operator --() &#123;</span><br><span class="line">        return *this-=1;</span><br><span class="line">    &#125;</span><br><span class="line">    bool operator &lt; (const bign &amp;b) &#123;</span><br><span class="line">        if(len != b.len) return len &lt; b.len;</span><br><span class="line">        for(int i = len-1; i &gt;= 0; i--) &#123;</span><br><span class="line">            if(s[i] != b.s[i]) return s[i] &lt; b.s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    bool operator &gt; (const bign &amp;b) &#123;</span><br><span class="line">        if(len != b.len) return len &gt; b.len;</span><br><span class="line">        for(int i = len-1; i &gt;= 0; i--) &#123;</span><br><span class="line">            if(s[i] != b.s[i]) return s[i] &gt; b.s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    bool operator == (const bign &amp;b) &#123;</span><br><span class="line">        return !(*this &gt; b) &amp;&amp; !(*this &lt; b);</span><br><span class="line">    &#125;</span><br><span class="line">    bool operator != (const bign &amp;b) &#123;</span><br><span class="line">        return !(*this == b);</span><br><span class="line">    &#125;</span><br><span class="line">    bool operator &lt;= (const bign &amp;b) &#123;</span><br><span class="line">        return *this &lt; b || *this == b;</span><br><span class="line">    &#125;</span><br><span class="line">    bool operator &gt;= (const bign &amp;b) &#123;</span><br><span class="line">        return *this &gt; b || *this == b;</span><br><span class="line">    &#125;</span><br><span class="line">    bign operator !() &#123;</span><br><span class="line">        bign s=1;</span><br><span class="line">        for(bign i=1;i&lt;=*this;++i)</span><br><span class="line">            s*=i; return s;</span><br><span class="line">    &#125;</span><br><span class="line">    bign operator ^ (const bign&amp; b) &#123;</span><br><span class="line">        bign s=1;</span><br><span class="line">        for(bign i=0;i&lt;b;++i)</span><br><span class="line">            s*=*this;return s;</span><br><span class="line">    &#125;</span><br><span class="line">    bign sqrt() &#123;</span><br><span class="line">        bign c=*this/2;</span><br><span class="line">        while((c*c)&gt;*this) c/=2;</span><br><span class="line">        while((c*c)&lt;=*this) ++c;</span><br><span class="line">        return c-1;</span><br><span class="line">    &#125;</span><br><span class="line">    /*string operator *()&#123;</span><br><span class="line">        string op=&quot;Hello World&quot;;</span><br><span class="line">        return op;</span><br><span class="line">    &#125;*/</span><br><span class="line">    string str() const &#123;</span><br><span class="line">        string res = &quot;&quot;;</span><br><span class="line">        for(int i = 0; i &lt; len; i++) res = char(s[i]+&apos;0&apos;) + res;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">istream&amp; operator &gt;&gt; (istream &amp;in, bign &amp;x) &#123;</span><br><span class="line">    string s;</span><br><span class="line">    in &gt;&gt; s;</span><br><span class="line">    x = s.c_str();</span><br><span class="line">    return in;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream&amp; operator &lt;&lt; (ostream &amp;out, const bign &amp;x) &#123;</span><br><span class="line">    out &lt;&lt; x.str();</span><br><span class="line">    return out;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    // bign a,b;</span><br><span class="line">    // cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    // cout&lt;&lt;a+b;</span><br><span class="line">    bign left=0,n,mid,value,ans;</span><br><span class="line">    int mark=0;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    bign right=n;</span><br><span class="line">    while(left&lt;right) &#123;</span><br><span class="line">        mid=(left+right)/2;</span><br><span class="line">        value=mid*mid*mid+mid*mid+(bign)3*mid;</span><br><span class="line">        if(value==n) &#123;</span><br><span class="line">            ans=mid;mark=1;break;</span><br><span class="line">        &#125;else if(value&gt;n) &#123;</span><br><span class="line">            right=mid;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            left=mid+1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(mark==0) ans=left-1;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="专业题2"><a href="#专业题2" class="headerlink" title="专业题2"></a>专业题2</h4><ul><li>描述：</li></ul><p>在一个棋盘上有N个处于不同位置的棋子，每个棋子所在的位置都可以用坐标(X,Y)来表示，并且任一棋子每次可以向上、下、左、右移动单位长度。如果想让所有棋子进入一个水平线，彼此靠近，即它们最后的位置是(X,Y)、(X+1,Y)、……、(X+N,Y)，水平线上棋子的最后顺序是任意的，那么最少需要移动多少次棋子？<br>注意：两个或两个以上的棋子不能在同一时间处于同一位置。</p><ul><li>输入：</li></ul><p>第一行是一个整数N，表示棋子数，1&lt;=N&lt;=10000。后面的N行分别是每个棋子的初始位置，包含空格分开的整数x、y，-10000&lt;=x,y&lt;=10000。</p><ul><li>输出：</li></ul><p>仅有一行一个值，表示使棋子移到水平线彼此相邻位置的最小移动次数。</p><ul><li>样例输入：</li></ul><p>5<br>1 2<br>2 2<br>1 3<br>3 -2<br>3 3</p><ul><li>样例输出：</li></ul><p>8</p><ul><li><p>解题思路：中位数</p></li><li><p>参考代码:</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int a[10010],b[10010],n,i,x,y,ans;</span><br><span class="line">int main() &#123;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(i=1;i&lt;=n;i++) scanf(&quot;%d%d&quot;,&amp;a[i],&amp;b[i]);</span><br><span class="line">    sort(b+1,b+n+1);</span><br><span class="line">    y=b[n+1&gt;&gt;1];</span><br><span class="line">    sort(a+1,a+n+1);</span><br><span class="line">    for(i=1;i&lt;=n;i++) a[i]-=i;</span><br><span class="line">    sort(a+1,a+n+1);</span><br><span class="line">    x=a[n+1&gt;&gt;1]; </span><br><span class="line">    for(i=1;i&lt;=n;i++) ans+=abs(a[i]-x)+abs(b[i]-y);</span><br><span class="line">    printf(&quot;%d\n&quot;,ans); </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;专业题1&quot;&gt;&lt;a href=&quot;#专业题1&quot; class=&quot;headerlink&quot; title=&quot;专业题1&quot;&gt;&lt;/a&gt;专业题1&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;描述：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一个k（1&amp;lt;=k&amp;lt;=80）位的十进制整数n，我们称其为大整数。现在的问题是，请你设计一个程序，对于给出的某个大整数，找到满足条件p^3+p^2+3 * p&amp;lt;=n的p的最大值。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://e99net.github.io/categories/Algorithm/"/>
    
    
      <category term="Number theory" scheme="https://e99net.github.io/tags/Number-theory/"/>
    
  </entry>
  
  <entry>
    <title>洛谷的刷题日常之P1880</title>
    <link href="https://e99net.github.io/2019/09/24/luogu_P1880/"/>
    <id>https://e99net.github.io/2019/09/24/luogu_P1880/</id>
    <published>2019-09-24T03:16:45.340Z</published>
    <updated>2019-10-06T12:12:45.330Z</updated>
    
    <content type="html"><![CDATA[<h4 id="石子合并"><a href="#石子合并" class="headerlink" title="石子合并"></a>石子合并</h4><p>先看一道比luogu p1880简单的题目。</p><ul><li>描述：</li></ul><p>有n堆石子排成一排，每堆石子有一定的数量，将n堆石子合并成一堆。合并的规则是每次只能合并相邻的两堆石子，合并的花费为这两堆石子的总数。石子经过n-1次合并后成为一堆，求总的最小花费和最大花费。</p><a id="more"></a><ul><li>输入：</li></ul><p>有多组测试数据，输入到文件结束。每组测试数据的第1行有一个整数n，表示有n堆石子，n&lt;250。接下来的一行有n个数，分别表示这n堆石子的数目。每堆石子至少一颗，最多10000颗。</p><ul><li>输出：</li></ul><p>总的最小花费和最大花费。</p><ul><li>输入样例：</li></ul><p>3<br>2 4 5</p><ul><li>输出样例：</li></ul><p>17<br>20</p><ul><li><p>解题思路：区间DP</p></li><li><p>参考代码:</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int INF=1&lt;&lt;30;</span><br><span class="line">const int N=300;</span><br><span class="line">int n,sum[N];</span><br><span class="line"></span><br><span class="line">int Minval()&#123;</span><br><span class="line">    int dp[N][N]；</span><br><span class="line">    for(int i=1;i&lt;=n;i++) dp[i][i]=0;</span><br><span class="line">    for(int len=1;len&lt;n;len++)</span><br><span class="line">        for(int i=1;i&lt;=n-len;i++) &#123;</span><br><span class="line">            int j=i+len;</span><br><span class="line">            dp[i][j]=INF;</span><br><span class="line">            for(int k=i;k&lt;j;k++)</span><br><span class="line">                dp[i][j]=min(dp[i][j],dp[i][k]+dp[k+1][j]+sum[j]-sum[i-1]);</span><br><span class="line">        &#125;</span><br><span class="line">    return dp[1][n];</span><br><span class="line">&#125;</span><br><span class="line">int Maxval()&#123;</span><br><span class="line">    int dp[N][N];</span><br><span class="line">    for(int i=1;i&lt;=n;i++) dp[i][i]=0;</span><br><span class="line">    for(int len=1;len&lt;n;len++)</span><br><span class="line">        for(int i=1;i&lt;=n-len;i++) &#123;</span><br><span class="line">            int j=i+len;</span><br><span class="line">            dp[i][j]=-INF;</span><br><span class="line">            for(int k=i;k&lt;j;k++)</span><br><span class="line">                dp[i][j]=max(dp[i][j],dp[i][k]+dp[k+1][j]+sum[j]-sum[i-1]);</span><br><span class="line">        &#125;</span><br><span class="line">    return dp[1][n];</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    sum[0]=0;</span><br><span class="line">    for(int i=1;i&lt;=n;i++) &#123;</span><br><span class="line">        int x;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">        sum[i]=sum[i-1]+x;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n%d&quot;,Minval(),Maxval());</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="环形石子合并"><a href="#环形石子合并" class="headerlink" title="环形石子合并"></a>环形石子合并</h4><p>接下来就可以着手解决luogu p1880了。如果按照上面的解法解这道题，会出现“min值永远比正确答案大1”的“奇怪”现象，这是因为没有考虑环形的缘故。</p><ul><li>描述：</li></ul><p>在一个圆形操场的四周摆放N堆石子,现要将石子有次序地合并成一堆.规定每次只能选相邻的2堆合并成新的一堆，并将新的一堆的石子数，记为该次合并的得分。</p><p>试设计出1个算法,计算出将N堆石子合并成1堆的最小得分和最大得分.</p><!-- more --><ul><li>输入：</li></ul><p>数据的第1行试正整数N,1≤N≤100,表示有N堆石子.第2行有N个数,分别表示每堆石子的个数.</p><ul><li>输出：</li></ul><p>输出共2行,第1行为最小得分,第2行为最大得分.</p><ul><li>输入样例：</li></ul><p>4<br>4 5 9 4</p><ul><li>输出样例：</li></ul><p>43<br>54</p><ul><li><p>解题思路：</p><ul><li>区间DP</li><li>处理环形情况的通用套路：在任意位置把环断开成链，复制一倍接在末尾</li></ul></li><li><p>参考代码:</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int INF=1&lt;&lt;30;</span><br><span class="line">const int N=240;</span><br><span class="line">int n,sum[N],x,arr[N];</span><br><span class="line"></span><br><span class="line">int Minval()&#123;</span><br><span class="line">    int dp[N][N],ans=INF;</span><br><span class="line">    for(int i=1;i&lt;=n;i++) dp[i][i]=0;</span><br><span class="line">    for(int len=1;len&lt;n;len++)</span><br><span class="line">        for(int i=1;i&lt;=2*n-len;i++) &#123;</span><br><span class="line">            int j=i+len;</span><br><span class="line">            dp[i][j]=INF;</span><br><span class="line">            for(int k=i;k&lt;j;k++)</span><br><span class="line">                dp[i][j]=min(dp[i][j],dp[i][k]+dp[k+1][j]+sum[j]-sum[i-1]);</span><br><span class="line">        &#125;</span><br><span class="line">    for(int i=1;i&lt;=n;i++) &#123;</span><br><span class="line">        ans=ans&gt;dp[i][i+n-1]?dp[i][i+n-1]:ans;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int Maxval()&#123;</span><br><span class="line">    int dp[N][N],ans=-INF;</span><br><span class="line">    for(int i=1;i&lt;=n;i++) dp[i][i]=0;</span><br><span class="line">    for(int len=1;len&lt;n;len++)</span><br><span class="line">        for(int i=1;i&lt;=2*n-len;i++) &#123;</span><br><span class="line">            int j=i+len;</span><br><span class="line">            dp[i][j]=-INF;</span><br><span class="line">            for(int k=i;k&lt;j;k++)</span><br><span class="line">                dp[i][j]=max(dp[i][j],dp[i][k]+dp[k+1][j]+sum[j]-sum[i-1]);</span><br><span class="line">        &#125;</span><br><span class="line">    for(int i=1;i&lt;=n;i++) &#123;</span><br><span class="line">        ans=ans&lt;dp[i][i+n-1]?dp[i][i+n-1]:ans;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    sum[0]=0;</span><br><span class="line">    for(int i=1;i&lt;=n;i++) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;arr[i]);</span><br><span class="line">        arr[i+n]=arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=2*n;i++) &#123;</span><br><span class="line">        sum[i]=sum[i-1]+arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n%d&quot;,Minval(),Maxval());</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>相似题目：</li></ul><p>hdu 3506 “Monkey Party”</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;石子合并&quot;&gt;&lt;a href=&quot;#石子合并&quot; class=&quot;headerlink&quot; title=&quot;石子合并&quot;&gt;&lt;/a&gt;石子合并&lt;/h4&gt;&lt;p&gt;先看一道比luogu p1880简单的题目。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;描述：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有n堆石子排成一排，每堆石子有一定的数量，将n堆石子合并成一堆。合并的规则是每次只能合并相邻的两堆石子，合并的花费为这两堆石子的总数。石子经过n-1次合并后成为一堆，求总的最小花费和最大花费。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://e99net.github.io/categories/Algorithm/"/>
    
    
      <category term="Dynamic Programming" scheme="https://e99net.github.io/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>记三道2020年某企业秋招笔试题</title>
    <link href="https://e99net.github.io/2019/09/24/cmbcc/"/>
    <id>https://e99net.github.io/2019/09/24/cmbcc/</id>
    <published>2019-09-24T02:30:06.499Z</published>
    <updated>2019-10-06T16:19:31.270Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-n-中每位数字乘积最大的值"><a href="#1-n-中每位数字乘积最大的值" class="headerlink" title="1 ~ n 中每位数字乘积最大的值"></a>1 ~ n 中每位数字乘积最大的值</h4><ul><li>描述：</li></ul><p>99°是一位爱好爬山的小青年，他每次在爬山过程中都会遇到很多小猴子，小猴子们喜欢向他提这样一种问题：在1 ~ n中找一个数字m，使得m的各个数位乘积最大。99°不擅长回答这种问题，你能帮他写一个程序得到结果吗？</p><a id="more"></a><ul><li>样例输入1：</li></ul><p>100</p><ul><li>样例输出1：</li></ul><p>81</p><p>提示：9 * 9 = 81</p><ul><li>样例输入2：</li></ul><p>6</p><ul><li>样例输出2：</li></ul><p>6</p><ul><li><p>解题思路：深度优先搜索</p></li><li><p>参考代码:</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define ll long long</span><br><span class="line"></span><br><span class="line">ll dfs(int n) &#123;</span><br><span class="line">    if(n==0) return 1;</span><br><span class="line">    if(n&lt;10) return n;</span><br><span class="line">    else return max(dfs(n/10-1)*9,dfs(n/10)*(n%10));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    printf(&quot;%lld&quot;,dfs(n));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="完成可能有前置任务的任务"><a href="#完成可能有前置任务的任务" class="headerlink" title="完成可能有前置任务的任务"></a>完成可能有前置任务的任务</h4><ul><li>描述：</li></ul><p>99°要完成n个任务，它制定了一个计划，计划第i天完成第i个任务，每个任务可能有前置任务，在完成第i个任务时，必须先完成它的前置任务才行。问99°要想实现它的计划，每天至少要完成多少个任务？</p><ul><li>输入：</li></ul><p>一个整数n，表示要完成的任务数，2&lt;=n&lt;=10000。接下来n行，每行第一个数字k表示该任务的前置任务数，剩下的k个数字分别表示前置任务编号。</p><ul><li>输出：</li></ul><p>n个数字，每个数字以一个空格间隔，表示每天至少完成的任务数。</p><ul><li>样例输入：</li></ul><p>3<br>1 2<br>0<br>2 1 2</p><ul><li>样例输出：</li></ul><p>2 0 1</p><p>说明：任务1有1个前置任务2，第1天要想完成任务1，需先完成任务2，所以第1天至少完成2个任务。第2天计划完成任务2，因为任务2已在第一天完成，且任务2无前置任务，所以第2天至少完成0个任务。第3天计划完成任务3，任务3有两个前置任务1、2，在前两天都已完成，所以这一天只需完成任务3，至少完成1个任务即可。</p><ul><li>样例输入：</li></ul><p>5<br>4 2 3 4 5<br>1 1<br>2 1 2<br>0<br>1 3</p><ul><li>样例输出：</li></ul><p>5 0 0 0 0</p><p>说明：第1个任务有4个前置任务2、3、4、5，要想完成1，需先完成2、3、4、5，那么第1天至少完成5个任务。接下来的第2、3、4、5天每天完成0个任务，因为在第1天已完成全部5个任务。</p><ul><li><p>解题思路：开哈希数组</p></li><li><p>参考程序：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=10005;</span><br><span class="line">int n,res[N],v[N];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int k,x;</span><br><span class="line">    memset(res,0,sizeof res);</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(int i=1;i&lt;=n;i++) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;k);</span><br><span class="line">        while(k--) &#123;</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">            if(!v[x]) &#123;</span><br><span class="line">                v[x]=1;</span><br><span class="line">                res[i]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(!v[i]) &#123;</span><br><span class="line">            res[i]++;</span><br><span class="line">            v[i]=1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=n;i++) &#123;</span><br><span class="line">        printf(&quot;%d &quot;,res[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="将数组元素变为非递减"><a href="#将数组元素变为非递减" class="headerlink" title="将数组元素变为非递减"></a>将数组元素变为非递减</h4><ul><li>描述</li></ul><p>99°给出一个包含$n$个整数的数组$a_i$，99°每次可以选择数组中若干个下标不同的元素，对选中的每个元素执行下列改变：假设选中的元素为$x$，那么就将$x$替换为$(x+1) mod m$，即选中的每个元素自增1，如果变为$m$则归零。<br>请问最少执行多少次操作，99°可以把这个数组变为一个数组元素非递减的数组。</p><ul><li>输入：</li></ul><p>第一行两个整数$n$和$m$，用一个空格分隔；<br>第二行$n$个整数$a_1$,$a_2$,…,$a_n$表示数组，每两个整数之间用一个空格分隔。<br>输入满足$1&lt;=n,m&lt;=300000;0 &lt;= a_i &lt; m$ 。</p><ul><li>输出：</li></ul><p>一个整数，表示最少需要的操作次数。</p><ul><li>输入样例1：</li></ul><p>6 8<br>7 5 6 3 2 1</p><ul><li>输出样例1：</li></ul><p>3</p><ul><li>输入样例2：</li></ul><p>3 2<br>1 0 1</p><ul><li>输出样例2：</li></ul><p>1</p><ul><li>输入样例3：</li></ul><p>3 2<br>1 0 0</p><ul><li>输出样例3：</li></ul><p>1</p><ul><li><p>解题思路：线性dp</p></li><li><p>参考程序：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define INF 0x3f3f3f3f</span><br><span class="line">const int N=300005;</span><br><span class="line">int n,m,a[N],dp[N];</span><br><span class="line"></span><br><span class="line">inline int move(int i,int j) &#123;</span><br><span class="line">    int ans=j-a[i];</span><br><span class="line">    if(a[i]&gt;j) ans+=m;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int t,ans=INF;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">    for(int i=0;i&lt;m;i++)   //初始化dp数组</span><br><span class="line">        dp[i]=move(0,i);</span><br><span class="line">    for(int i=1;i&lt;n;i++) &#123;</span><br><span class="line">        t=dp[0];</span><br><span class="line">        for(int j=0;j&lt;m;j++) &#123;</span><br><span class="line">            t=min(t,dp[j]);</span><br><span class="line">            dp[j]=max(t,move(i,j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for(int i=0;i&lt;m;i++)</span><br><span class="line">        ans=min(ans,dp[i]);</span><br><span class="line">    printf(&quot;%d\n&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-n-中每位数字乘积最大的值&quot;&gt;&lt;a href=&quot;#1-n-中每位数字乘积最大的值&quot; class=&quot;headerlink&quot; title=&quot;1 ~ n 中每位数字乘积最大的值&quot;&gt;&lt;/a&gt;1 ~ n 中每位数字乘积最大的值&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;描述：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;99°是一位爱好爬山的小青年，他每次在爬山过程中都会遇到很多小猴子，小猴子们喜欢向他提这样一种问题：在1 ~ n中找一个数字m，使得m的各个数位乘积最大。99°不擅长回答这种问题，你能帮他写一个程序得到结果吗？&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://e99net.github.io/categories/Algorithm/"/>
    
    
      <category term="DFS" scheme="https://e99net.github.io/tags/DFS/"/>
    
      <category term="Dynamic Programming" scheme="https://e99net.github.io/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>记一道2020年某企业提前批招聘的机试题</title>
    <link href="https://e99net.github.io/2019/09/21/spdb/"/>
    <id>https://e99net.github.io/2019/09/21/spdb/</id>
    <published>2019-09-21T11:20:15.013Z</published>
    <updated>2019-09-24T02:57:39.061Z</updated>
    
    <content type="html"><![CDATA[<h4 id="字符串是否由子串拼接而成"><a href="#字符串是否由子串拼接而成" class="headerlink" title="字符串是否由子串拼接而成"></a>字符串是否由子串拼接而成</h4><ul><li>描述：</li></ul><p>给出一个非空的字符串，判断这个字符串是否由它的一个子串进行多次首尾拼接构成。<br>例如，“abcabcabc”满足条件，因为它是由“abc”首尾拼接而成，而“abcab”则不满足条件。</p><a id="more"></a><ul><li>输入：</li></ul><p>abcabcabc</p><ul><li>输出：</li></ul><p>true</p><ul><li>参考代码:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    string str;</span><br><span class="line">    cin&gt;&gt;str;</span><br><span class="line">    int n=str.size();</span><br><span class="line">    int m,flag;</span><br><span class="line">    for(int i=n/2;i&gt;=1;i--) &#123;</span><br><span class="line">        flag=0;</span><br><span class="line">        if(n%i==0)&#123;</span><br><span class="line">            m=n/i;</span><br><span class="line">            for(int j=0;j&lt;i;j++)&#123;</span><br><span class="line">                for(int k=1;k&lt;m;k++) &#123;</span><br><span class="line">                    if(str[j]!=str[j+k*i]) &#123;</span><br><span class="line">                        flag=1;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if(flag) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(!flag) &#123;</span><br><span class="line">                printf(&quot;true&quot;);</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;false&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;字符串是否由子串拼接而成&quot;&gt;&lt;a href=&quot;#字符串是否由子串拼接而成&quot; class=&quot;headerlink&quot; title=&quot;字符串是否由子串拼接而成&quot;&gt;&lt;/a&gt;字符串是否由子串拼接而成&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;描述：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;给出一个非空的字符串，判断这个字符串是否由它的一个子串进行多次首尾拼接构成。&lt;br&gt;例如，“abcabcabc”满足条件，因为它是由“abc”首尾拼接而成，而“abcab”则不满足条件。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://e99net.github.io/categories/Algorithm/"/>
    
    
      <category term="String" scheme="https://e99net.github.io/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>C++的输入与输出</title>
    <link href="https://e99net.github.io/2019/08/25/InputandOutputOfCpp/"/>
    <id>https://e99net.github.io/2019/08/25/InputandOutputOfCpp/</id>
    <published>2019-08-25T07:35:30.848Z</published>
    <updated>2019-08-25T07:38:59.207Z</updated>
    
    <content type="html"><![CDATA[<p>输入时：<br>float型输入用%f。<br>double型输入用%lf。</p><a id="more"></a><p>输出时：<br>最好是都用%f输出。<br>在G++中，double类型若用%lf输出可能会错，而在C++中，double类型用%lf输出是正确的。<br>printf() 函数中不存在 %lf。</p><p>总结：<br>输入 double 用 %lf 输出用 %f。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;输入时：&lt;br&gt;float型输入用%f。&lt;br&gt;double型输入用%lf。&lt;/p&gt;
    
    </summary>
    
      <category term="memo" scheme="https://e99net.github.io/categories/memo/"/>
    
    
      <category term="C/C++" scheme="https://e99net.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>用Git进行简单有效的项目版本控制管理</title>
    <link href="https://e99net.github.io/2019/03/02/git/"/>
    <id>https://e99net.github.io/2019/03/02/git/</id>
    <published>2019-03-02T11:50:07.770Z</published>
    <updated>2019-03-02T11:59:41.342Z</updated>
    
    <content type="html"><![CDATA[<p>Git是一个非常强大的项目版本控制管理工具，在单机环境下，可以简单有效地使用Git</p><a id="more"></a><ul><li>常用的Git命令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;[提交点名称]&quot;</span><br><span class="line">git status</span><br><span class="line">git log</span><br><span class="line">git reset --hard HEAD^^</span><br><span class="line">get reset --hard [Git生成的版本号，不必写全，无歧义即可]</span><br><span class="line">git checkout -- [文件]</span><br></pre></td></tr></table></figure></li></ul><p>以上这些命令就足以较好地管理自己的项目目录了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Git是一个非常强大的项目版本控制管理工具，在单机环境下，可以简单有效地使用Git&lt;/p&gt;
    
    </summary>
    
      <category term="memo" scheme="https://e99net.github.io/categories/memo/"/>
    
    
      <category term="Git" scheme="https://e99net.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>makefile文件的不同写法</title>
    <link href="https://e99net.github.io/2019/02/23/otherKindOfMakefile/"/>
    <id>https://e99net.github.io/2019/02/23/otherKindOfMakefile/</id>
    <published>2019-02-23T03:50:46.528Z</published>
    <updated>2019-02-23T03:55:09.817Z</updated>
    
    <content type="html"><![CDATA[<ul><li>封装so库时的写法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">CC=gcc</span><br><span class="line"></span><br><span class="line">SRCS=mylib.c</span><br><span class="line"></span><br><span class="line">OBJS=$(SRCS:.c=.o)</span><br><span class="line"></span><br><span class="line">EXEC=libmylib.so</span><br><span class="line"></span><br><span class="line">start: $(OBJS)</span><br><span class="line">    $(CC) -o $(EXEC) $(OBJS) -shared</span><br><span class="line"></span><br><span class="line">.c.o:</span><br><span class="line">    $(CC) -o $@ -c $&lt; -fPIC</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">    rm -rf $(OBJS)</span><br></pre></td></tr></table></figure><a id="more"></a><ul><li>C/C++混合编程的写法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">CC=g++</span><br><span class="line"></span><br><span class="line">SRCS=main.cpp\</span><br><span class="line">    udp.cpp</span><br><span class="line"></span><br><span class="line">OBJS=$(SRCS:.cpp=.o)</span><br><span class="line"></span><br><span class="line">EXEC=myudp</span><br><span class="line"></span><br><span class="line">start: $(OBJS)</span><br><span class="line">    $(CC) -o $(EXEC) $(OBJS)</span><br><span class="line"></span><br><span class="line">.cpp.o:</span><br><span class="line">    $(CC) -o $@ -c $&lt; -DMYLINUX</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">    rm -rf $(OBJS)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;封装so库时的写法&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;CC=gcc&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SRCS=mylib.c&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;OBJS=$(SRCS:.c=.o)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;EXEC=libmylib.so&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;start: $(OBJS)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    $(CC) -o $(EXEC) $(OBJS) -shared&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.c.o:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    $(CC) -o $@ -c $&amp;lt; -fPIC&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;clean:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    rm -rf $(OBJS)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="memo" scheme="https://e99net.github.io/categories/memo/"/>
    
    
      <category term="C/C++" scheme="https://e99net.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>循序渐进写makefile</title>
    <link href="https://e99net.github.io/2019/02/23/writeMakefile/"/>
    <id>https://e99net.github.io/2019/02/23/writeMakefile/</id>
    <published>2019-02-23T03:11:15.605Z</published>
    <updated>2019-02-23T04:22:53.639Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>准备工作</p><ul><li><p>main.cpp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;a.h&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    test();</span><br><span class="line">    cout &lt;&lt; &quot;hello world&quot; &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>a.h</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#ifndef AH_H</span><br><span class="line">#define AH_H</span><br><span class="line">void test();</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></li><li><p>a.cpp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;I am test\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><a id="more"></a><ul><li>版本0</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">start:</span><br><span class="line">    g++ -o a.o -c a.cpp</span><br><span class="line">    g++ -o main.o -c main.cpp</span><br><span class="line">    g++ -o myapp a.o main.o</span><br></pre></td></tr></table></figure><ul><li>版本1</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">start:</span><br><span class="line">    g++ -o a.o -c a.cpp</span><br><span class="line">    g++ -o main.o -c main.cpp</span><br><span class="line">    g++ -o myapp a.o main.o</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">    rm -rf a.o main.o</span><br></pre></td></tr></table></figure><ul><li>版本2</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CC=g++</span><br><span class="line"></span><br><span class="line">EXEC=myapp</span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line">    $(CC) -o a.o -c a.cpp</span><br><span class="line">    $(CC) -o main.o -c main.cpp</span><br><span class="line">    $(CC) -o $(EXEC) a.o main.o</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">    rm -rf a.o main.o</span><br></pre></td></tr></table></figure><ul><li>版本3</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">CC=g++</span><br><span class="line"></span><br><span class="line">SRCS=main.cpp\</span><br><span class="line">        a.cpp</span><br><span class="line"></span><br><span class="line">OBJS=main.o\</span><br><span class="line">        a.o</span><br><span class="line"></span><br><span class="line">EXEC=myapp</span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line">    $(CC) -o $(OBJS) -c $(SRCS)</span><br><span class="line">    $(CC) -o $(EXEC) $(OBJS)</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">    rm -rf $(OBJS)</span><br></pre></td></tr></table></figure><ul><li>版本4</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">CC=g++</span><br><span class="line"></span><br><span class="line">SRCS=main.cpp\</span><br><span class="line">        a.cpp</span><br><span class="line"></span><br><span class="line">OBJS=main.o\</span><br><span class="line">        a.o</span><br><span class="line"></span><br><span class="line">EXEC=myapp</span><br><span class="line"></span><br><span class="line">start: a.o main.o</span><br><span class="line">    $(CC) -o $(EXEC) $(OBJS)</span><br><span class="line"></span><br><span class="line">a.o main.o:</span><br><span class="line">    $(CC) -o $(OBJS) -c $(SRCS)</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">    rm -rf $(OBJS)</span><br></pre></td></tr></table></figure><ul><li>最终版本</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">CC=g++</span><br><span class="line"></span><br><span class="line">SRCS=main.cpp\</span><br><span class="line">        a.cpp</span><br><span class="line"></span><br><span class="line">OBJS=$(SRCS:.cpp=.o)</span><br><span class="line"></span><br><span class="line">EXEC=myapp</span><br><span class="line"></span><br><span class="line">start: $(OBJS)</span><br><span class="line">        $(CC) -o $(EXEC) $(OBJS)</span><br><span class="line"></span><br><span class="line">.cpp.o:</span><br><span class="line">        $(CC) -o $@ -c $&lt;</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">        rm -rf $(OBJS)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;准备工作&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;main.cpp&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;quot;a.h&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;using namespace std;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int main()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    test();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cout &amp;lt;&amp;lt; &amp;quot;hello world&amp;quot; &amp;lt;&amp;lt; endl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;a.h&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#ifndef AH_H&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#define AH_H&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void test();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#endif&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;a.cpp&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void test()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    printf(&amp;quot;I am test\n&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="memo" scheme="https://e99net.github.io/categories/memo/"/>
    
    
      <category term="C/C++" scheme="https://e99net.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>Win7开机界面英文转中文</title>
    <link href="https://e99net.github.io/2019/02/10/EnToChOfBootloader/"/>
    <id>https://e99net.github.io/2019/02/10/EnToChOfBootloader/</id>
    <published>2019-02-10T03:56:23.237Z</published>
    <updated>2019-02-10T07:44:35.550Z</updated>
    
    <content type="html"><![CDATA[<p>打开cmd命令提示符并执行如下命令</p><ul><li>将操作系统启动选择菜单的显示语言修改为简体中文<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcdedit /set &#123;bootmgr&#125; locale zh-CN</span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><ul><li><p>将当前Windows操作系统F8高级启动菜单的显示语言修改为简体中文</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcdedit /set &#123;current&#125; locale zh-CN</span><br></pre></td></tr></table></figure></li><li><p>将Windows内存诊断工具的显示语言修改为简体中文</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcdedit /set &#123;memdiag&#125; locale zh-CN</span><br></pre></td></tr></table></figure></li><li><p>将休眠恢复时的显示语言修改为简体中文</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcdedit /set &#123;视机器而定的一段字符&#125; locale zh-CN</span><br></pre></td></tr></table></figure></li></ul><p>注意：视机器而定的一段字符形如526bf864-88ef-11de-9b8c-e613e975374f，这段字符可通过以下命令进行查看<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcdedit /enum all</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;打开cmd命令提示符并执行如下命令&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将操作系统启动选择菜单的显示语言修改为简体中文&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;bcdedit /set &amp;#123;bootmgr&amp;#125; locale zh-CN&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="memo" scheme="https://e99net.github.io/categories/memo/"/>
    
    
      <category term="Water" scheme="https://e99net.github.io/tags/Water/"/>
    
  </entry>
  
  <entry>
    <title>用UltraISO制作Ubuntu18.04的启动U盘</title>
    <link href="https://e99net.github.io/2019/02/02/USBofUbuntu/"/>
    <id>https://e99net.github.io/2019/02/02/USBofUbuntu/</id>
    <published>2019-02-02T14:41:58.789Z</published>
    <updated>2019-09-21T11:54:52.784Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>从Ubuntu官网下载18.04系统的iso文件，并安装UltraISO软件</p></li><li><p>确保用来制作启动盘的U盘是FAT32格式的，否则，可将U盘格式化为FAT32格式</p></li></ol><a id="more"></a><ol start="3"><li><p>点击UltraISO的红色框内按钮<br><img src="/2019/02/02/USBofUbuntu/20170916135522757.png" alt=""></p></li><li><p>找到Ubuntu ISO文件并选中，点击打开<br><img src="/2019/02/02/USBofUbuntu/20170916135636024.png" alt=""><br>打开后的界面如下图所示<br><img src="/2019/02/02/USBofUbuntu/20170916135757851.png" alt=""></p></li><li><p>点击“启动→写入硬盘映像…”<br><img src="/2019/02/02/USBofUbuntu/20170916140000287.png" alt=""></p></li><li><p>写入方式选择USB-HDD+或者USB-HDD都可以<br><img src="/2019/02/02/USBofUbuntu/20170916140040427.png" alt=""></p></li><li><p>点击“便捷启动→写入新的驱动器引导扇区→Syslinux”,选择“是”，完成后“确定”<br><img src="/2019/02/02/USBofUbuntu/20170916140325642.png" alt=""><br><img src="/2019/02/02/USBofUbuntu/20170916140507610.png" alt=""><br><img src="/2019/02/02/USBofUbuntu/20170916140541363.png" alt=""></p></li><li><p>点击“写入”，选择“是”。<br><img src="/2019/02/02/USBofUbuntu/20170916140938127.png" alt=""></p></li><li><p>写入需要等待一段时间，完成后如下图。此时，选择“返回”并退出UltraISO即可<br><img src="/2019/02/02/USBofUbuntu/20170916141128817.png" alt=""></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;p&gt;从Ubuntu官网下载18.04系统的iso文件，并安装UltraISO软件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;确保用来制作启动盘的U盘是FAT32格式的，否则，可将U盘格式化为FAT32格式&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="memo" scheme="https://e99net.github.io/categories/memo/"/>
    
    
      <category term="Water" scheme="https://e99net.github.io/tags/Water/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu上的各种软件问题解决之道</title>
    <link href="https://e99net.github.io/2019/02/02/SolofMatlabOnUbuntu/"/>
    <id>https://e99net.github.io/2019/02/02/SolofMatlabOnUbuntu/</id>
    <published>2019-02-02T14:17:20.516Z</published>
    <updated>2019-02-02T14:41:36.433Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Ubuntu上的Matlab无法以普通用户身份运行"><a href="#Ubuntu上的Matlab无法以普通用户身份运行" class="headerlink" title="Ubuntu上的Matlab无法以普通用户身份运行"></a>Ubuntu上的Matlab无法以普通用户身份运行</h2><p>给“/home/用户名/.matlab”这个文件目录递归授予超级权限<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod 777 .matlab -R</span><br></pre></td></tr></table></figure></p><h2 id="CLion无法用快捷方式启动"><a href="#CLion无法用快捷方式启动" class="headerlink" title="CLion无法用快捷方式启动"></a>CLion无法用快捷方式启动</h2><p>先在Terminal中启动CLion，然后点击菜单栏Tools下面的Create Desktop Entry即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Ubuntu上的Matlab无法以普通用户身份运行&quot;&gt;&lt;a href=&quot;#Ubuntu上的Matlab无法以普通用户身份运行&quot; class=&quot;headerlink&quot; title=&quot;Ubuntu上的Matlab无法以普通用户身份运行&quot;&gt;&lt;/a&gt;Ubuntu上的Mat
      
    
    </summary>
    
      <category term="memo" scheme="https://e99net.github.io/categories/memo/"/>
    
    
      <category term="Linux" scheme="https://e99net.github.io/tags/Linux/"/>
    
      <category term="Matlab" scheme="https://e99net.github.io/tags/Matlab/"/>
    
  </entry>
  
  <entry>
    <title>强化学习介绍</title>
    <link href="https://e99net.github.io/2018/11/12/A_intro_to_RL/"/>
    <id>https://e99net.github.io/2018/11/12/A_intro_to_RL/</id>
    <published>2018-11-12T12:10:15.619Z</published>
    <updated>2019-01-05T12:11:57.067Z</updated>
    
    <content type="html"><![CDATA[<h4 id="蒙特卡罗-VS-TD学习方法"><a href="#蒙特卡罗-VS-TD学习方法" class="headerlink" title="蒙特卡罗 VS TD学习方法"></a>蒙特卡罗 VS TD学习方法</h4><p>我们有两种学习方式：</p><ul><li>在episode的最后收集奖励并计算最大期望将来奖励：蒙特卡罗方法</li><li>估计每一步的奖励：时序差分学习</li></ul><a id="more"></a><h5 id="蒙特卡罗"><a href="#蒙特卡罗" class="headerlink" title="蒙特卡罗"></a>蒙特卡罗</h5><p>当episode结束时（智能体到达一个“终止状态”），智能体视其总共的累计奖励来知晓它做的怎么样。在蒙特卡罗方法中，只有在游戏的最后才会收到奖励。</p><p>然后，带着新增的知识开启一轮新游戏。智能体每次迭代会做出更好的决策。</p><h4 id="探索-开发的权衡"><a href="#探索-开发的权衡" class="headerlink" title="探索/开发的权衡"></a>探索/开发的权衡</h4><ul><li>探索是发现有关环境的更多信息</li><li>开发是开发已知的信息，使得奖励最大化</li></ul><p>强化学习智能体的目标是最大化期望的累计奖励，然而，我们会陷入一个共同的陷阱。</p><p>我们必须定义一个规则帮助我们处理这种权衡。</p><h4 id="强化学习的三种方法"><a href="#强化学习的三种方法" class="headerlink" title="强化学习的三种方法"></a>强化学习的三种方法</h4><p>解决强化学习问题的三种方法是：基于值、基于策略、基于模型。</p><h5 id="基于值"><a href="#基于值" class="headerlink" title="基于值"></a>基于值</h5><p>在基于值的强化学习中，目标是优化值函数</p><blockquote><p>值函数告知我们智能体在每个状态得到的最大期望将来奖励</p></blockquote><p>每个状态的值是在那个状态的智能体期望在将来累计的奖励总数。<br>$$<br>V_\pi(s)=\mathbb{E_\pi}[R_{t+1}+\gamma R_{t+2}+\gamma ^2 R_{t+3}+…|S_t =s]<br>$$<br>智能体会使用这个值函数去在每一步选择一个状态，选择的状态具有最大的值。</p><h5 id="基于策略"><a href="#基于策略" class="headerlink" title="基于策略"></a>基于策略</h5><p>在基于策略的强化学习中，我们想不使用值函数而直接优化策略函数$\mathtt{\pi}(s)$。</p><p>策略是在一个给定的时间对智能体行为的定义。<br>$$<br>a=\pi(s)<br>$$<br>我们学习一个策略函数，使每个状态映射到对应的最好动作。</p><p>我们有两种策略：</p><ul><li>固定策略：一种在给定状态总会返回相同动作的策略。</li><li>随机策略：随动作输出分布概率。</li></ul><p>$$<br>\text{Stochastic policy:} \ \pi(a|s)=\mathbb{P}[A_t=a|S_t=s]<br>$$</p><p>策略直接表明每一步应该采取的最好动作。</p><h5 id="基于模型"><a href="#基于模型" class="headerlink" title="基于模型"></a>基于模型</h5><p>在基于模型的强化学习中，我们对环境建模。这意味着我们创建了一个环境行为的模型。</p><p>问题是每个环境都需要一个不同的模型表示。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;蒙特卡罗-VS-TD学习方法&quot;&gt;&lt;a href=&quot;#蒙特卡罗-VS-TD学习方法&quot; class=&quot;headerlink&quot; title=&quot;蒙特卡罗 VS TD学习方法&quot;&gt;&lt;/a&gt;蒙特卡罗 VS TD学习方法&lt;/h4&gt;&lt;p&gt;我们有两种学习方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在episode的最后收集奖励并计算最大期望将来奖励：蒙特卡罗方法&lt;/li&gt;
&lt;li&gt;估计每一步的奖励：时序差分学习&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="memo" scheme="https://e99net.github.io/categories/memo/"/>
    
    
      <category term="Reinforcement Learning" scheme="https://e99net.github.io/tags/Reinforcement-Learning/"/>
    
  </entry>
  
  <entry>
    <title>Latex处理参考文献</title>
    <link href="https://e99net.github.io/2018/11/02/reference_of_latex/"/>
    <id>https://e99net.github.io/2018/11/02/reference_of_latex/</id>
    <published>2018-11-02T13:48:12.079Z</published>
    <updated>2018-11-02T13:51:28.363Z</updated>
    
    <content type="html"><![CDATA[<p>使用cite宏包可以生成参考文献</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\usepackage&#123;cite&#125;</span><br><span class="line">\cite&#123;b3,b4,b5,b6,b7,b8&#125;</span><br></pre></td></tr></table></figure><p>生成的参考文献格式为：[3]-[8]</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用cite宏包可以生成参考文献&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;
      
    
    </summary>
    
      <category term="memo" scheme="https://e99net.github.io/categories/memo/"/>
    
    
      <category term="Latex" scheme="https://e99net.github.io/tags/Latex/"/>
    
  </entry>
  
  <entry>
    <title>WEB框架辨析</title>
    <link href="https://e99net.github.io/2018/10/23/webframe/"/>
    <id>https://e99net.github.io/2018/10/23/webframe/</id>
    <published>2018-10-23T05:30:52.852Z</published>
    <updated>2018-10-23T05:34:11.843Z</updated>
    
    <content type="html"><![CDATA[<h3 id="bootstrap是个Web框架吗？"><a href="#bootstrap是个Web框架吗？" class="headerlink" title="bootstrap是个Web框架吗？"></a>bootstrap是个Web框架吗？</h3><p>bootstrap不能算是个完整的框架，它应该算是一个css框架+一些js组件。主要目的不是提供一个完整的前端解决方案，而只是关注前端UI呈现。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;bootstrap是个Web框架吗？&quot;&gt;&lt;a href=&quot;#bootstrap是个Web框架吗？&quot; class=&quot;headerlink&quot; title=&quot;bootstrap是个Web框架吗？&quot;&gt;&lt;/a&gt;bootstrap是个Web框架吗？&lt;/h3&gt;&lt;p&gt;bootst
      
    
    </summary>
    
      <category term="memo" scheme="https://e99net.github.io/categories/memo/"/>
    
    
      <category term="Water" scheme="https://e99net.github.io/tags/Water/"/>
    
  </entry>
  
  <entry>
    <title>差分进化基础</title>
    <link href="https://e99net.github.io/2018/09/28/basic_of_DE/"/>
    <id>https://e99net.github.io/2018/09/28/basic_of_DE/</id>
    <published>2018-09-28T02:10:31.334Z</published>
    <updated>2018-10-01T08:34:42.606Z</updated>
    
    <content type="html"><![CDATA[<p>差分进化算法是一种自组织最小化方法，用户只需要很少的输入，它起源于遗传算法(EA)，是一种基于种群进化的算法，包括变异、交叉、选择、边界检测。</p><a id="more"></a><p>差分进化算法由Storn等人于1995年提出，是一种模拟生物进化的随机模型，保留了基于种群的全局搜索策略，降低了遗传操作的复杂性。</p><p>DE和PSO都是基于种群的算法，不同于其他演化算法的是，DE使用种群中两个随机选择的个体向量差产生一个新的候选解（个体）。DE有一个好的全局搜索能力，但通常在种群演化的后阶段收敛得很慢。PSO能够收敛得很快，但易于陷入局部最优。由于DE与PSO的互补特性，一些研究常聚焦于两者的混合应用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;差分进化算法是一种自组织最小化方法，用户只需要很少的输入，它起源于遗传算法(EA)，是一种基于种群进化的算法，包括变异、交叉、选择、边界检测。&lt;/p&gt;
    
    </summary>
    
      <category term="EAs" scheme="https://e99net.github.io/categories/EAs/"/>
    
    
      <category term="DE" scheme="https://e99net.github.io/tags/DE/"/>
    
  </entry>
  
  <entry>
    <title>扫盲</title>
    <link href="https://e99net.github.io/2018/09/23/Eliminate_illiteracy/"/>
    <id>https://e99net.github.io/2018/09/23/Eliminate_illiteracy/</id>
    <published>2018-09-23T05:26:00.771Z</published>
    <updated>2018-09-23T05:33:47.323Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>中国、日本和韩国的象形文字总称为CJK。</p><a id="more"></a></li><li><p>Mac OS X Mavericks(巨浪)：X表示Mac的第10个版本，“X”是罗马数字“10”的意思。</p></li><li><p>将“休眠”去掉，同时腾出C盘空间：powercfg.exe /hibernate off。</p></li><li><p>Sublime Text快捷键：Ctrl+K U 改为大写，Ctrl+K L 改为小写。</p></li><li><p>FreeBSD比Linux还要稳定，可以做到十年不关机，并且比Linux速度要快出30%。</p></li><li><p>美国军方五角大楼采用的是openBSD操作系统。</p></li><li><p>编译器图书中的”龙书“、”虎书“、”鲸书“ 分别指的是《编译原理：技术与工具（第2版）》、《高级编译器：设计与实现》、《现代编译原理：C语言描述》</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;中国、日本和韩国的象形文字总称为CJK。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="memo" scheme="https://e99net.github.io/categories/memo/"/>
    
    
      <category term="Water" scheme="https://e99net.github.io/tags/Water/"/>
    
  </entry>
  
  <entry>
    <title>JDK1.5的新特性</title>
    <link href="https://e99net.github.io/2018/09/23/jdk1.5_newCharacter/"/>
    <id>https://e99net.github.io/2018/09/23/jdk1.5_newCharacter/</id>
    <published>2018-09-23T05:13:15.352Z</published>
    <updated>2018-09-23T05:16:43.389Z</updated>
    
    <content type="html"><![CDATA[<p>jdk1.5的四个新特性如下：</p><ul><li>自动装箱和拆箱</li><li>增强for循环</li><li>静态导入（唯一的败笔）</li><li>可变参数</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;jdk1.5的四个新特性如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自动装箱和拆箱&lt;/li&gt;
&lt;li&gt;增强for循环&lt;/li&gt;
&lt;li&gt;静态导入（唯一的败笔）&lt;/li&gt;
&lt;li&gt;可变参数&lt;/li&gt;
&lt;/ul&gt;

      
    
    </summary>
    
      <category term="memo" scheme="https://e99net.github.io/categories/memo/"/>
    
    
      <category term="Java" scheme="https://e99net.github.io/tags/Java/"/>
    
  </entry>
  
</feed>
