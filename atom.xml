<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>99°</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://e99net.github.io/"/>
  <updated>2021-06-17T17:33:03.764Z</updated>
  <id>https://e99net.github.io/</id>
  
  <author>
    <name>sqLiu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>总结LeetCode上跳跃游戏这一类型的几道题</title>
    <link href="https://e99net.github.io/2021/06/17/LeetCode_JumpGame/"/>
    <id>https://e99net.github.io/2021/06/17/LeetCode_JumpGame/</id>
    <published>2021-06-17T12:07:30.169Z</published>
    <updated>2021-06-17T17:33:03.764Z</updated>
    
    <content type="html"><![CDATA[<h4 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h4><p>LeetCode 55 Medium [<a href="https://leetcode.com/problems/jump-game]" target="_blank" rel="noopener">https://leetcode.com/problems/jump-game]</a></p><ul><li><p>描述：</p><p>给定一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个下标。</p></li></ul><a id="more"></a><ul><li><p>输入：</p><p>一个非负整数数组</p></li><li><p>输出：</p><p>true 或 false</p></li><li><p>样例输入1：</p><p>[2,3,1,1,4]</p></li><li><p>样例输出1：</p><p>true</p><p>说明：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。</p></li><li><p>样例输入2：</p><p>[3,2,1,0,4]</p></li><li><p>样例输出2：</p><p>false</p><p>说明：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。</p></li><li><p>数据范围</p><p>$1 &lt;= nums.length &lt;= 10^4$</p><p>$0 &lt;= nums[i] &lt;= 10^5$</p></li><li><p>解题思路：贪心法</p><p>用动态规划也可解此题，但最好的方法还是贪心，只关心能否到达末尾即可。</p></li><li><p>参考代码:</p><ul><li><p>代码1，时间复杂度$O(n)$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums.size(),reach=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;reach || reach&gt;=n<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">            reach=max(reach,i+nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> reach&gt;=n<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h4><p>LeetCode 45 Medium [<a href="https://leetcode.com/problems/jump-game-ii]" target="_blank" rel="noopener">https://leetcode.com/problems/jump-game-ii]</a></p><ul><li><p>描述：</p><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p><p>假设你总是可以到达数组的最后一个位置。</p></li><li><p>输入：</p><p>一个非负整数数组</p></li><li><p>输出：</p><p>一个整数</p></li><li><p>输入样例1：</p><p>[2,3,1,1,4]</p></li><li><p>输出样例1：</p><p>2</p><p>说明：跳到最后一个位置的最小跳跃数是 2。从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</p></li><li><p>输入样例2：</p><p>[2,3,0,1,4]</p></li><li><p>输出样例2：</p><p>2</p></li><li><p>数据范围：</p><p>$1 &lt;= nums.length &lt;= 10^4$</p><p>$0 &lt;= nums[i] &lt;= 1000$</p></li><li><p>解题思路：贪心法</p></li><li><p>参考代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums.size(),res=<span class="number">0</span>,i=<span class="number">0</span>,cur=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur&lt;n<span class="number">-1</span>) &#123;</span><br><span class="line">            res++;</span><br><span class="line">            <span class="keyword">int</span> pre=cur;</span><br><span class="line">            <span class="keyword">for</span>(;i&lt;=pre;i++) &#123;</span><br><span class="line">                cur=max(cur,i+nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur==pre) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h4><p>LeetCode 1306 Hard [<a href="https://leetcode.com/problems/jump-game-iii]" target="_blank" rel="noopener">https://leetcode.com/problems/jump-game-iii]</a></p><ul><li><p>描述：</p><p>这里有一个非负整数数组 arr，你最开始位于该数组的起始下标 start 处。当你位于下标 i 处时，你可以跳到 i + arr[i] 或者 i - arr[i]。</p><p>请你判断自己是否能够跳到对应元素值为 0 的 任一 下标处。</p><p>注意，不管是什么情况下，你都无法跳到数组之外。</p></li><li><p>输入：</p><p>一个非负整数数组和一个整数</p></li><li><p>输出：</p><p>true 或 false</p></li><li><p>输入样例1：</p><p>[4,2,3,0,3,1,2] 5</p></li><li><p>输出样例1：</p><p>true</p><p>说明：</p><p>到达值为 0 的下标 3 有以下可能方案：<br>下标 5 -&gt; 下标 4 -&gt; 下标 1 -&gt; 下标 3<br>下标 5 -&gt; 下标 6 -&gt; 下标 4 -&gt; 下标 1 -&gt; 下标 3 </p></li><li><p>输入样例2：</p><p>[4,2,3,0,3,1,2] 0</p></li><li><p>输出样例2：</p><p>false</p><p>说明：无法到达值为 0 的下标 1 处。 </p></li><li><p>数据范围：</p><p>$1 &lt;= arr.length &lt;= 5 * 10^4$</p><p>$0 &lt;= arr[i] &lt; arr.length$</p><p>$0 &lt;= start &lt; arr.length$</p></li><li><p>解题思路：DFS</p></li><li><p>参考代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canReach</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=arr.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visited(n);</span><br><span class="line">        <span class="keyword">return</span> helper(arr,visited,start);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp; visited, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[start]==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(visited[start]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        visited[start]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">bool</span> flag=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(start-arr[start]&gt;=<span class="number">0</span>)</span><br><span class="line">            flag = flag || helper(arr,visited,start-arr[start]);</span><br><span class="line">        <span class="keyword">if</span>(start+arr[start]&lt;arr.size())</span><br><span class="line">            flag = flag || helper(arr,visited,start+arr[start]);</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="第四题"><a href="#第四题" class="headerlink" title="第四题"></a>第四题</h4><p>LeetCode 1345 Hard [<a href="https://leetcode.com/problems/jump-game-iv]" target="_blank" rel="noopener">https://leetcode.com/problems/jump-game-iv]</a></p><ul><li><p>描述：</p><p>给你一个整数数组 arr ，你一开始在数组的第一个元素处（下标为 0）。</p><p>每一步，你可以从下标 i 跳到下标：</p><p>i + 1 满足：i + 1 &lt; arr.length<br>i - 1 满足：i - 1 &gt;= 0<br>j 满足：arr[i] == arr[j] 且 i != j<br>请你返回到达数组最后一个元素的下标处所需的 最少操作次数 。</p><p>注意：任何时候你都不能跳到数组外面。</p></li><li><p>输入：</p><p>一个整数数组</p></li><li><p>输出：</p><p>一个整数</p></li><li><p>输入样例1：</p><p>[100,-23,-23,404,100,23,23,23,3,404]</p></li><li><p>输出样例1：</p><p>3</p><p>说明：那你需要跳跃 3 次，下标依次为 0 –&gt; 4 –&gt; 3 –&gt; 9 。下标 9 为数组的最后一个元素的下标。</p></li><li><p>输入样例2：</p><p>[7]</p></li><li><p>输出样例2：</p><p>0</p><p>说明：一开始就在最后一个元素处，所以你不需要跳跃。</p></li><li><p>输入样例3：</p><p>[7,6,9,6,9,6,9,7]</p></li><li><p>输出样例3：</p><p>1</p><p>说明：你可以直接从下标 0 处跳到下标 7 处，也就是数组的最后一个元素处。</p></li><li><p>输入样例4：</p><p>[6,1,9]</p></li><li><p>输出样例4：</p><p>2</p></li><li><p>输入样例5：</p><p>[11,22,7,7,7,7,7,7,7,22,13]</p></li><li><p>输出样例5：</p><p>3</p></li><li><p>数据范围：</p><p>$1 &lt;= arr.length &lt;= 5 * 10^4$</p><p>$-10^8 &lt;= arr[i] &lt;= 10^8$</p></li><li><p>解题思路：BFS</p></li><li><p>参考代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minJumps</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=INT_MAX,n=arr.size(),cur=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visited(n);</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            m[arr[i]].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q&#123;&#123;<span class="number">0</span>&#125;&#125;;</span><br><span class="line">        visited[<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=q.size();i&gt;<span class="number">0</span>;i--) &#123;</span><br><span class="line">                <span class="keyword">int</span> t=q.front();q.pop();</span><br><span class="line">                <span class="keyword">if</span>(t==n<span class="number">-1</span>) &#123;</span><br><span class="line">                    res=min(res,cur);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(t<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; !visited[t<span class="number">-1</span>]) &#123;</span><br><span class="line">                    q.push(t<span class="number">-1</span>);</span><br><span class="line">                    visited[t<span class="number">-1</span>]=<span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(t+<span class="number">1</span>&lt;n &amp;&amp; !visited[t+<span class="number">1</span>]) &#123;</span><br><span class="line">                    q.push(t+<span class="number">1</span>);</span><br><span class="line">                    visited[t+<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> v:m[arr[t]]) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(v!=t &amp;&amp; !visited[v]) &#123;</span><br><span class="line">                        q.push(v);</span><br><span class="line">                        visited[v]=<span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                m[arr[t]].clear();</span><br><span class="line">            &#125;</span><br><span class="line">            ++cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="第五题"><a href="#第五题" class="headerlink" title="第五题"></a>第五题</h4><p>LeetCode 1340 Hard [<a href="https://leetcode.com/problems/jump-game-v]" target="_blank" rel="noopener">https://leetcode.com/problems/jump-game-v]</a></p><ul><li><p>描述：</p><p>给你一个整数数组 arr 和一个整数 d 。每一步你可以从下标 i 跳到：</p><p>i + x ，其中 i + x &lt; arr.length 且 0 &lt; x &lt;= d 。<br>i - x ，其中 i - x &gt;= 0 且 0 &lt; x &lt;= d 。<br>除此以外，你从下标 i 跳到下标 j 需要满足：arr[i] &gt; arr[j] 且 arr[i] &gt; arr[k] ，其中下标 k 是所有 i 到 j 之间的数字（更正式的，min(i, j) &lt; k &lt; max(i, j)）。</p><p>你可以选择数组的任意下标开始跳跃。请你返回你 最多 可以访问多少个下标。</p><p>请注意，任何时刻你都不能跳到数组的外面。</p></li><li><p>输入：</p><p>一个整数数组和一个整数</p></li><li><p>输出：</p><p>一个整数</p></li><li><p>输入样例1：</p><p>[6,4,14,6,8,13,9,7,10,6,12] 2</p></li><li><p>输出样例1：</p><p>4</p><p>说明：</p><p><img src="https://assets.leetcode.com/uploads/2020/01/23/meta-chart.jpeg" alt="img"></p><p>你可以从下标 10 出发，然后如上图依次经过 10 –&gt; 8 –&gt; 6 –&gt; 7 。<br>注意，如果你从下标 6 开始，你只能跳到下标 7 处。你不能跳到下标 5 处因为 13 &gt; 9 。你也不能跳到下标 4 处，因为下标 5 在下标 4 和 6 之间且 13 &gt; 9 。<br>类似的，你不能从下标 3 处跳到下标 2 或者下标 1 处。</p></li><li><p>输入样例2：</p><p>[3,3,3,3,3] 3</p></li><li><p>输出样例2：</p><p>1</p></li></ul><ul><li><p>输入样例3：</p><p>[7,6,5,4,3,2,1] 1</p></li><li><p>输出样例3：</p><p>7</p></li><li><p>输入样例4：</p><p>[7,1,7,1,7,1] 2</p></li><li><p>输出样例4：</p><p>2</p></li><li><p>输入样例5：</p><p>[66] 1</p></li><li><p>输出样例5：</p><p>1</p></li></ul><ul><li><p>数据范围：</p><p>$1 &lt;= arr.length &lt;= 1000$</p><p>$1 &lt;= arr[i] &lt;= 10^5$</p><p>$1 &lt;= d &lt;= arr.length$</p></li><li><p>解题思路：动态规划<br>用 $dp[i]$ 表示从 $i$ 开始跳，最多可以跳的台阶数。<br>因为，根据题意只能往低了跳，且中间不能遇到比自己高的，所以，动态规划要按从低向高的顺序计算，要先排序（<strong>这一点很重要</strong>），这里借助multimap数据结构进行排序，默认升序排列。<br>状态转移方程 $dp[i]=max(dp[i], 1+dp[j])$，从 $i$ 跳到所有可能的 $j$</p></li><li><p>参考代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxJumps</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=arr.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n); <span class="comment">// dp数组</span></span><br><span class="line">        <span class="built_in">multimap</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            m.insert(make_pair(arr[i],i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; it:m) &#123; <span class="comment">// 从低到高开始dp</span></span><br><span class="line">            <span class="keyword">int</span> i=it.second;</span><br><span class="line">            dp[i]=<span class="number">1</span>; <span class="comment">// 至少为1，因为至少包含自身</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i<span class="number">-1</span>;j&gt;=i-d &amp;&amp; j&gt;=<span class="number">0</span> &amp;&amp; arr[j]&lt;arr[i];j--) &#123;</span><br><span class="line">                <span class="comment">// 往左边找比自己低的，遇到比自己高的就停止</span></span><br><span class="line">                <span class="comment">// 由于由低到高计算，比自己低的已经计算好了</span></span><br><span class="line">                dp[i]=max(dp[i],<span class="number">1</span>+dp[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=i+d &amp;&amp; j&lt;n &amp;&amp; arr[j]&lt;arr[i];j++) &#123;</span><br><span class="line">                <span class="comment">// 往右边找比自己低的，遇到比自己高的就停止</span></span><br><span class="line">                <span class="comment">// 由于由低到高计算，比自己低的已经计算好了</span></span><br><span class="line">                dp[i]=max(dp[i],<span class="number">1</span>+dp[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *max_element(dp.begin(),dp.end()); <span class="comment">// q</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="第六题"><a href="#第六题" class="headerlink" title="第六题"></a>第六题</h4><p>LeetCode 1696 Medium [<a href="https://leetcode.com/problems/jump-game-vi]" target="_blank" rel="noopener">https://leetcode.com/problems/jump-game-vi]</a></p><ul><li><p>描述：</p><p>给你一个下标从 0 开始的整数数组 nums 和一个整数 k 。</p><p>一开始你在下标 0 处。每一步，你最多可以往前跳 k 步，但你不能跳出数组的边界。也就是说，你可以从下标 i 跳到 [i + 1， min(n - 1, i + k)] 包含 两个端点的任意位置。</p><p>你的目标是到达数组最后一个位置（下标为 n - 1 ），你的 得分 为经过的所有数字之和。</p><p>请你返回你能得到的 最大得分 。</p></li><li><p>输入：</p><p>一个整数数组和一个整数</p></li><li><p>输出：</p><p>一个整数</p></li><li><p>输入样例1：</p><p>[1,-1,-2,4,-7,3] 2</p></li><li><p>输出样例1：</p><p>7</p><p>说明：你可以选择子序列 [1,-1,4,3] （上面加粗的数字），和为 7 。、</p></li></ul><ul><li><p>输入样例2：</p><p>[10,-5,-2,4,0,3] 3</p></li><li><p>输出样例2：</p><p>17</p></li><li><p>输入样例3：</p><p>[1,-5,-20,4,-1,3,-6,-3] 2</p></li><li><p>输出样例3：</p><p>0</p></li></ul><ul><li><p>数据范围：</p><p>$1 &lt;= nums.length, k &lt;= 10^5$</p><p>$-10^4 &lt;= nums[i] &lt;= 10^4$</p></li><li><p>解题思路：动态规划</p><p>这题很容易想到 DP，但是 DP 的复杂度是 $O(n*k)$ 的，显然会超时，所以要借助一种数据结构快速找到[i−k, i−1]的最大值，然后再结合 DP 即可。</p><p>这种数据结构可以是堆，也可以是单调队列。用堆的话，堆顶维护区间最大值，把下标也一并放入堆中来帮助判断是否能从这个状态转移；用单调队列的话，队首维护区间最大值，按需出队、入队皆可。</p></li><li><p>参考代码：</p><ul><li><p>代码1，时间复杂度$O(n*k)$</p><p>LeetCode上的数据范围是$1 &lt;= nums.length, k &lt;= 10^5$，$O(n*k)$时间复杂度的算法会超时，故代码1提交时会TLE</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxResult</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n,INT_MIN);</span><br><span class="line">        dp[n<span class="number">-1</span>]=nums[n<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=k &amp;&amp; i+j&lt;n;j++) &#123;</span><br><span class="line">                dp[i]=max(dp[i],nums[i]+dp[i+j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>代码2，时间复杂度$O(nlogn)$，动态规划+堆</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxResult</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n,<span class="number">0</span>);</span><br><span class="line">        dp[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; pq;</span><br><span class="line">        pq.push(&#123;nums[<span class="number">0</span>],<span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(pq.top().second&lt;i-k) pq.pop();</span><br><span class="line">            dp[i]=nums[i]+pq.top().first;</span><br><span class="line">            pq.push(&#123;dp[i],i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>代码3，每个元素只会入队列一次和出队列一次，所以总体时间复杂度$O(n)$，动态规划+滑动窗口</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxResult</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n,<span class="number">0</span>);</span><br><span class="line">        dp[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; dq;</span><br><span class="line">        dq.push_back(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(i-k&gt;dq.front()) dq.pop_front();</span><br><span class="line">            dp[i]=nums[i]+dp[dq.front()];</span><br><span class="line">            <span class="keyword">while</span>(dq.size() &amp;&amp; dp[i]&gt;dp[dq.back()]) dq.pop_back();</span><br><span class="line">            dq.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="第七题"><a href="#第七题" class="headerlink" title="第七题"></a>第七题</h4><p>LeetCode 1871 Medium [<a href="https://leetcode.com/problems/jump-game-vii]" target="_blank" rel="noopener">https://leetcode.com/problems/jump-game-vii]</a></p><ul><li><p>描述：</p><p>给你一个下标从 0 开始的二进制字符串 s 和两个整数 minJump 和 maxJump 。一开始，你在下标 0 处，且该位置的值一定为 ‘0’ 。当同时满足如下条件时，你可以从下标 i 移动到下标 j 处：</p><ul><li>i + minJump &lt;= j &lt;= min(i + maxJump, s.length - 1) 且</li><li>s[j] == ‘0’.</li></ul><p>如果你可以到达 s 的下标 s.length - 1 处，请你返回 true ，否则返回 false 。</p></li><li><p>输入：</p><p>一个字符串和两个整数</p></li><li><p>输出：</p><p>true 或 false</p></li><li><p>输入样例1：</p><p>“011010” 2 3</p></li><li><p>输出样例1：</p><p>true</p><p>说明：第一步，从下标 0 移动到下标 3 。第二步，从下标 3 移动到下标 5 。</p></li><li><p>输入样例2：</p><p>“01101110” 2 3</p></li><li><p>输出样例2：</p><p>false</p></li><li><p>数据范围：</p><p>$2 &lt;= s.length &lt;= 10^5$<br>s[i] 要么是 ‘0’ ，要么是 ‘1’<br>s[0] == ‘0’<br>$1 &lt;= minJump &lt;= maxJump &lt; s.length$</p></li><li><p>解题思路：贪心+剪枝优化</p><p>首先要明白，末尾字符为’1’的话一定返回false。因为只能跳到字符为’0’的位置，如果末尾字符为’1’，则表示永远跳不到末尾。</p><p>然后遍历字符串，标记在每个位置上能跳跃到的位置。可以使用额外的数组来标记，也可以直接在原字符串进行标记。</p><p>一开始这样是会超时的，有很多位置可能存在重复标记。因此做一个小小的优化，在标记前比较本次标记的起始位置与已标记到的位置，取较大值作为新的标记起始位置，这样可以避免重复标记之前已标记过的位置。</p><p>最后看末尾位置是否已标记，如果已标记，说明能够到达末尾。</p></li><li><p>参考代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canReach</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> minJump, <span class="keyword">int</span> maxJump)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=s.size(), j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(s[n<span class="number">-1</span>]==<span class="string">'1'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visited(n);</span><br><span class="line">        visited[<span class="number">0</span>]=<span class="literal">true</span>;<span class="comment">//初始必须标记位置0，否则循环中的判断会导致出错</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">'1'</span>) <span class="keyword">continue</span>; <span class="comment">//该位置的字符为'1'，则无法跳到此位置</span></span><br><span class="line">            <span class="keyword">if</span>(!visited[i]) <span class="keyword">continue</span>; <span class="comment">//此位置未标记，表示从起始位置无法跳到此位置</span></span><br><span class="line">            <span class="keyword">for</span>(j=max(j,i+minJump);j&lt;=min(i+maxJump,n<span class="number">-1</span>);j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[j]==<span class="string">'0'</span>) visited[j]=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(visited[n<span class="number">-1</span>]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> visited[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;第一题&quot;&gt;&lt;a href=&quot;#第一题&quot; class=&quot;headerlink&quot; title=&quot;第一题&quot;&gt;&lt;/a&gt;第一题&lt;/h4&gt;&lt;p&gt;LeetCode 55 Medium [&lt;a href=&quot;https://leetcode.com/problems/jump-game]&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/jump-game]&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;描述：&lt;/p&gt;
&lt;p&gt;给定一个非负整数数组 &lt;code&gt;nums&lt;/code&gt; ，你最初位于数组的 &lt;strong&gt;第一个下标&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;数组中的每个元素代表你在该位置可以跳跃的最大长度。&lt;/p&gt;
&lt;p&gt;判断你是否能够到达最后一个下标。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://e99net.github.io/categories/Algorithm/"/>
    
    
      <category term="DFS" scheme="https://e99net.github.io/tags/DFS/"/>
    
      <category term="Dynamic Programming" scheme="https://e99net.github.io/tags/Dynamic-Programming/"/>
    
      <category term="Greedy" scheme="https://e99net.github.io/tags/Greedy/"/>
    
      <category term="BFS" scheme="https://e99net.github.io/tags/BFS/"/>
    
      <category term="LeetCode" scheme="https://e99net.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>YAPI——api自动化测试平台</title>
    <link href="https://e99net.github.io/2021/06/12/the_problem_of_play_docker-yapi/"/>
    <id>https://e99net.github.io/2021/06/12/the_problem_of_play_docker-yapi/</id>
    <published>2021-06-12T11:21:15.100Z</published>
    <updated>2021-06-12T12:43:46.164Z</updated>
    
    <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>YAPI是一个很炫酷的企业级api自动化测试平台，最早是由<u>去哪儿</u>开发，后来移交给<u>百度</u>进行维护。</p><a id="more"></a><h4 id="记录几个玩docker-yapi时踩的坑"><a href="#记录几个玩docker-yapi时踩的坑" class="headerlink" title="记录几个玩docker-yapi时踩的坑"></a>记录几个玩docker-yapi时踩的坑</h4><p>在windows7中安装docker-yapi体验学习一下如何使用YAPI，在此过程中遇到如下几个问题：</p><ul><li><p>Error: getaddrinfo ENOTFOUND yapi.demo.qunar.com</p><p>此错误可忽略，貌似在配置文件中重定向到了<a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a></p></li><li><p>镜像build了好多次, 模块找不到</p><blockquote><p>internal/modules/cjs/loader.js:818<br>throw err;<br>^</p><p>Error: Cannot find module ‘/my-yapi/vendors/server/app.js’<br>at Function.Module._resolveFilename (internal/modules/cjs/loader.js:815:15)<br>at Function.Module._load (internal/modules/cjs/loader.js:667:27)<br>at Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:60:12)<br>at internal/main/run_main_module.js:17:47 {<br>code: ‘MODULE_NOT_FOUND’,<br>requireStack: []<br>}</p></blockquote><p>第一次修改docker-compose.yml里的command指令：</p><p>由</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">yapi:</span></span><br><span class="line"><span class="attr">build:</span></span><br><span class="line"><span class="attr">context:</span> <span class="string">./</span></span><br><span class="line"><span class="attr">dockerfile:</span> <span class="string">Dockerfile</span></span><br><span class="line"><span class="attr">image:</span> <span class="string">yapi</span></span><br><span class="line"><span class="comment"># 第一次启动使用</span></span><br><span class="line"><span class="comment"># command: "yapi server"</span></span><br><span class="line"><span class="comment"># 之后使用下面的命令</span></span><br><span class="line"><span class="attr">command:</span> <span class="string">"node /my-yapi/vendors/server/app.js"</span></span><br></pre></td></tr></table></figure><p>修改成</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">yapi:</span></span><br><span class="line"><span class="attr">build:</span></span><br><span class="line"><span class="attr">context:</span> <span class="string">./</span></span><br><span class="line"><span class="attr">dockerfile:</span> <span class="string">Dockerfile</span></span><br><span class="line"><span class="attr">image:</span> <span class="string">yapi</span></span><br><span class="line"><span class="comment"># 第一次启动使用</span></span><br><span class="line"><span class="attr">command:</span> <span class="string">"yapi server"</span></span><br><span class="line"><span class="comment"># 之后使用下面的命令</span></span><br><span class="line"><span class="comment"># command: "node /my-yapi/vendors/server/app.js"</span></span><br></pre></td></tr></table></figure></li><li><p>Operation not permitted.</p><p>此错误在web配置页面中显示为：</p><blockquote><p>Error: 连接数据库失败 Error: getaddrinfo ENOTFOUND mongo at GetAddrInfoReqWrap.onlookup [as oncomplete] (dns.js:66:26) { name: ‘MongoError’ }]</p><p>Error: 连接数据库失败, failed to connect to server [mongo:27017]</p></blockquote><p>查询一下docker中与mongo相关的环境（此处镜像为mongo:4，docker-yapi起的容器名为docker-yapi_mongo_1）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br><span class="line">docker ps -a</span><br></pre></td></tr></table></figure><p>发现docker-yapi的mongo环境没有启动成功。</p><p>这是因为Windows和OS X上的默认Docker设置使用VirtualBox VM来托管Docker守护程序。不幸的是，VirtualBox用于在主机系统和Docker容器之间共享文件夹的机制与MongoDB使用的内存映射文件不兼容（请参阅vbox bug，docs.mongodb.org和相关的jira.mongodb.org错误）。这意味着无法运行映射到主机的数据目录的MongoDB容器。原文见<a href="https://hub.docker.com/_/mongo" target="_blank" rel="noopener">Docker Hub中mongoDB官方镜像</a>对此的描述：</p><blockquote><p>WARNING (Windows &amp; OS X): The default Docker setup on Windows and OS X uses a VirtualBox VM to host the Docker daemon. Unfortunately, the mechanism VirtualBox uses to share folders between the host system and the Docker container is not compatible with the memory mapped files used by MongoDB (see vbox bug, docs.mongodb.org and related jira.mongodb.org bug). This means that it is not possible to run a MongoDB container with the data directory mapped to the host.</p></blockquote><p>解决方案是创建docker数据卷（Volume）作为保存持久化数据的目录，数据卷Volume可理解为虚拟磁盘。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 创建Volume虚拟磁盘</span><br><span class="line">docker volume create --name &lt;名称&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 删除Volume虚拟磁盘</span><br><span class="line">docker volume rm &lt;名称&gt;</span><br></pre></td></tr></table></figure><p>例如此处可以创建名为<em>mongodata</em>的数据卷，并与docker-yapi中配置的mongo数据目录建立映射：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker volume create --name mongodata</span><br><span class="line">docker run --name mongodb -v mongodata:/data/db -p 27017:27017 -d mongo:latest</span><br></pre></td></tr></table></figure></li><li><p>“msg”:”Authentication failed”,”attr”:{“mechanism”:”SCRAM-SHA-1”,”speculative”:false,”principalName”:”yapi”,”authenticationDatabase”:”yapi”,”error”:”UserNotFound: Could not find user \”yapi\” for db \”yapi\””}</p><p>此错误在web配置页面中显示为：</p><blockquote><p>Error: 连接数据库失败, Authentication failed.</p></blockquote><p>这是因为新版本的MongoDB权限管理更加严格，可手动登入docker中的mongo环境配置用户yapi的权限（根据docker-yapi自带的配置文件进行配置即可）</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h4&gt;&lt;p&gt;YAPI是一个很炫酷的企业级api自动化测试平台，最早是由&lt;u&gt;去哪儿&lt;/u&gt;开发，后来移交给&lt;u&gt;百度&lt;/u&gt;进行维护。&lt;/p&gt;
    
    </summary>
    
      <category term="memo" scheme="https://e99net.github.io/categories/memo/"/>
    
    
      <category term="Golang" scheme="https://e99net.github.io/tags/Golang/"/>
    
      <category term="Microservice" scheme="https://e99net.github.io/tags/Microservice/"/>
    
  </entry>
  
  <entry>
    <title>记录几个玩Golang微服务生态时踩的坑</title>
    <link href="https://e99net.github.io/2021/06/12/the_problem_of_play_go-related_framework/"/>
    <id>https://e99net.github.io/2021/06/12/the_problem_of_play_go-related_framework/</id>
    <published>2021-06-12T09:40:26.784Z</published>
    <updated>2021-06-12T11:10:28.320Z</updated>
    
    <content type="html"><![CDATA[<h4 id="go-micro"><a href="#go-micro" class="headerlink" title="go-micro"></a>go-micro</h4><ul><li>invalid character ‘\‘’ looking for beginning of value</li></ul><p>go micro官方文档给的实例里面</p><p>Make an RPC call via the CLI. The query is sent as json.<br><a id="more"></a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">micro call go.micro.srv.example Example.Call '&#123;"name": "John"&#125;'</span><br></pre></td></tr></table></figure><p>在windows控制台中执行会返回:</p><blockquote><p>invalid character ‘\‘’ looking for beginning of value</p></blockquote><p>经过测试，正确写法是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">micro call go.micro.srv.example Example.Call "&#123;\"name\":\"John\"&#125;"</span><br></pre></td></tr></table></figure><h4 id="consul-go-micro"><a href="#consul-go-micro" class="headerlink" title="consul + go-micro"></a>consul + go-micro</h4><ul><li>Go-Micro客户端请求报<strong>500错误和408错误</strong></li></ul><blockquote><p>{“id”:”go.micro.client”,”code”:500,”detail”:”service not found”}</p><p>{“id”:”go.micro.client”,”code”:408,”detail”:”call timeout: context deadline exceeded”,”status”:”Request Timeout”}</p></blockquote><p>查看一下服务列表和服务详细信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">micro list services</span><br><span class="line">比如得到结果：go.micro.srv.example</span><br><span class="line"></span><br><span class="line">micro get service go.micro.srv.example</span><br></pre></td></tr></table></figure><p>此现象有可能是因为服务没有在consul中注册成功所导致，这里提供一种解决思路：</p><p>确保在“告诉consul即将注册的服务的配置信息”时有以下配置项</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">registerService:=api.AgentServiceRegistration&#123;</span><br><span class="line">    ID:<span class="string">"xxx"</span>,</span><br><span class="line">    Tags:[]<span class="keyword">string</span>&#123;<span class="string">"grpc"</span>,<span class="string">"consul"</span>&#125;,</span><br><span class="line">    Name:<span class="string">"grpc And Consul"</span>,</span><br><span class="line">    Address:<span class="string">"127.0.0.1"</span>,</span><br><span class="line">    Port:<span class="number">8800</span>,</span><br><span class="line">    Check:&amp;api.AgentServiceCheck&#123;</span><br><span class="line">        CheckID:<span class="string">"consul grpc test"</span>,</span><br><span class="line">        TCP:<span class="string">"127.0.0.1:8800"</span>,</span><br><span class="line">        Timeout:<span class="string">"1s"</span>,</span><br><span class="line">        Interval:<span class="string">"5s"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h4><ul><li>VBoxManage.exe: error: Details: code E_FAIL (0x80004005)……</li></ul><p>windows7利用DockerToolBox安装Docker出现此问题，经测试，以下方法能解决此问题：</p><p>卸载掉VirtualBox，然后从<a href="https://www.virtualbox.org/wiki/Downloads" target="_blank" rel="noopener">https://www.virtualbox.org/wiki/Downloads</a> 更新最新版本安装，安装完成后再启动docker的客户端</p><h4 id="elasticsearch"><a href="#elasticsearch" class="headerlink" title="elasticsearch"></a>elasticsearch</h4><ul><li>post 中文数据到elasticsearch restful接口报json_parse_exception 问题</li></ul><blockquote><p>{“error”:{“root_cause”:[{“type”:”json_parse_exception”,”reason”:”Invalid UTF-8 middle byte……</p></blockquote><p>在windows7 cmd命令行下执行会报此错误，可尝试通过专业的<strong>postman</strong>工具进行操作</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;go-micro&quot;&gt;&lt;a href=&quot;#go-micro&quot; class=&quot;headerlink&quot; title=&quot;go-micro&quot;&gt;&lt;/a&gt;go-micro&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;invalid character ‘\‘’ looking for beginning of value&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;go micro官方文档给的实例里面&lt;/p&gt;
&lt;p&gt;Make an RPC call via the CLI. The query is sent as json.&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="memo" scheme="https://e99net.github.io/categories/memo/"/>
    
    
      <category term="Golang" scheme="https://e99net.github.io/tags/Golang/"/>
    
      <category term="Microservice" scheme="https://e99net.github.io/tags/Microservice/"/>
    
  </entry>
  
  <entry>
    <title>手写堆(以小根堆为例)</title>
    <link href="https://e99net.github.io/2021/06/12/write_a_heap/"/>
    <id>https://e99net.github.io/2021/06/12/write_a_heap/</id>
    <published>2021-06-12T08:19:51.992Z</published>
    <updated>2021-06-12T11:14:20.092Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基础准备"><a href="#基础准备" class="headerlink" title="基础准备"></a>基础准备</h3><h4 id="一个数据结构"><a href="#一个数据结构" class="headerlink" title="一个数据结构"></a>一个数据结构</h4><p>堆其实是一棵完全二叉树，</p><p>用一个<strong>一维数组</strong>保存堆元素，</p><p>下标从1开始存（根节点是1），x的左儿子是2x，x的右儿子是2x+1。</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> h[N], size;</span><br></pre></td></tr></table></figure><h4 id="两个关键-heapify堆化"><a href="#两个关键-heapify堆化" class="headerlink" title="两个关键(heapify堆化)"></a>两个关键(heapify堆化)</h4><ul><li><p>up</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(u/<span class="number">2</span> &amp;&amp; h[u/<span class="number">2</span>]&gt;h[u]) &#123;</span><br><span class="line">        swap(h[u/<span class="number">2</span>],h[u]);</span><br><span class="line">        u/=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>down</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u*<span class="number">2</span>&lt;=size &amp;&amp; h[t]&gt;h[u*<span class="number">2</span>]) t=u*<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(u*<span class="number">2</span>+<span class="number">1</span>&lt;=size &amp;&amp; h[t]&gt;h[u*<span class="number">2</span>+<span class="number">1</span>]) t=u*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(t!=u) &#123;</span><br><span class="line">        swap(h[t],h[u]);</span><br><span class="line">        down(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="五个操作"><a href="#五个操作" class="headerlink" title="五个操作"></a>五个操作</h4><ul><li><p>插入一个数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">heap[++size]=x; up(size);</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>求集合当中的最小值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">heap[<span class="number">1</span>];</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>删除最小值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">heap[<span class="number">1</span>]=heap[size];size--;down(<span class="number">1</span>);</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>删除任意一个元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">heap[k]=heap[size];size--;up(k);down(k);</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>修改任意一个元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">heap[k]=x;up(k);down(k);</span><br></pre></td></tr></table></figure></li></ul><h3 id="来做几道题练练手"><a href="#来做几道题练练手" class="headerlink" title="来做几道题练练手"></a>来做几道题练练手</h3><h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><ul><li><p>描述：</p><p>输入一个长度为 n 的整数数列，从小到大输出前 m 小的数。</p></li><li><p>输入：</p><p>第一行包含整数 n 和 m。</p><p>第二行包含 n 个整数，表示整数数列。</p></li><li><p>输出：</p><p>共一行，包含 m 个整数，表示整数数列中前 m 小的数。</p></li><li><p>数据范围：</p><p>$1≤m≤n≤10^5.$</p><p>$1≤数列中元素≤10^9$</p></li><li><p>样例输入：</p><p>5 3</p><p>4 5 1 3 2</p></li><li><p>样例输出：</p><p>1 2 3</p></li><li><p>样例解释：</p></li><li><p>参考代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> h[N],size;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> t=u;</span><br><span class="line"><span class="keyword">if</span>(u*<span class="number">2</span>&lt;=size &amp;&amp; h[t]&gt;h[u*<span class="number">2</span>]) t=u*<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(u*<span class="number">2</span>+<span class="number">1</span>&lt;=size &amp;&amp; h[t]&lt;h[u*<span class="number">2</span>+<span class="number">1</span>]) t=u*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(t!=u) &#123;</span><br><span class="line">        swap(h[u],h[t]);</span><br><span class="line">        down(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(u/<span class="number">2</span> &amp;&amp; h[u/<span class="number">2</span>]&gt;h[u]) &#123;</span><br><span class="line">        swap(h[u/<span class="number">2</span>],h[u]);</span><br><span class="line">        u/=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;h[i]);</span><br><span class="line">    size=n;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 一种建堆方式：从n/2开始down，一直到1，时间复杂度是O(n) </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n/<span class="number">2</span>;i;i--) down(i);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,h[<span class="number">1</span>]);</span><br><span class="line">        h[<span class="number">1</span>]=h[size];</span><br><span class="line">        size--;</span><br><span class="line">        down(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="模拟堆"><a href="#模拟堆" class="headerlink" title="模拟堆"></a>模拟堆</h4><ul><li><p>描述：</p><p>维护一个集合，初始时集合为空，支持如下几种操作：</p></li></ul><ol><li>“I x”，插入一个数x；</li><li>“PM”，输出当前集合中的最小值；</li><li>“DM”，删除当前集合中的最小值（当最小值不唯一时，删除最早插入的最小值）；</li><li>“D k”，删除第k个插入的数；</li><li>“C k x”，修改第k个插入的数，将其变为x；</li></ol><p>  现在要进行N次操作，对于所有第2个操作，输出当前集合的最小值。</p><ul><li><p>输入：</p><p>第一行包含整数N。<br>接下来N行，每行包含一个操作指令，操作指令为“I x”，“PM”，“DM”，“D k”或“C k x”中的一种。</p></li><li><p>输出：</p><p>对于每个输出指令“PM”，输出一个结果，表示当前集合中的最小值。<br>每个结果占一行。</p></li><li><p>数据范围：</p><p>$1\le N \le 10^5$</p><p>$-10^9 \le x \le 10^9$</p><p>数据保证合法。</p></li><li><p>样例输入：</p><p>10<br>I -10<br>PM<br>I -10<br>D 1<br>C 2 8<br>I 6<br>PM<br>DM</p></li><li><p>样例输出：</p><p>-10</p><p>6</p></li><li><p>参考代码:</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟（带映射版的）堆各项操作的模板</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ph[i]:第i个插入的数在堆中的位置</span></span><br><span class="line"><span class="comment">// hp[i]:堆中第i个位置的数的插入时刻</span></span><br><span class="line"><span class="keyword">int</span> h[N],hp[N],ph[N],size;</span><br><span class="line"></span><br><span class="line"><span class="comment">//由于要修改或删除堆中任意位置的元素，所以变得复杂</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_swap</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    swap(ph[hp[a]],ph[hp[b]]);</span><br><span class="line">    swap(hp[a],hp[b]);</span><br><span class="line">    swap(h[a],h[b]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t=u;</span><br><span class="line">    <span class="keyword">if</span>(u*<span class="number">2</span>&lt;=size &amp;&amp; h[u*<span class="number">2</span>]&lt;h[t]) t=u*<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(u*<span class="number">2</span>+<span class="number">1</span>&lt;=size &amp;&amp; h[u*<span class="number">2</span>+<span class="number">1</span>]&lt;h[t]) t=u*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(u!=t) &#123;</span><br><span class="line">        heap_swap(u,t);</span><br><span class="line">        down(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(u/<span class="number">2</span> &amp;&amp; h[u/<span class="number">2</span>]&gt;h[u]) &#123;</span><br><span class="line">        heap_swap(u/<span class="number">2</span>,u);</span><br><span class="line">        u/=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> op[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">int</span> k,x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,op);</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op,<span class="string">"I"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">            size++;</span><br><span class="line">            m++;</span><br><span class="line">            <span class="comment">//第m个插入的数在堆的size位置，堆中size位置上的数是第m个插入的数</span></span><br><span class="line">            ph[m]=size,hp[size]=m;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 一种建堆方式：一个一个插，时间复杂度是O(nlogn)</span></span><br><span class="line">            h[size]=x;</span><br><span class="line">            up(size);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op,<span class="string">"PM"</span>)) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,h[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op,<span class="string">"DM"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            heap_swap(<span class="number">1</span>,size);</span><br><span class="line">            size--;</span><br><span class="line">            down(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op,<span class="string">"D"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;k);</span><br><span class="line">            k=ph[k];<span class="comment">//找到第k个插入的数所对应的堆里面的位置</span></span><br><span class="line">            heap_swap(k,size);</span><br><span class="line">            size--;</span><br><span class="line">            down(k),up(k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;k,&amp;x);</span><br><span class="line">            k=ph[k];</span><br><span class="line">            h[k]=x;</span><br><span class="line">            down(k),up(k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;基础准备&quot;&gt;&lt;a href=&quot;#基础准备&quot; class=&quot;headerlink&quot; title=&quot;基础准备&quot;&gt;&lt;/a&gt;基础准备&lt;/h3&gt;&lt;h4 id=&quot;一个数据结构&quot;&gt;&lt;a href=&quot;#一个数据结构&quot; class=&quot;headerlink&quot; title=&quot;一个数据结构&quot;&gt;&lt;/a&gt;一个数据结构&lt;/h4&gt;&lt;p&gt;堆其实是一棵完全二叉树，&lt;/p&gt;
&lt;p&gt;用一个&lt;strong&gt;一维数组&lt;/strong&gt;保存堆元素，&lt;/p&gt;
&lt;p&gt;下标从1开始存（根节点是1），x的左儿子是2x，x的右儿子是2x+1。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://e99net.github.io/categories/Algorithm/"/>
    
    
      <category term="Heap" scheme="https://e99net.github.io/tags/Heap/"/>
    
  </entry>
  
  <entry>
    <title>千万级大表的MySQL优化</title>
    <link href="https://e99net.github.io/2021/01/19/mysqlOptimizationOfLargeTable/"/>
    <id>https://e99net.github.io/2021/01/19/mysqlOptimizationOfLargeTable/</id>
    <published>2021-01-19T14:52:53.672Z</published>
    <updated>2021-01-19T15:14:43.912Z</updated>
    
    <content type="html"><![CDATA[<h3 id="SQL语句优化"><a href="#SQL语句优化" class="headerlink" title="SQL语句优化"></a>SQL语句优化</h3><ul><li>避免select * <ul><li>在解析的过程中，会将“*”依次转换成所有的列名，这个工作是通过查询数据字典完成的，这意味着将耗费更多的时间</li><li>应该养成一个需要什么就取什么的好习惯</li></ul></li></ul><a id="more"></a><ul><li><p>ORDER BY语句优化 </p><ul><li>任何在ORDER BY语句的非索引项或者有计算表达式都将降低查询速度</li><li>方法：<ul><li>重写ORDER BY语句以使用索引</li><li>为所使用的列建立另外一个索引</li><li>绝对避免在ORDER BY子句中使用表达式</li></ul></li></ul></li><li><p>GROUP BY语句优化</p><p>提高GROUP BY语句的效率, 可以通过将不需要的记录在GROUP BY 之前过滤掉（如下例，先用where语句过滤掉一部分数据）</p><p>低效：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> JOB, <span class="keyword">AVG</span>(SAL)</span><br><span class="line"><span class="keyword">FROM</span> EMP</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">by</span> JOB</span><br><span class="line"><span class="keyword">HAVING</span> JOB = <span class="string">'PRESIDENT'</span></span><br><span class="line"><span class="keyword">OR</span> JOB = <span class="string">'MANAGER'</span></span><br></pre></td></tr></table></figure><p>高效：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> JOB, <span class="keyword">AVG</span>(SAL)</span><br><span class="line"><span class="keyword">FROM</span> EMP</span><br><span class="line"><span class="keyword">WHERE</span> JOB = <span class="string">'PRESIDENT'</span></span><br><span class="line"><span class="keyword">OR</span> JOB = <span class="string">'MANAGER'</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">by</span> JOB</span><br></pre></td></tr></table></figure></li><li><p>用exists代替in</p><p>很多时候用exists代替in是一个好的选择，如</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">num</span> <span class="keyword">from</span> a <span class="keyword">where</span> <span class="keyword">num</span> <span class="keyword">in</span>(<span class="keyword">select</span> <span class="keyword">num</span> <span class="keyword">from</span> b)</span><br></pre></td></tr></table></figure><p>用下面的语句替换：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">num</span> <span class="keyword">from</span> a <span class="keyword">where</span> <span class="keyword">exists</span>(<span class="keyword">select</span> <span class="number">1</span> <span class="keyword">from</span> b <span class="keyword">where</span> <span class="keyword">num</span>=a.num)</span><br></pre></td></tr></table></figure></li><li><p>尽量使用varchar/nvarchar代替char/nchar </p><ul><li>变长字段存储空间小，可以节省存储空间</li><li>对于查询来说，在一个相对较小的字段内搜索效率显然要高些</li></ul></li><li><p>能用DISTINCT的就不用GROUP BY</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> OrderID <span class="keyword">FROM</span> Details <span class="keyword">WHERE</span> UnitPrice &gt; <span class="number">10</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> OrderID</span><br></pre></td></tr></table></figure><p>可改为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> OrderID <span class="keyword">FROM</span> Details <span class="keyword">WHERE</span> UnitPrice &gt; <span class="number">10</span></span><br></pre></td></tr></table></figure></li><li><p>能用UNION ALL就不要用UNION</p><p>UNION ALL不执行SELECT DISTINCT函数，这样就会减少很多不必要的资源。（UNION ALL允许重复）</p></li><li><p>在join表的时候使用相同类型的字段，并将其索引</p><ul><li>如果应用程序有很多join查询，应该确认两个表中join的字段是被建过索引的。这样，MySQL内部会启动优化join的SQL语句的机制</li><li>被用来join的字段应该具有相同的类型。例如，如果把DECIMAL字段和一个INT字段join在一起，MySQL将无法使用它们的索引。对于那些STRING类型，还需要有相同的字符集才行（两个表的字符集有可能不一样）</li></ul></li></ul><h3 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h3><ul><li>在<strong>适合建索引的地方</strong>建立索引（索引并非越多越好）<ul><li>适合建索引的情况<ul><li>主键会自动建立唯一索引</li><li>频繁作为 where 条件语句查询的字段</li><li>关联字段，例如外键字段</li><li>排序字段，因为排序字段若通过索引去访问将大大提高排序速度（索引干两件事：<br>检索和排序）</li><li>分组字段，因为分组的前提是排序</li><li>统计字段，例如 count()、max()</li><li>高并发下倾向于创建组合索引，而不是单键索引。组合索引是由多个字段构成的索<br>引，组合索引中的字段顺序是非常重要的，越是唯一的字段越是要靠前（根据最左<br>前缀准则）。</li></ul></li><li>不适合建索引的情况<ul><li>表记录太少的情况下</li><li>频繁更新的字段、经常增删改的字段，因为修改性能和检索性能是互相矛盾的，每<br>次更新不仅会更新记录还会更新索引</li><li>where 条件中用不到的字段，在查询中很少使用或参考的列</li><li>数据重复且分布比较均匀的字段，即唯一性太差的字段，例如性别、真假值</li><li>参与计算的列</li></ul></li></ul></li><li>避免有索引但未被用到的情况（索引失效时，MySQL 会进行全表扫描）<ul><li>无查询条件</li><li>一些关键字会导致索引失效<ul><li>where 语句中使用&lt;&gt;、!=、not in、not exist、is null、is not unll（使用&gt;或<br>&lt;会比较高效）</li><li>where 语句中使用 or（注意：or 中所有的字段都加上索引才会使用索引）</li><li>以通配符“%”开头的 like 查询（注意：以“%”结尾的 like 查询会使用索引）</li><li>避免 where 条件不符合最左前缀原则，最左前缀原则：mysql 会一直向右匹配直到遇到<br>范围查询(&gt;、&lt;、between、like)就停止匹配，比如 a = 1 and b = 2 and c &gt; 3 and d<br>= 4 如果建立(a,b,c,d)顺序的索引，d 是用不到索引的，如果建立(a,b,d,c)的索引则<br>都可以用到，a,b,d 的顺序可以任意调整（IN 和=可以乱序）。（多列索引没有遵循最左<br>匹配原则，未使用第一个）</li><li>如果列类型是字符串，那一定要在条件中将数据用引号引起来,否则不使用索引</li><li>隐式转换会导致索引失效，比如数据库中的 id 是 number 类型，在查询时却出现“……<br>where id=”123””。</li><li>对索引字段应用内部函数</li><li>对索引字段进行运算</li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;SQL语句优化&quot;&gt;&lt;a href=&quot;#SQL语句优化&quot; class=&quot;headerlink&quot; title=&quot;SQL语句优化&quot;&gt;&lt;/a&gt;SQL语句优化&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;避免select * &lt;ul&gt;
&lt;li&gt;在解析的过程中，会将“*”依次转换成所有的列名，这个工作是通过查询数据字典完成的，这意味着将耗费更多的时间&lt;/li&gt;
&lt;li&gt;应该养成一个需要什么就取什么的好习惯&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Database" scheme="https://e99net.github.io/categories/Database/"/>
    
    
      <category term="MySQL" scheme="https://e99net.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Go语言做的不好的几个地方</title>
    <link href="https://e99net.github.io/2021/01/19/weaknessOfGolang/"/>
    <id>https://e99net.github.io/2021/01/19/weaknessOfGolang/</id>
    <published>2021-01-19T14:22:08.223Z</published>
    <updated>2021-01-19T14:44:07.044Z</updated>
    
    <content type="html"><![CDATA[<h3 id="浮点型比其他语言要差"><a href="#浮点型比其他语言要差" class="headerlink" title="浮点型比其他语言要差"></a>浮点型比其他语言要差</h3><ul><li><p>运算时，计算结果不准</p></li><li><p>四舍五入时，用的是银行舍入法，和其他语言四舍五入的值对不上。解决方法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//四舍五入 取精度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ToFixed</span><span class="params">(f <span class="keyword">float64</span>,places <span class="keyword">int</span>)</span> <span class="title">float64</span></span>&#123;</span><br><span class="line">    shift := math.Pow(<span class="number">10</span>, <span class="keyword">float64</span>(places))</span><br><span class="line">    fv := <span class="number">0.0000000001</span> + f        <span class="comment">//对浮点数产生.xxx999999999 计算不准进行处理</span></span><br><span class="line">    <span class="keyword">return</span> math.Floor(fv * shift + <span class="number">.5</span>) / shift</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><h3 id="自带的json不好用"><a href="#自带的json不好用" class="headerlink" title="自带的json不好用"></a>自带的json不好用</h3><ul><li>Golang中自带的json包可以用来解析json数据，但是Golang自带的json解析是通过反射机制实现json数据的解析的，这样就造成了解析性能的低下</li><li>json包在解析本地配置文件的场景下使用的较多，但在一些高并发的场景下就显得不足</li><li><p>对于json的解析，可以选择使用<strong>easyjson</strong>包，避免使用反射，从而提高解析的性能，在众多Golang高性能解析json的框架中，easyjson名列前茅，比go语言自带的json序列化快几倍</p><ul><li><p>easyjson在解析json数据的时候，并不是使用反射机制，而只针对预先定义好的json结构体对输入的json字符串进行纯字符串的截取，并将对应的json字段赋值给结构体</p></li><li><p>easyjson在解析json数据的时候虽然并不会使用反射机制，但是在使用easyjson生成解析代码的时候，easyjson还是会使用反射机制的，所以我们需要为每个解析字段指定FieldTag，否则easyjson就会将变量名当作解析字段生成解析代码，当然解析代码生成之后，easyjson解析json数据就和反射机制没有关系了</p></li><li>使用Benchmark测试Golang内置的json包以及eashjson包的性能，解析相同的json数据并对解析好的Struct进行json转换， 测试结果表明，easyjson的运行时间大约是json包的三分之一，easyjson在单次运行占用内存和内存分配次数上也要比Golang内置的json包表现好很多</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;浮点型比其他语言要差&quot;&gt;&lt;a href=&quot;#浮点型比其他语言要差&quot; class=&quot;headerlink&quot; title=&quot;浮点型比其他语言要差&quot;&gt;&lt;/a&gt;浮点型比其他语言要差&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;运算时，计算结果不准&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;四舍五入时，用的是银行舍入法，和其他语言四舍五入的值对不上。解决方法如下：&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//四舍五入 取精度&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ToFixed&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(f &lt;span class=&quot;keyword&quot;&gt;float64&lt;/span&gt;,places &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;)&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;float64&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    shift := math.Pow(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;float64&lt;/span&gt;(places))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    fv := &lt;span class=&quot;number&quot;&gt;0.0000000001&lt;/span&gt; + f        &lt;span class=&quot;comment&quot;&gt;//对浮点数产生.xxx999999999 计算不准进行处理&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; math.Floor(fv * shift + &lt;span class=&quot;number&quot;&gt;.5&lt;/span&gt;) / shift&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="memo" scheme="https://e99net.github.io/categories/memo/"/>
    
    
      <category term="Go" scheme="https://e99net.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>macOS新手上路</title>
    <link href="https://e99net.github.io/2020/10/05/new_to_macOS/"/>
    <id>https://e99net.github.io/2020/10/05/new_to_macOS/</id>
    <published>2020-10-04T18:46:33.000Z</published>
    <updated>2020-10-04T18:46:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>安装软件</p><ul><li>Hands Off!</li><li>Proxifier</li><li>The Unarchiver</li><li>Itsycal</li><li>BetterTouchTool</li><li>Alfred 4</li><li>HandShaker</li></ul><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;安装软件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Hands Off!&lt;/li&gt;
&lt;li&gt;Proxifier&lt;/li&gt;
&lt;li&gt;The Unarchiver&lt;/li&gt;
&lt;li&gt;Itsycal&lt;/li&gt;
&lt;li&gt;BetterTouchTool&lt;/li&gt;
&lt;li&gt;Alfred 4&lt;/li&gt;
&lt;li&gt;HandShaker&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="memo" scheme="https://e99net.github.io/categories/memo/"/>
    
    
      <category term="Water" scheme="https://e99net.github.io/tags/Water/"/>
    
  </entry>
  
  <entry>
    <title>前n小的和</title>
    <link href="https://e99net.github.io/2020/03/15/first_n_small_sum/"/>
    <id>https://e99net.github.io/2020/03/15/first_n_small_sum/</id>
    <published>2020-03-15T05:07:25.941Z</published>
    <updated>2020-03-15T05:21:42.235Z</updated>
    
    <content type="html"><![CDATA[<h4 id="两序列前n小的两数和"><a href="#两序列前n小的两数和" class="headerlink" title="两序列前n小的两数和"></a>两序列前n小的两数和</h4><ul><li>描述：有两个长度都是N的序列A和B，在A和B中各取一个数相加可以得到$N^2$个和，求这$N^2$个和中最小的N个。</li></ul><a id="more"></a><ul><li>输入：</li></ul><p>第一行输入一个正整数N，$1 \le N \le 100000$，表示序列长度；</p><p>第二行输入N个整数$A_i$，满足$A_i \le A_{i+1}$且$A_i \le 10^9$；</p><p>第二行输入N个整数$B_i$，满足$B_i \le B_{i+1}$且$B_i \le 10^9$。</p><ul><li>输出：</li></ul><p>输出仅一行，包含N个整数，从小到大输出这N个最小的和，相邻数字之间用空格隔开。</p><ul><li>样例输入：</li></ul><p>3<br>2 6 6<br>1 4 8</p><ul><li>样例输出：</li></ul><p>3 6 7</p><ul><li>解题思路：</li></ul><p>由题意可得A和B是两个升序排列的序列，其中：</p><p>A[1]+B[1] &lt;= A[2]+B[1] &lt;= … &lt;= A[N]+B[1]</p><p>A[1]+B[2] &lt;= A[2]+B[2] &lt;= … &lt;= A[N]+B[2]</p><p>……</p><p>A[1]+B[N] &lt;= A[2]+B[N] &lt;= … &lt;= A[N]+B[N]</p><p>接下来，就相当于要将这N个有序队列进行合并排序：</p><p>首先，将这N个队列中的第一个元素放入一个堆中；</p><p>然后；每次取出堆中的最小值。若这个最小值来自于第k个队列，那么，就将第k个队列的下一个元素放入堆中。</p><p>时间复杂度：O(NlogN)。</p><p>堆可用优先队列实现，此题需要的是一个小顶堆。</p><ul><li>参考代码:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=1e5+10;</span><br><span class="line">typedef pair&lt;int,int&gt; PII;</span><br><span class="line">int n;</span><br><span class="line">int a[N],b[N],next_of_a[N];</span><br><span class="line">int i;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt; &gt; pq;//小顶堆</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(i=1;i&lt;=n;i++)</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">    for(i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;b[i]);</span><br><span class="line">        next_of_a[i]=2;</span><br><span class="line">        pq.push(&#123;a[1]+b[i],i&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    while(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%d &quot;,pq.top().first);</span><br><span class="line">        i=pq.top().second;</span><br><span class="line">        pq.pop();</span><br><span class="line">        pq.push(&#123;a[next_of_a[i]++]+b[i],i&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;两序列前n小的两数和&quot;&gt;&lt;a href=&quot;#两序列前n小的两数和&quot; class=&quot;headerlink&quot; title=&quot;两序列前n小的两数和&quot;&gt;&lt;/a&gt;两序列前n小的两数和&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;描述：有两个长度都是N的序列A和B，在A和B中各取一个数相加可以得到$N^2$个和，求这$N^2$个和中最小的N个。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://e99net.github.io/categories/Algorithm/"/>
    
    
      <category term="Heap" scheme="https://e99net.github.io/tags/Heap/"/>
    
  </entry>
  
  <entry>
    <title>数组跳跃问题</title>
    <link href="https://e99net.github.io/2019/11/17/simpleproblemofjump/"/>
    <id>https://e99net.github.io/2019/11/17/simpleproblemofjump/</id>
    <published>2019-11-17T06:01:03.776Z</published>
    <updated>2020-03-15T05:06:51.634Z</updated>
    
    <content type="html"><![CDATA[<h4 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a>跳跃游戏</h4><ul><li>描述：给定数组arr，arr[i]=k代表可以从位置i向右跳1 ~ k个距离。比如，arr[2]=3，代表从位置2可以跳到位置3、位置4或位置5。如果从位置0出发，返回最少跳几次能跳到arr最后的位置上。如果arr长度为N，要求实现时间复杂度为O(N)、额外空间复杂度为O(1)的解法。</li></ul><a id="more"></a><ul><li>输入：</li></ul><p>第一行输入一个正整数N，$1 \le N \le 100$，表示数组的元素数。</p><p>第二行输入N个数，用空格隔开，表示一个数组中的所有数。</p><ul><li>输出：</li></ul><p>输出一个整数，表示最少跳几次。</p><ul><li>样例输入：</li></ul><p>6<br>3 2 3 1 1 4</p><ul><li>样例输出：</li></ul><p>2</p><ul><li>样例解释：</li></ul><p>arr[0]=3，选择跳到位置2；arr[2]=3，可以跳到最后的位置。所以返回2。</p><ul><li>解题思路：</li></ul><p>这道题是一道简单的不能再简单的“水题”，可以说是动态规划的入门题。会者不难，难者不会。</p><p>思路太简单，略，←_←。直接上代码。<br>感觉和剑指offer上“股票的最大利润”一题有点像。</p><ul><li>参考代码:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int jump(vector&lt;int&gt;&amp; arr) &#123;</span><br><span class="line">        if(arr.empty()) return 0;</span><br><span class="line">        int jump=0;</span><br><span class="line">        int cur=0;</span><br><span class="line">        int next=0;</span><br><span class="line">        for(int i=0;i&lt;arr.size();i++) &#123;</span><br><span class="line">            if(cur&lt;i) &#123;</span><br><span class="line">                jump++;</span><br><span class="line">                cur=next;</span><br><span class="line">            &#125;</span><br><span class="line">            next=max(next,i+arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return jump;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;跳跃游戏&quot;&gt;&lt;a href=&quot;#跳跃游戏&quot; class=&quot;headerlink&quot; title=&quot;跳跃游戏&quot;&gt;&lt;/a&gt;跳跃游戏&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;描述：给定数组arr，arr[i]=k代表可以从位置i向右跳1 ~ k个距离。比如，arr[2]=3，代表从位置2可以跳到位置3、位置4或位置5。如果从位置0出发，返回最少跳几次能跳到arr最后的位置上。如果arr长度为N，要求实现时间复杂度为O(N)、额外空间复杂度为O(1)的解法。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://e99net.github.io/categories/Algorithm/"/>
    
    
      <category term="Dynamic Programming" scheme="https://e99net.github.io/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>一道算法编程题</title>
    <link href="https://e99net.github.io/2019/11/10/liulishuo/"/>
    <id>https://e99net.github.io/2019/11/10/liulishuo/</id>
    <published>2019-11-10T12:12:51.364Z</published>
    <updated>2019-11-10T12:31:33.803Z</updated>
    
    <content type="html"><![CDATA[<h4 id="火车站台数量"><a href="#火车站台数量" class="headerlink" title="火车站台数量"></a>火车站台数量</h4><ul><li>描述：假设已知某个火车站的所有过往列车的到达arrival和离开departure时间（同一天），如果要求所有列车都不等待直接进站，问至少需要多少个站台。无需考虑晚点等特殊情况。</li></ul><a id="more"></a><ul><li>输入：</li></ul><p>第一行输入一个正整数N，$1 \le N \le 100$，表示过往列车数。</p><p>第二行输入N个字符串，每个字符串表示列车的到达时间，字符串之间用空格隔开。</p><p>第三行输入N个字符串，每个字符串表示列车的离开时间，字符串之间用空格隔开。</p><ul><li>输出：</li></ul><p>输出一个整数，表示最少需要的站台数。</p><ul><li>样例输入：</li></ul><p>6<br>9:00 9:40 9:50 11:00 15:00 18:00<br>9:10 12:00 11:20 11:30 19:00 20:00</p><ul><li>样例输出：</li></ul><p>3</p><ul><li>样例解释：</li></ul><p>最多有3辆列车同时进站（在11:00到11:20之间），所以至少需要3个火车站台。</p><ul><li>解题思路：</li></ul><p>题目要求找到所有时间中同时在车站的列车的最大数量。一个简单的方案是逐个检查每个车辆的停发时间段，然后看有多少个时间段区间与其有重合，记录最多的重合区间数目，即为待求解的答案。易知，此方法的时间复杂度为O(n^2)。<br>认真思考后，其实可以有O(nlog_2 n)时间复杂度的方法。思路是将所有的事件 (到达或离开)按时间顺序排序，然后只记录当前还在车站（未离开的）列车。所有时间点中最多数量列车即待求解的答案。<br>例如，对于上面样例输入，将所有事件按时间排序后得到：</p><table><thead><tr><th>时间</th><th>事件</th><th>需要的站台数量</th></tr></thead><tbody><tr><td>9:00</td><td>Arrival</td><td>1</td><td></td></tr><tr><td>9:10</td><td>Departure</td><td>0</td><td></td></tr><tr><td>9:40</td><td>Arrival</td><td>1</td><td></td></tr><tr><td>9:50</td><td>Arrival</td><td>2</td><td></td></tr><tr><td>11:00</td><td>Arrival</td><td><strong>3</strong></td><td></td></tr><tr><td>11:20</td><td>Departure</td><td>2</td><td></td></tr><tr><td>11:30</td><td>Departure</td><td>1</td><td></td></tr><tr><td>12:00</td><td>Departure</td><td>0</td><td></td></tr><tr><td>15:00</td><td>Arrival</td><td>1</td><td></td></tr><tr><td>18:00</td><td>Arrival</td><td>2</td><td></td></tr><tr><td>19:00</td><td>Departure</td><td>1</td><td></td></tr><tr><td>20:00</td><td>Departure</td><td>0</td><td></td></tr></tbody></table><p>最多需要的站台数量是3，时间段为11:00 ~ 11:20</p><p>注意，在算法实现时，只需对到达时间arr数组，和离开时间dep数组进行单独排序，然后将两个有序数组再进行归并操作。</p><ul><li>参考代码:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;火车站台数量&quot;&gt;&lt;a href=&quot;#火车站台数量&quot; class=&quot;headerlink&quot; title=&quot;火车站台数量&quot;&gt;&lt;/a&gt;火车站台数量&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;描述：假设已知某个火车站的所有过往列车的到达arrival和离开departure时间（同一天），如果要求所有列车都不等待直接进站，问至少需要多少个站台。无需考虑晚点等特殊情况。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://e99net.github.io/categories/Algorithm/"/>
    
    
      <category term="Simulation" scheme="https://e99net.github.io/tags/Simulation/"/>
    
  </entry>
  
  <entry>
    <title>两道算法编程题</title>
    <link href="https://e99net.github.io/2019/11/10/webank/"/>
    <id>https://e99net.github.io/2019/11/10/webank/</id>
    <published>2019-11-10T11:15:19.892Z</published>
    <updated>2019-11-10T12:07:22.337Z</updated>
    
    <content type="html"><![CDATA[<h4 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h4><ul><li>描述：</li></ul><p>你需要对一个数组进行排序（升序），每一次，你可以将一个数移动到任意位置，这一次操作的代价是这个数的大小。最少需要多少代价才能将整个数组排序？</p><a id="more"></a><ul><li>输入：</li></ul><p>第一行输入一个正整数N，$1 \le N \le 100$，表示数组元素个数。</p><p>第二行输入N个整数，整数之间用空格隔开。</p><ul><li>输出：</li></ul><p>输出一个整数，表示将整个数组排序的最小代价。</p><ul><li>样例输入：</li></ul><p>4<br>8 1 2 3</p><ul><li>样例输出：</li></ul><p>6</p><ul><li>解题思路：</li></ul><p>求出里面和最大的升序数组，用数组和减去它就是结果了。因为最终的数组和原来的数组，差别就在于那些移动了位置的数，要让移动位置的代价最小，当然就是让移动位置的数的和最小，等价于不移动位置的数的和最大，而最大的升序数组和就是能够不移动位置的最大子数组。<br>最大的升序数组和可用dp求出。</p><ul><li>参考代码:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="取棋子"><a href="#取棋子" class="headerlink" title="取棋子"></a>取棋子</h4><ul><li>描述：</li></ul><p>西西有一个N行N列的棋盘，其中某些格子上放有棋子（黑子或白子）。西西不希望棋盘上有两个相邻的格子放 着颜色相同的棋子，与第i行 第j列的格子相邻的格子为：</p><p>第i-1行第j列的格子（当i&gt;1时）；</p><p>第i+1行第j列的格子（当i&lt;N时）；</p><p>第i行第i-1列的格子（当i&gt;1时）；</p><p>第i行第i+1列的格子（当i&lt;N时）。</p><p>现在，西西可以取走棋盘上的某些棋子，使得剩下的棋子中，任意两个颜色相同的棋子所在的格子不相邻。<br>那么， 棋盘上最多剩下多少个棋子？</p><ul><li>输入：</li></ul><p>第一行输入一个正整数N，$N \le 50$，表示棋盘的行列数。</p><p>接下来的N行，每行有N个整数，整数之间用空格隔开，表示棋盘每行每列防止棋子的情况。<br>整数取值只能是0、1、2，分别表示该格未放棋子、放的是黑子、放的是白子。</p><ul><li>输出：</li></ul><p>输出一个整数，表示棋盘上最多剩下的棋子数。</p><ul><li>样例输入：</li></ul><ul><li>样例输出：</li></ul><ul><li>解题思路：</li></ul><p>给每个棋子设置一个度(0 1 2 3 4)。一个棋子周围每有一个同样颜色的棋子，那就让它的度加1，最小为0，最大为4。然后从棋盘里逐个删掉度是4的并且更新棋盘(周围的同样颜色的棋子度要剪1)，然后删掉度是3的，以此类推知道所有棋子度是0，看这时候删了多少棋子。</p><p>用4个hash set分别保存度为1 2 3 4的点，每删一个度为4的点，就更新所有它周围的节点，然后再继续进行删除。对黑的进行一次删除，再对白的进行一次删除，就能求出结果了。</p><p>这个方法对相连的度为4的点还要额外讨论。<br><img src="/2019/11/10/webank/20191110200143.jpg" alt=""><br>图中的两个点度都为4，但删绿的总共删四个，删红的 总共删五个。<br>所以又想出一个方法：先取连通的区域 统计如果在国际象棋棋盘中 黑格和白格点数 然后删少的。<br>在上图中就是黑7白4，删白的。<br><img src="/2019/11/10/webank/20191110200530.jpg" alt=""><br>五个同色棋子，白格一个，黑格四个，删白格。<br>但这种方法还是有badcase。</p><p>所以……我也不知道咋做！</p><ul><li>参考代码:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;数组排序&quot;&gt;&lt;a href=&quot;#数组排序&quot; class=&quot;headerlink&quot; title=&quot;数组排序&quot;&gt;&lt;/a&gt;数组排序&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;描述：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;你需要对一个数组进行排序（升序），每一次，你可以将一个数移动到任意位置，这一次操作的代价是这个数的大小。最少需要多少代价才能将整个数组排序？&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://e99net.github.io/categories/Algorithm/"/>
    
    
      <category term="Dynamic Programming" scheme="https://e99net.github.io/tags/Dynamic-Programming/"/>
    
      <category term="Greedy" scheme="https://e99net.github.io/tags/Greedy/"/>
    
  </entry>
  
  <entry>
    <title>宽搜手工写队列</title>
    <link href="https://e99net.github.io/2019/10/26/bytedance_2019_2/"/>
    <id>https://e99net.github.io/2019/10/26/bytedance_2019_2/</id>
    <published>2019-10-26T07:10:04.956Z</published>
    <updated>2019-10-26T07:52:46.047Z</updated>
    
    <content type="html"><![CDATA[<h4 id="二维数组区块计数"><a href="#二维数组区块计数" class="headerlink" title="二维数组区块计数"></a>二维数组区块计数</h4><ul><li>描述：</li></ul><p>输入一个只包含0和1的二维数组，上下左右和对角相邻的1组成一个区块，0不形成区块，求数组中的区块个数。</p><a id="more"></a><ul><li>输入：</li></ul><p>第一行输入两个正整数N和M，N表示数组行数，M表示数组列数。</p><p>接下来N行，每行表示数组对应的一行，每行包含M个整数，整数之间用空格隔开。</p><ul><li>输出：</li></ul><p>输出一个整数，表示数组中区块的个数。</p><ul><li>数据范围：</li></ul><p>$0 \le N,M,N*M \le 10^6$</p><ul><li>样例输入：</li></ul><p>3 3<br>0 1 0<br>1 0 0<br>1 0 1</p><ul><li>样例输出：</li></ul><p>2</p><ul><li>样例解释：</li></ul><p>数组右下角的1单独构成一个区块，其他的3个1对角或上下相邻，构成另一个区块。</p><ul><li><p>解题思路：宽搜/深搜</p></li><li><p>参考代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">//dfs</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef pair&lt;int,int&gt; PII;</span><br><span class="line">const int N=1000010;</span><br><span class="line">int n,m;</span><br><span class="line">int g[N];</span><br><span class="line"></span><br><span class="line">void dfs(int x,int y) &#123;</span><br><span class="line">    g[x*m+y]=0;</span><br><span class="line">    for(int i=-1;i&lt;=1;i++)</span><br><span class="line">        for(int j=-1;j&lt;=1;j++) &#123;</span><br><span class="line">            int a=x+i,b=y+j;</span><br><span class="line">            if(a&gt;=0&amp;&amp;a&lt;n&amp;&amp;b&gt;=0&amp;&amp;b&lt;m&amp;&amp;g[a*m+b])</span><br><span class="line">                dfs(a,b);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">    for(int i=0,k=0;i&lt;n;i++)</span><br><span class="line">        for(int j=0;j&lt;m;j++,k++)</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;g[k]);</span><br><span class="line">    int res=0;</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">        for(int j=0;j&lt;m;j++) &#123;</span><br><span class="line">            if(g[i*m+j]) &#123;</span><br><span class="line">                res++;</span><br><span class="line">                dfs(i,j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;,res);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">//bfs，用STL中的queue</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef pair&lt;int,int&gt; PII;</span><br><span class="line">const int N=1000010;</span><br><span class="line"></span><br><span class="line">int n,m;</span><br><span class="line">int g[N];</span><br><span class="line"></span><br><span class="line">void bfs(int sx,int sy) &#123;</span><br><span class="line">    queue&lt;PII&gt; q;</span><br><span class="line">    q.push(&#123;sx,sy&#125;);</span><br><span class="line">    g[sx*m+sy]=0;</span><br><span class="line"></span><br><span class="line">    while(q.size()) &#123;</span><br><span class="line">        auto t=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        int x=t.first,y=t.second;</span><br><span class="line"></span><br><span class="line">        for(int i=-1;i&lt;=1;i++)</span><br><span class="line">            for(int j=-1;j&lt;=1;j++) &#123;</span><br><span class="line">                int a=x+i,b=y+j;</span><br><span class="line">                if(a&gt;=0&amp;&amp;a&lt;n&amp;&amp;b&gt;=0&amp;&amp;b&lt;m&amp;&amp;g[a*m+b]) &#123;</span><br><span class="line">                    g[a*m+b]=0;</span><br><span class="line">                    q.push(&#123;a,b&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">    for(int i=0,k=0;i&lt;n;i++)</span><br><span class="line">        for(int j=0;j&lt;m;j++,k++)</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;g[k]);</span><br><span class="line"></span><br><span class="line">    int res=0;</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">        for(int j=0;j&lt;m;j++)</span><br><span class="line">            if(g[i*m+j]) &#123;</span><br><span class="line">                res++;</span><br><span class="line">                bfs(i,j);</span><br><span class="line">            &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;,res);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">//bfs，用手工写的队列</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef pair&lt;int,int&gt; PII;</span><br><span class="line">const int N=1000010;</span><br><span class="line"></span><br><span class="line">int n,m;</span><br><span class="line">int g[N];</span><br><span class="line">PII q[N];</span><br><span class="line"></span><br><span class="line">void bfs(int sx,int sy) &#123;</span><br><span class="line">    int hh=0,tt=0;</span><br><span class="line">    q[0]=&#123;sx,sy&#125;;</span><br><span class="line">    g[sx*m+sy]=0;</span><br><span class="line">    while(hh&lt;=tt) &#123;</span><br><span class="line">        PII t=q[hh++];</span><br><span class="line">        int x=t.first,y=t.second;</span><br><span class="line">        for(int i=-1;i&lt;=1;i++)</span><br><span class="line">            for(int j=-1;j&lt;=1;j++) &#123;</span><br><span class="line">                int a=x+i,b=y+j;</span><br><span class="line">                if(a&gt;=0&amp;&amp;a&lt;n&amp;&amp;b&gt;=0&amp;&amp;b&lt;m&amp;&amp;g[a*m+b]) &#123;</span><br><span class="line">                    g[a*m+b]=0;</span><br><span class="line">                    q[++tt]=&#123;a,b&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">    for(int i=0,k=0;i&lt;n;i++)</span><br><span class="line">        for(int j=0;j&lt;m;j++,k++)</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;g[k]);</span><br><span class="line"></span><br><span class="line">    int res=0;</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">        for(int j=0;j&lt;m;j++)</span><br><span class="line">            if(g[i*m+j]) &#123;</span><br><span class="line">                res++;</span><br><span class="line">                bfs(i,j);</span><br><span class="line">            &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;,res);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行时间：<ul><li>用dfs：1003ms</li><li>用bfs：<ul><li>用STL中的queue：1932ms</li><li>用手工写的队列：1036ms</li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;二维数组区块计数&quot;&gt;&lt;a href=&quot;#二维数组区块计数&quot; class=&quot;headerlink&quot; title=&quot;二维数组区块计数&quot;&gt;&lt;/a&gt;二维数组区块计数&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;描述：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;输入一个只包含0和1的二维数组，上下左右和对角相邻的1组成一个区块，0不形成区块，求数组中的区块个数。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://e99net.github.io/categories/Algorithm/"/>
    
    
      <category term="DFS" scheme="https://e99net.github.io/tags/DFS/"/>
    
      <category term="BFS" scheme="https://e99net.github.io/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>立方体塔</title>
    <link href="https://e99net.github.io/2019/10/26/bytedance_2019_1/"/>
    <id>https://e99net.github.io/2019/10/26/bytedance_2019_1/</id>
    <published>2019-10-26T05:16:58.977Z</published>
    <updated>2019-10-26T06:23:10.941Z</updated>
    
    <content type="html"><![CDATA[<ul><li>描述：</li></ul><p>小方有w个白色立方体和b个黑色立方体，现在小方想把它们堆成一个立方体塔。</p><p>一座高度为h的立方体塔，最底层有h个立方体，每往上一层，所需立方体减一，直到最高层只需要一个立方体。</p><p>为了让这座塔看起来美观，小方希望每一层都只能用一种颜色的立方体。</p><p>小方希望把这座塔叠的尽可能高，因此他想知道塔的最大高度是多少，以及这个高度的立方体塔能有几种。</p><p>两种立方体塔，当且仅当至少有一层的颜色是不同的，则被认为是不同的。</p><a id="more"></a><ul><li>输入：</li></ul><p>共一行，包含两个整数w和b。</p><ul><li>输出：</li></ul><p>共一行，包含两个整数h和c，分别表示最高塔的高度以及此高度塔的种类数。</p><p>因为种类数可能较多，请将c对$10^9+7$取模后的值输出。</p><ul><li>数据范围：</li></ul><p>$0 \le w,b \le 10^5$</p><ul><li>样例输入：</li></ul><p>1 1<br>4 6</p><ul><li>样例输出：</li></ul><p>1 2<br>4 2</p><ul><li>解题思路：0/1背包问题求方案数</li></ul><p>假设用到的白色块总数是a，那么“1到h层有多少种选法使得白色块总数是a”就是最后此高度塔的种类数。1到h层有多少种选法使得白色块总数是a，即选出1 ~ h中的若干数，让这些数的加和是a。a不是确定的，还要枚举一下a。对于每个a都求一个f[a]，那么$\sum f[a]$就是答案。</p><p>f(i,j)是在考虑前i个物品的情况下，体积是j的方案数，有$f(i,j)=f(i-1,j)+f(i-1,j-v[i])$，做恒等变形得$f(j)=f(j)+f(j-i)$，在这里v[i]就是i，第i个物品的体积就是i。</p><ul><li>参考代码:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=100010,mod=1e9+7;</span><br><span class="line"></span><br><span class="line">int f[N];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n,m;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line"></span><br><span class="line">    int h=1;</span><br><span class="line">    while(h*(h+1)/2&lt;=n+m) h++;</span><br><span class="line">    h--;</span><br><span class="line"></span><br><span class="line">    //swap(n,m);</span><br><span class="line"></span><br><span class="line">    f[0]=1;</span><br><span class="line">    for(int i=1;i&lt;=h;i++) &#123;</span><br><span class="line">        for(int j=n;j&gt;=i;j--) &#123;</span><br><span class="line">            f[j]=(f[j]+f[j-i])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int res=0;</span><br><span class="line">    for(int i=0;i&lt;=n;i++)</span><br><span class="line">        if(h*(h+1)/2-i&lt;=m)</span><br><span class="line">            res=(res+f[i])%mod;</span><br><span class="line"></span><br><span class="line">    printf(&quot;%d %d\n&quot;,h,res);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码是滚动数组优化之后f变成一维的情况。f[N]等同于f[N][N],<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">f[0]=1;</span><br><span class="line">for(int i=1;i&lt;=h;i++) &#123;</span><br><span class="line">    for(int j=n;j&gt;=i;j--) &#123;</span><br><span class="line">        f[j]=(f[j]+f[j-i])%mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>等同于<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">f[0][0]=1;</span><br><span class="line">for(int i=1;i&lt;=h;i++)</span><br><span class="line">    for(int j=0;j&lt;=n;j++) &#123;</span><br><span class="line">        f[i][j]=f[i-1][j];//不选第i个物品</span><br><span class="line">        if(j&gt;=i) f[i][j]+=f[i-1][j-i];//如果体积够的话就可以选第i个物品</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>二维变成一维的过程是对代码做恒等变形的过程，f[i][j]=f[i-1][j]和f[j]=f[j]就完全一样了，可以删掉（f[j]本来就等于f[j]）。</p><p>if(j&gt;=i)可以写到第二个循环里去，将for(int j=0;j&lt;=n;j++)变成for(int j=i;j&lt;=n;j++)，因为j &lt; i时循环压根不会执行。</p><p>剩下的就是对f[i][j]+=f[i-1][j-i]的变形，如果j从小到大枚举，那么f[i][j]+=f[i-1][j-i]不会等价于f[j]+=f[j-i]：<br>i是大于0的，所以j-i一定是小于j的，从小到大枚举j的话会先算f[j-i]再算f[j]，先算f[j-i]的时候是在第i层算的，那f[j]+=f[j-i]就等价于f[i][j]+=f[i][j-i]，而不等价于f[i][j]+=f[i-1][j-i]。</p><p>将j改为从大到小枚举（for(int j=n;j&gt;=i;j–)）的话就可以了，此时j-i还是比j小，但变成f[j-i]在f[j]后面算（因为j从大到小枚举），此时f[j-i]用的就不是第i层的f[j-i]（因为还没算到），而是上一层——第i-1层的f[j-i]（还没被更新），那f[j]+=f[j-i]就和f[i][j]+=f[i-1][j-i]等价了。</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;描述：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;小方有w个白色立方体和b个黑色立方体，现在小方想把它们堆成一个立方体塔。&lt;/p&gt;
&lt;p&gt;一座高度为h的立方体塔，最底层有h个立方体，每往上一层，所需立方体减一，直到最高层只需要一个立方体。&lt;/p&gt;
&lt;p&gt;为了让这座塔看起来美观，小方希望每一层都只能用一种颜色的立方体。&lt;/p&gt;
&lt;p&gt;小方希望把这座塔叠的尽可能高，因此他想知道塔的最大高度是多少，以及这个高度的立方体塔能有几种。&lt;/p&gt;
&lt;p&gt;两种立方体塔，当且仅当至少有一层的颜色是不同的，则被认为是不同的。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://e99net.github.io/categories/Algorithm/"/>
    
    
      <category term="Knapsack" scheme="https://e99net.github.io/tags/Knapsack/"/>
    
  </entry>
  
  <entry>
    <title>总结LeetCode上买卖股票这一类型的几道题</title>
    <link href="https://e99net.github.io/2019/10/22/LeetCode_BestTimeToBuyAndSellStock/"/>
    <id>https://e99net.github.io/2019/10/22/LeetCode_BestTimeToBuyAndSellStock/</id>
    <published>2019-10-22T12:01:17.021Z</published>
    <updated>2021-06-17T12:22:35.321Z</updated>
    
    <content type="html"><![CDATA[<h4 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h4><p>LeetCode 121 Easy [<a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/]" target="_blank" rel="noopener">https://leetcode.com/problems/best-time-to-buy-and-sell-stock/]</a></p><ul><li><p>描述：</p><p>给一个数组，数组中的第i个元素代表第i天的股票价格。如果<strong>只允许完全至多一次交易（即买进一股股票并卖出这股股票）</strong>，那么最大收益是多少？</p><p>注意：卖出股票的时间不能早于买进股票的时间。</p></li></ul><a id="more"></a><ul><li><p>输入：</p><p>一个数组。</p></li><li><p>输出：</p><p>买卖股票的最大收益。</p></li><li><p>样例输入1：</p><p>[7,1,5,3,6,4]</p></li><li><p>样例输出1：</p><p>5</p></li><li><p>样例输入2：</p><p>[7,6,4,3,1]</p></li><li><p>样例输出2：</p><p>0</p></li><li><p>解题思路：贪心法</p><p>遍历一次数组，用一个变量记录遍历过的数中的最小值，然后每次计算当前值和最小值之间的差值作为利润，每次选较大的利润来更新，遍历完成后，当前利润即所求。</p></li><li><p>参考代码:</p><ul><li><p>代码1，时间复杂度$O(n^2)$</p><p>LeetCode上的数据范围是$1 &lt;= prices.length &lt;= 10^5$，$O(n^2)$时间复杂度的算法会超时，故代码1提交时会TLE</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;prices.size()<span class="number">-1</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;prices.size();j++) &#123;</span><br><span class="line">                res=max(res,prices[j]-prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>代码2，时间复杂度$O(n)$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>, buy=INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; price:prices) &#123;</span><br><span class="line">            buy=min(buy,price);</span><br><span class="line">            res=max(res,price-buy);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h4><p>LeetCode 122 Easy [<a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/]" target="_blank" rel="noopener">https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/]</a></p><ul><li><p>描述：</p><p>给一个数组，数组中的第i个元素代表第i天的股票价格。如果<strong>允许完成多次交易（即多次买进一股股票并卖出这股股票）</strong>，那么最大收益是多少？</p><p>注意：不能同时进行多次交易，必须在再次买进股票前卖出股票。</p></li><li><p>输入：</p><p>一个数组。</p></li><li><p>输出：</p><p>买卖股票的最大收益。</p></li><li><p>输入样例1：</p><p>[7,1,5,3,6,4]</p></li><li><p>输出样例1：</p><p>7</p><p>说明：第二天买进，第三天卖出，获得收益5-1=4；第四天买进，第五天卖出，获得收益6-3=3。总共获得收益4+3=7。</p></li><li><p>输入样例2：</p><p>[1,2,3,4,5]</p></li><li><p>输出样例2：</p><p>4</p><p>说明：第一天买进，第五天卖出，获得收益5-1=4。不能在第一天买进，第二天买进，稍后再卖出它们，因为这算同时进行多次交易。</p></li><li><p>输入样例3：</p><p>[7,6,4,3,1]</p></li><li><p>输出样例3：</p><p>0</p></li><li><p>解题思路：贪心法</p><p>从第二天开始，如果当前价格比之前价格高，则把差值加入利润中，因为我们可以昨天买入，今日卖出，若明日价更高的话，还可以今日买入，明日再抛出。以此类推，遍历完整个数组后即可求得最大利润。 </p></li><li><p>参考代码：</p><ul><li><p>代码1，时间复杂度$O(n)$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;prices.size();i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i]&gt;prices[i<span class="number">-1</span>])</span><br><span class="line">                sum+=prices[i]-prices[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>代码2</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;prices.size();i++) &#123;</span><br><span class="line">            sum+=max(<span class="number">0</span>,prices[i]-prices[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>代码3，类比第一题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sell=<span class="number">0</span>,buy=INT_MIN;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> p:prices) &#123;</span><br><span class="line">            buy=max(buy,sell-p);</span><br><span class="line">            sell=max(sell,buy+p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sell;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h4><p>LeetCode 123 Hard [<a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/]" target="_blank" rel="noopener">https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/]</a></p><ul><li><p>描述：</p><p>给一个数组，数组中的第i个元素代表第i天的股票价格。如果<strong>只允许完成最多两次交易（即最多两次买进股票并卖出股票）</strong>，那么最大收益是多少？</p><p>注意：不能同时进行多次交易，必须在再次买进股票前卖出股票。</p></li><li><p>输入：</p><p>一个数组。</p></li><li><p>输出：</p><p>买卖股票的最大收益。</p></li><li><p>输入样例1：</p><p>[3,3,5,0,0,3,1,4]</p></li><li><p>输出样例1：</p><p>6</p><p>说明：第四天买进，第六天卖出，获得收益3-0=3；然后第七天买进，第八天卖出，获得收益4-1=3。总共获得收益3+3=6。</p></li><li><p>输入样例2：</p><p>[1,2,3,4,5]</p></li><li><p>输出样例2：</p><p>4</p><p>说明：第一天买进，第五天卖出，获得收益5-1=4。不能在第一天买进，第二天买进，稍后再卖出它们，因为这算同时进行多次交易。</p></li><li><p>输入样例3：</p><p>[7,6,4,3,1]</p></li><li><p>输出样例3：</p><p>0</p></li><li><p>解题思路：动态规划</p><p>题目规定最多交易两次，而不是一定要交易两次，故允许在同一天既买进又卖出，这相当于不交易</p><p>因为最多允许两次交易且交易分先后，所以可将区间分成两段，分别使用动态规划求每段的最大利润</p><p>f[i]表示在第i天一定卖出时的最大利润，即区间[0, i]的最大利润</p><p>g[i]表示在第i天买入且在最后一天一定卖出时的最大利润，即区间[i, n-1]的最大利润</p><p>那么，max{f[i]+g[i]}就是最多允许两次交易的最大利润</p></li><li><p>参考代码：</p><ul><li><p>代码1，时间复杂度O(n)，空间复杂度O(n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.size()&lt;<span class="number">2</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n=prices.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; f(n,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g(n,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,valley=prices[<span class="number">0</span>];i&lt;n;i++) &#123;</span><br><span class="line">            valley=min(valley,prices[i]);</span><br><span class="line">            <span class="comment">// 第i天一定卖出的最大利润 包括 第i-1天一定卖出的最大利润</span></span><br><span class="line">            f[i]=max(f[i<span class="number">-1</span>],prices[i]-valley);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-2</span>,peak=prices[n<span class="number">-1</span>];i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">            peak=max(peak,prices[i]);</span><br><span class="line">            <span class="comment">// 第i天买入且最后一天一定卖出的最大利润 不包括 第i+1天买入且最后一天卖出的最大利润</span></span><br><span class="line">            g[i]=max(g[i],peak-prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max_profit=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            max_profit=max(max_profit,f[i]+g[i]);</span><br><span class="line">        <span class="keyword">return</span> max_profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>代码2，第四题代码2的特例，将k改成2所得</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sells(<span class="number">3</span>,<span class="number">0</span>), buys(<span class="number">3</span>,INT_MIN);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> p:prices) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>;i++) &#123;</span><br><span class="line">                buys[i]=max(buys[i],sells[i<span class="number">-1</span>]-p);</span><br><span class="line">            sells[i]=max(sells[i],buys[i]+p);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sells[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="第四题"><a href="#第四题" class="headerlink" title="第四题"></a>第四题</h4><p>LeetCode 188 Hard [<a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/]" target="_blank" rel="noopener">https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/]</a></p><ul><li><p>描述：</p><p>给一个数组，数组中的第i个元素代表第i天的股票价格。如果<strong>只允许完成最多k次交易（即最多k次买进股票并卖出股票）</strong>，那么最大收益是多少？</p><p>注意：不能同时进行多次交易，必须在再次买进股票前卖出股票。</p></li><li><p>输入：</p><p>一个数组和一个数，用空格分隔。</p></li><li><p>输出：</p><p>买卖股票的最大收益。</p></li><li><p>输入样例1：</p><p>[2,4,1] 2</p></li><li><p>输出样例1：</p><p>2</p><p>说明：第一天买进，第二天卖出，总共获得收益4-2=2。</p></li><li><p>输入样例2：</p><p>[3,2,6,5,0,3] 2</p></li><li><p>输出样例2：</p><p>7</p><p>说明：第二天买进，第三天卖出，获得收益6-2=4；然后在第五天买进，第六天卖出，获得收益3-0=3。总共获得收益4+3=7。</p></li><li><p>解题思路：动态规划</p><p>这道题是第三题的推广<br>如果k的值远大于prices的天数，应该直接用第二题的解法，所以这道题又是第二题和第三题的结合</p></li><li><p>参考代码：</p><ul><li><p>代码1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n=prices.size();</span><br><span class="line">        <span class="keyword">if</span>(k&gt;=n) <span class="keyword">return</span> solveMaxProfit(prices);</span><br><span class="line">        <span class="keyword">int</span> global[k+<span class="number">1</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> local[k+<span class="number">1</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> diff=prices[i+<span class="number">1</span>]-prices[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=k;j&gt;=<span class="number">1</span>;j--) &#123;</span><br><span class="line">                local[j]=max(global[j<span class="number">-1</span>]+max(diff,<span class="number">0</span>),local[j]+diff);</span><br><span class="line">                global[j]=max(global[j],local[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> global[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">solveMaxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;prices.size();i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i]-prices[i<span class="number">-1</span>]&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                res+=prices[i]-prices[i<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>代码2</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k&gt;=prices.size()/<span class="number">2</span>) <span class="keyword">return</span> helper(prices);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sells(k+<span class="number">1</span>,<span class="number">0</span>),buys(k+<span class="number">1</span>,INT_MIN);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> p:prices) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++) &#123;</span><br><span class="line">                <span class="comment">// buys[i]表示在价格为p时第i次买入的最大利润</span></span><br><span class="line">                <span class="comment">// sells[i]表示在价格为p是第i次卖出的最大利润</span></span><br><span class="line">                buys[i]=max(buys[i],sells[i<span class="number">-1</span>]-p);</span><br><span class="line">            sells[i]=max(sells[i],buys[i]+p);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sells[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;prices.size();i++) &#123;</span><br><span class="line">            res+=max(<span class="number">0</span>,prices[i]-prices[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="第五题"><a href="#第五题" class="headerlink" title="第五题"></a>第五题</h4><p>LeetCode 309 Medium [<a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/]" target="_blank" rel="noopener">https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/]</a></p><ul><li><p>描述：</p><p>给一个数组，数组中的第i个元素代表第i天的股票价格。如果<strong>允许按照以下限制完成多次交易（即多次买进股票并卖出股票）</strong>，那么最大收益是多少？</p><p><strong>限制1：不能同时进行多次交易，必须在再次买进股票前卖出股票。</strong><br><strong>限制2：在卖出股票后，不能买进下一天的股票（冷却一天）。</strong></p></li><li><p>输入：</p><p>一个数组。</p></li><li><p>输出：</p><p>买卖股票的最大收益。</p></li><li><p>输入样例：</p><p>[1,2,3,0,2]</p></li><li><p>输出样例：</p><p>3</p><p>说明：第一天买进，第二天卖出，第三天冷却，第四天买进，第五天卖出，总共获得收益1+2=3。</p></li><li><p>解题思路：动态规划</p></li></ul><p><img src="/2019/10/22/LeetCode_BestTimeToBuyAndSellStock/585082-20160229165036642-1352963708.png" alt=""></p><p>​        状态转移图中：<br>​        S0 代表没有买入的状态<br>​        S1 代表买入后等待卖出的状态<br>​        S2 代表卖出后的状态</p><p>​        S2与S0的区别是：因为题目要求卖出后必须cooldown一轮，所以卖出进入S2后，必须再进入S0这个等待买入的状态，这一状态转换代表cooldown一轮</p><p>​        状态转移方程：<br>​        $s0[i] = max(s0[i-1], s2[i-1])$<br>​        $s1[i] = max(s1[i-1], s0[i-1] - price[i])$<br>​        $s2[i] = s1[i-1] + price[i]$</p><ul><li><p>参考代码：</p><ul><li><p>代码1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n=prices.size();</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; s0(n,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; s1(n,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; s2(n,<span class="number">0</span>);</span><br><span class="line">        s1[<span class="number">0</span>]=-prices[<span class="number">0</span>];</span><br><span class="line">        s0[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        s2[<span class="number">0</span>]=INT_MIN;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">            s0[i]=max(s0[i<span class="number">-1</span>],s2[i<span class="number">-1</span>]);</span><br><span class="line">            s1[i]=max(s1[i<span class="number">-1</span>],s0[i<span class="number">-1</span>]-prices[i]);</span><br><span class="line">            s2[i]=s1[i<span class="number">-1</span>]+prices[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max(s0[n<span class="number">-1</span>],s2[n<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>代码2，类比第四题代码2，两个数组意思不同</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=prices.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sell(len+<span class="number">1</span>,<span class="number">0</span>),buy(len+<span class="number">1</span>,INT_MIN);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len+<span class="number">1</span>;i++) &#123;</span><br><span class="line">            <span class="comment">// buy[i]表示第i-1天持股的最大利润</span></span><br><span class="line">            <span class="comment">// sell[i]表示第i-1天未持股的最大利润</span></span><br><span class="line">            buy[i]=max(buy[i<span class="number">-1</span>],(i<span class="number">-2</span>&gt;<span class="number">0</span>?sell[i<span class="number">-2</span>]:<span class="number">0</span>)-prices[i<span class="number">-1</span>]); <span class="comment">//i-2&gt;=0也可以</span></span><br><span class="line">            sell[i]=max(sell[i<span class="number">-1</span>],buy[i<span class="number">-1</span>]+prices[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sell[len];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="第六题"><a href="#第六题" class="headerlink" title="第六题"></a>第六题</h4><p>LeetCode 714 Medium [<a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/]" target="_blank" rel="noopener">https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/]</a></p><ul><li><p>描述：</p><p>给一个数组和一个数，数组中的第i个元素代表第i天的股票价格，那个数代表交易费。如果<strong>允许完成多次交易（即多次买进股票并卖出股票），且每次交易需要支付交易费</strong>，那么最大收益是多少？</p><p>注意：不能同时进行多次交易，必须在再次买进股票前卖出股票。</p></li><li><p>输入：</p><p>一个数组prices（$0 &lt; prices.length \le 50000$，$0 &lt; prices[i] &lt; 50000$）和一个数fee（$0 \le fee &lt; 50000$），用空格分隔。</p></li><li><p>输出：</p><p>买卖股票的最大收益。</p></li><li><p>输入样例：</p><p>[1,3,2,8,4,9] 2</p></li><li><p>输出样例：</p><p>8</p><p>说明：第一天买进，第四天卖出，第五天买进，第六天卖出，总共获得收益(8-1-2)+(9-4-2)=8。</p></li><li><p>解题思路：动态规划</p><p>贪心法不行，当卖出的利润小于交易费时，不应该卖出，否则会亏损。</p><p>状态转移方程：<br>$sold[i] = max(sold[i - 1], hold[i - 1] + prices[i] - fee)$<br>$hold[i] = max(hold[i - 1], sold[i - 1] - prices[i])$</p><p>不管是卖出还是保留，第i天的利润只跟第i-1天有关系，所以可以优化空间，用两个变量来表示当前的卖出和保留的利润，</p></li><li><p>参考代码：</p><ul><li><p>代码1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices, <span class="keyword">int</span> fee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sold=<span class="number">0</span>,hold=-prices[<span class="number">0</span>];<span class="comment">// hold=INT_MIN也可以</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> price:prices) &#123;</span><br><span class="line">            <span class="keyword">int</span> t=sold;</span><br><span class="line">            sold=max(sold,hold+price-fee);</span><br><span class="line">            hold=max(hold,t-price);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sold;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>代码2，类比第二题代码3</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices, <span class="keyword">int</span> fee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sold=<span class="number">0</span>,hold=-prices[<span class="number">0</span>];<span class="comment">// hold=INT_MIN也可以</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> price:prices) &#123;</span><br><span class="line">            hold=max(hold,sold-price);</span><br><span class="line">            sold=max(sold,hold+price-fee);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sold;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;第一题&quot;&gt;&lt;a href=&quot;#第一题&quot; class=&quot;headerlink&quot; title=&quot;第一题&quot;&gt;&lt;/a&gt;第一题&lt;/h4&gt;&lt;p&gt;LeetCode 121 Easy [&lt;a href=&quot;https://leetcode.com/problems/best-time-to-buy-and-sell-stock/]&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/best-time-to-buy-and-sell-stock/]&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;描述：&lt;/p&gt;
&lt;p&gt;给一个数组，数组中的第i个元素代表第i天的股票价格。如果&lt;strong&gt;只允许完全至多一次交易（即买进一股股票并卖出这股股票）&lt;/strong&gt;，那么最大收益是多少？&lt;/p&gt;
&lt;p&gt;注意：卖出股票的时间不能早于买进股票的时间。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://e99net.github.io/categories/Algorithm/"/>
    
    
      <category term="Dynamic Programming" scheme="https://e99net.github.io/tags/Dynamic-Programming/"/>
    
      <category term="Greedy" scheme="https://e99net.github.io/tags/Greedy/"/>
    
      <category term="LeetCode" scheme="https://e99net.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>几道比较有意思的字符串题</title>
    <link href="https://e99net.github.io/2019/10/21/string/"/>
    <id>https://e99net.github.io/2019/10/21/string/</id>
    <published>2019-10-21T08:41:40.209Z</published>
    <updated>2020-12-20T13:35:39.928Z</updated>
    
    <content type="html"><![CDATA[<h4 id="整数反转求和"><a href="#整数反转求和" class="headerlink" title="整数反转求和"></a>整数反转求和</h4><ul><li>描述：</li></ul><p>请您写一个reverseAdd函数，该函数分别将输入的两个正整数a和b的数字按照高位在右的方式反转求和。<br>例如，reverseAdd(123,456)=321+654=975。</p><a id="more"></a><ul><li>输入：</li></ul><p>两个正整数a和b，以空格分隔，$1 \le a,b \le 70000$。</p><ul><li>输出：</li></ul><p>输出一个整数，表示两个正整数反转求和的结果。</p><ul><li>样例输入：</li></ul><p>123 456</p><ul><li>样例输出：</li></ul><p>975</p><ul><li>解题思路：</li></ul><p>按照int型来处理两个输入参数会比较麻烦，按照字符串类型来处理两个输入参数则会大大简化处理过程。</p><ul><li>参考代码:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    string n,m;</span><br><span class="line">    while(cin&gt;&gt;n&gt;&gt;m) &#123;</span><br><span class="line">        int x=0,y=0,i;</span><br><span class="line">        if(m[0]==&apos;0&apos;&amp;&amp;n[0]==&apos;0&apos;)</span><br><span class="line">            break;</span><br><span class="line">        for(i=m.size()-1;i&gt;=0;i--)</span><br><span class="line">            x=x*10+m[i]-&apos;0&apos;;</span><br><span class="line">        for(i=n.size()-1;i&gt;=0;i--)</span><br><span class="line">            y=y*10+n[i]-&apos;0&apos;;</span><br><span class="line">        cout&lt;&lt;x+y&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="字符串计数"><a href="#字符串计数" class="headerlink" title="字符串计数"></a>字符串计数</h4><ul><li>描述：</li></ul><p>给定一个仅由小写字母组成且长度不超过106的字符串，将首字符移到末尾并记录所得的字符串，不断重复该操作，虽然记录了无限个字符串，但其中不同字符串的数目却是有限的，那么一共记录了多少个不同的字符串？</p><ul><li>输入：</li></ul><p>给定的字符串。</p><ul><li>输出：</li></ul><p>记录的不同字符串数目。</p><ul><li>输入样例：</li></ul><p>abab</p><ul><li>输出样例：</li></ul><p>2</p><ul><li>解题思路：</li></ul><p>模板题，考查KMP算法next数组的求解</p><ul><li>参考代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=1000007;</span><br><span class="line">char s[N];</span><br><span class="line">int next[N];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    scanf(&quot;%s&quot;,s);</span><br><span class="line">    int n=strlen(s);</span><br><span class="line">    next[0]=-1;</span><br><span class="line">    for(int i=0,j=-1;i&lt;n;)</span><br><span class="line">        if(j==-1||s[i]=s[j]) next[++i]=++j;</span><br><span class="line">        else j=next[j];</span><br><span class="line">    if(n%(n-next[n])) printf(&quot;%d&quot;,n)</span><br><span class="line">    else printf(&quot;%d&quot;,n-next[n]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;整数反转求和&quot;&gt;&lt;a href=&quot;#整数反转求和&quot; class=&quot;headerlink&quot; title=&quot;整数反转求和&quot;&gt;&lt;/a&gt;整数反转求和&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;描述：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;请您写一个reverseAdd函数，该函数分别将输入的两个正整数a和b的数字按照高位在右的方式反转求和。&lt;br&gt;例如，reverseAdd(123,456)=321+654=975。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://e99net.github.io/categories/Algorithm/"/>
    
    
      <category term="String" scheme="https://e99net.github.io/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>背包问题总结</title>
    <link href="https://e99net.github.io/2019/10/21/knapsack/"/>
    <id>https://e99net.github.io/2019/10/21/knapsack/</id>
    <published>2019-10-21T03:51:37.001Z</published>
    <updated>2019-10-22T15:00:50.330Z</updated>
    
    <content type="html"><![CDATA[<h4 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0/1背包问题"></a>0/1背包问题</h4><ul><li>描述：</li></ul><p>有$N$件物品和一个容量是$V$的背包。</p><p>第$i$件物品的体积是$v_i$，价值是$w_i$。</p><p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。<br>输出最大价值。</p><a id="more"></a><ul><li>输入：</li></ul><p>第一行两个整数$N$和$V$，$0 &lt; N,V \le 1000$，用空格隔开，分别表示物品数量和背包容积。</p><p>接下来有$N$行，每行两个整数$v_i$和$w_i$，$0 &lt; v_i,w_i \le 1000$，用空格隔开，分别表示第$i$件物品的体积和价值。</p><ul><li>输出：</li></ul><p>输出一个整数，表示最大价值。</p><ul><li>样例输入：</li></ul><p>4 5<br>1 2<br>2 4<br>3 4<br>4 5</p><ul><li>样例输出：</li></ul><p>8</p><ul><li>参考代码:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=1010;</span><br><span class="line">int n,m;</span><br><span class="line">int f[N];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(int i=0;i&lt;n;i++) &#123;</span><br><span class="line">        int c,w;</span><br><span class="line">        cin&gt;&gt;c&gt;&gt;w;</span><br><span class="line">        for(int j=m;j&gt;=c;j--)</span><br><span class="line">            f[j]=max(f[j],f[j-c]+w);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[m]&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h4><ul><li>描述：</li></ul><p>有$N$种物品和一个容量是$V$的背包，每种物品都有无限件可用。</p><p>第$i$种物品的体积是$v_i$，价值是$w_i$。</p><p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。<br>输出最大价值。</p><!-- more --><ul><li>输入：</li></ul><p>第一行两个整数$N$和$V$，$0 &lt; N,V \le 1000$，用空格隔开，分别表示物品种数和背包容积。</p><p>接下来有$N$行，每行两个整数$v_i$和$w_i$，$0 &lt; v_i,w_i \le 1000$，用空格隔开，分别表示第$i$种物品的体积和价值。</p><ul><li>输出：</li></ul><p>输出一个整数，表示最大价值。</p><ul><li>样例输入：</li></ul><p>4 5<br>1 2<br>2 4<br>3 4<br>4 5</p><ul><li>样例输出：</li></ul><p>10</p><ul><li>参考代码:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=1010;</span><br><span class="line">int n,m;</span><br><span class="line">int f[N];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cin&gt;n&gt;&gt;m;</span><br><span class="line">    for(int i=0;i&lt;n;i++) &#123;</span><br><span class="line">        int c,w;</span><br><span class="line">        cin&gt;&gt;c&gt;&gt;w;</span><br><span class="line">        for(int j=c;j&lt;=m;j++)</span><br><span class="line">            f[j]=max(f[j],f[j-c]+w);</span><br><span class="line">    &#125;</span><br><span class="line">    int res=0;</span><br><span class="line">    for(int i=0;i&lt;=m;i++) res=max(res,f[i]);</span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多重背包问题"><a href="#多重背包问题" class="headerlink" title="多重背包问题"></a>多重背包问题</h4><ul><li>描述：</li></ul><p>有$N$种物品和一个容量是$V$的背包。</p><p>第$i$种物品最多有$s_i$件，每件体积是$v_i$，价值是$w_i$。</p><p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且价值总和最大。<br>输出最大价值。</p><!-- more --><h5 id="暴力-O-N-M-S"><a href="#暴力-O-N-M-S" class="headerlink" title="暴力 O(N*M*S)"></a>暴力 O(N*M*S)</h5><ul><li>输入：</li></ul><p>第一行两个整数$N$和$V$，$0 &lt; N,V \le 100$，用空格隔开，分别表示物品种数和背包容积。</p><p>接下来有$N$行，每行三个整数$v_i$、$w_i$和$s_i$，$0 &lt; v_i,w_i,s_i \le 100$，用空格隔开，分别表示第$i$件物品的体积、价值和数量。</p><ul><li>输出：</li></ul><p>输出一个整数，表示最大价值。</p><ul><li>样例输入：</li></ul><p>4 5<br>1 2 3<br>2 4 1<br>3 4 3<br>4 5 2</p><ul><li>样例输出：</li></ul><p>10</p><ul><li>参考代码:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=110;</span><br><span class="line"></span><br><span class="line">int n,m;</span><br><span class="line">int f[N];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(int i=0;i&lt;n;i++) &#123;</span><br><span class="line">        int c,w,s;</span><br><span class="line">        cin&gt;&gt;c&gt;&gt;w&gt;&gt;s;</span><br><span class="line">        for(int j=m;j&gt;=0;j--)</span><br><span class="line">            for(int k=1;k&lt;=s;k++)</span><br><span class="line">                if(j&gt;=k*c)</span><br><span class="line">                    f[j]=max(f[j],f[j-k*c]+k*w);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[m]&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="二进制优化-O-N-M-log-S"><a href="#二进制优化-O-N-M-log-S" class="headerlink" title="二进制优化 O(N*M*log S)"></a>二进制优化 O(N*M*log S)</h5><ul><li>输入：</li></ul><p>第一行两个整数$N$和$V$，$0 &lt; N \le 1000$，$0 &lt; V \le 2000$，用空格隔开，分别表示物品种数和背包容积。</p><p>接下来有$N$行，每行三个整数$v_i$、$w_i$和$s_i$，$0 &lt; v_i,w_i,s_i \le 2000$，用空格隔开，分别表示第$i$件物品的体积、价值和数量。</p><ul><li>输出：</li></ul><p>输出一个整数，表示最大价值。</p><ul><li>样例输入：</li></ul><p>4 5<br>1 2 3<br>2 4 1<br>3 4 3<br>4 5 2</p><ul><li>样例输出：</li></ul><p>10</p><ul><li>参考代码:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=2010;</span><br><span class="line"></span><br><span class="line">int n,m;</span><br><span class="line">int f[N];</span><br><span class="line">struct Good &#123;</span><br><span class="line">    int v,w;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;Good&gt; goods;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(int i=0;i&lt;n;i++) &#123;</span><br><span class="line">        int v,w,s;</span><br><span class="line">        cin&gt;&gt;v&gt;&gt;w&gt;&gt;s;</span><br><span class="line">        for(int k=1;j&lt;=s;k*=2) &#123;</span><br><span class="line">            s-=k;</span><br><span class="line">            goods.push_back(&#123;v*k,w*k&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        if(s&gt;0) goods.push_back(&#123;v*s,w*s&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    for(auto good:goods)</span><br><span class="line">        for(int j=m;j&gt;=good.v;j--)</span><br><span class="line">            f[j]=max(f[j],f[j-good.v]+good.w);</span><br><span class="line">    cout&lt;&lt;f[m]&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="单调队列优化-O-N-M"><a href="#单调队列优化-O-N-M" class="headerlink" title="单调队列优化 O(N*M)"></a>单调队列优化 O(N*M)</h5><ul><li>输入：</li></ul><p>第一行两个整数$N$和$V$，$0 &lt; N \le 1000$，$0 &lt; V \le 20000$，用空格隔开，分别表示物品种数和背包容积。</p><p>接下来有$N$行，每行三个整数$v_i$、$w_i$和$s_i$，$0 &lt; v_i,w_i,s_i \le 20000$，用空格隔开，分别表示第$i$件物品的体积、价值和数量。</p><ul><li>输出：</li></ul><p>输出一个整数，表示最大价值。</p><ul><li>样例输入：</li></ul><p>4 5<br>1 2 3<br>2 4 1<br>3 4 3<br>4 5 2</p><ul><li>样例输出：</li></ul><p>10</p><ul><li>参考代码:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=20010;</span><br><span class="line"></span><br><span class="line">int n,m;</span><br><span class="line">int f[N],g[N],q[N];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(int i=0;i&lt;n;i++) &#123;</span><br><span class="line">        int c,w,s;</span><br><span class="line">        cin&gt;&gt;c&gt;&gt;w&gt;&gt;s;</span><br><span class="line">        memcpy(g,f,sizeof f);</span><br><span class="line"></span><br><span class="line">        for(int j=0;j&lt;c;j++) &#123;</span><br><span class="line">            int hh=0,tt=-1;</span><br><span class="line">            for(int k=j;k&lt;=m;k+=c) &#123;</span><br><span class="line">                f[k]=g[k];</span><br><span class="line">                if(hh&lt;=tt&amp;&amp;k-s*c&gt;q[hh]) hh++;</span><br><span class="line">                if(hh&lt;=tt) f[k]=max(f[k],g[q[hh]]+(k-q[hh])/c*w);</span><br><span class="line">                while(hh&lt;=tt&amp;&amp;g[q[tt]]-(q[tt]-j)/c*w&lt;=g[k]-(k-j)/c*w) tt--;</span><br><span class="line">                q[++tt]=k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[m]&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="混合背包问题"><a href="#混合背包问题" class="headerlink" title="混合背包问题"></a>混合背包问题</h4><ul><li>描述：</li></ul><p>有$N$种物品和一个容量是$V$的背包。</p><p>物品一共有三类：</p><ul><li>第一类物品只能用1次（01背包）</li><li>第二类物品可以用无限次（完全背包）</li><li>第三类物品最多只能用$s_i$次（多重背包）</li></ul><p>每种体积是$v_i$，价值是$w_i$。</p><p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且价值总和最大。<br>输出最大价值。</p><!-- more --><ul><li>输入：</li></ul><p>第一行两个整数$N$和$V$，$0 &lt; N,V \le 1000$，用空格隔开，分别表示物品数量和背包容积。</p><p>接下来有$N$行，每行三个整数$v_i$、$w_i$和$s_i$，用空格隔开，分别表示第$i$件物品的体积、价值和数量。</p><p>$0 &lt; v_i,w_i \le 1000$，$-1 \le s_i \le 1000$。</p><ul><li>$s_i=-1$表示第$i$种物品只能用1次</li><li>$s_i=0$表示第$i$种物品可以用无限次</li><li>$s_i&gt;0$表示第$i$种物品可以使用$s_i$次</li></ul><ul><li>输出：</li></ul><p>输出一个整数，表示最大价值。</p><ul><li>样例输入：</li></ul><p>4 5<br>1 2 -1<br>2 4 1<br>3 4 0<br>4 5 2</p><ul><li>样例输出：</li></ul><p>8</p><ul><li>参考代码:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=1010;</span><br><span class="line"></span><br><span class="line">int n,m;</span><br><span class="line">int f[N];</span><br><span class="line"></span><br><span class="line">struct Thing &#123;</span><br><span class="line">    int kind;</span><br><span class="line">    int v,w;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Thing&gt; things;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(int i=0;i&lt;n;i++) &#123;</span><br><span class="line">        int v,w,s;</span><br><span class="line">        cin&gt;&gt;v&gt;&gt;w&gt;&gt;s;</span><br><span class="line">        if(s&lt;0) things.push_back(&#123;-1,v,w&#125;);</span><br><span class="line">        else if(s==0) things.push_back(&#123;0,v,w&#125;);</span><br><span class="line">        else &#123;</span><br><span class="line">            for(int k=1;k&lt;=s;k*=2) &#123;</span><br><span class="line">                s-=k;</span><br><span class="line">                things.push_back(&#123;-1,v*k,w*k&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            if(s&gt;0)things.push_back(&#123;-1,v*s,w*s&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(auto thing : things) &#123;</span><br><span class="line">        if(thing.kind&lt;0) &#123;</span><br><span class="line">            for(int j=m;j&gt;=thing.v;j--) f[j]=max(f[j],f[j-thing.v]+thing.w);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            for(int j=thing.v;j&lt;=m;j++) f[j]=max(f[j],f[j-thing.v]+thing.w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[m]&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二维费用的背包问题"><a href="#二维费用的背包问题" class="headerlink" title="二维费用的背包问题"></a>二维费用的背包问题</h4><ul><li>描述：</li></ul><p>有$N$件物品和一个容量是$V$的背包，背包能承受的最大重量是$M$。</p><p>每件物品只能用一次。体积是$v_i$，重量是$m_i$，价值是$w_i$。</p><p>求解将哪些物品装入背包，可使物品总体积不超过背包容量，总重量不超过背包可承受的最大重量，且价值总和最大。<br>输出最大价值。</p><!-- more --><ul><li>输入：</li></ul><p>第一行三个整数$N$、$V$和$M$，$0 &lt; N \le 1000$，$0 &lt; V,M \le 100$，用空格隔开，分别表示物品件数、背包容积和背包可承受的最大重量。</p><p>接下来有$N$行，每行三个整数$v_i$、$m_i$和$w_i$，$0 &lt; v_i,m_i \le 100$，$0 &lt; w_i \le 1000$，用空格隔开，分别表示第$i$件物品的体积、重量和价值。</p><ul><li>输出：</li></ul><p>输出一个整数，表示最大价值。</p><ul><li>样例输入：</li></ul><p>4 5 6<br>1 2 3<br>2 4 4<br>3 4 5<br>4 5 6</p><ul><li>样例输出：</li></ul><p>8</p><ul><li>参考代码:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=110;</span><br><span class="line"></span><br><span class="line">int n,v,m;</span><br><span class="line">int f[N][N];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;v&gt;&gt;m;</span><br><span class="line">    for(int i=0;i&lt;n;i++) &#123;</span><br><span class="line">        int a,b,c;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">        for(int j=v;j&gt;=a;j--)</span><br><span class="line">            for(int k=m;k&gt;=b;k--)</span><br><span class="line">                f[j][k]=max(f[j][k],f[j-a][k-b]+c);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[v][m]&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="分组背包问题"><a href="#分组背包问题" class="headerlink" title="分组背包问题"></a>分组背包问题</h4><ul><li>描述：</li></ul><p>有$N$组物品和一个容量是$V$的背包。</p><p>每组物品有若干个，同一组内的物品最多只能选一个。</p><p>每件物品的体积是$v_{ij}$，价值是$w_{ij}$，其中$i$是组号，$j$是组内编号。</p><p>求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。</p><p>输出最大价值。</p><!-- more --><ul><li>输入：</li></ul><p>第一行有两个整数$N$和$V$，$0 &lt; N,V \le 100$，用空格隔开，分别表示物品组数和背包容量。</p><p>接下来有$N$组数据：</p><ul><li>每组数据第一行有一个整数$S_i$，$0 &lt; S_i \le 100$，表示第$i$个物品组的物品数量；</li><li>每组数据接下来有$S_i$行，每行有两个整数$v_{ij}$和$w_{ij}$，$0 &lt; v_{ij},w_{ij} \le 100$，用空格隔开，分别表示第$i$个物品组的第$j$个物品的体积和价值。</li></ul><ul><li>输出：</li></ul><p>输出一个整数，表示最大价值。</p><ul><li>样例输入：</li></ul><p>3 5<br>2<br>1 2<br>2 4<br>1<br>3 4<br>1<br>4 5</p><ul><li>样例输出：</li></ul><p>8</p><ul><li>参考代码:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=110;</span><br><span class="line"></span><br><span class="line">int n,m;</span><br><span class="line">int f[N],v[N],w[N];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(int i=0;i&lt;n;i++) &#123;</span><br><span class="line">        int s;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        for(int j=0;j&lt;s;j++) cin&gt;&gt;v[j]&lt;&lt;w[j];</span><br><span class="line">        for(int j=m;j&gt;=0;j--)</span><br><span class="line">            for(int k=0;k&lt;s;k++)</span><br><span class="line">                if(j&gt;=v[k])</span><br><span class="line">                    f[j]=max(f[j],f[j-v[k]]+w[k]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[m]&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="背包问题求方案数"><a href="#背包问题求方案数" class="headerlink" title="背包问题求方案数"></a>背包问题求方案数</h4><ul><li>描述：</li></ul><p>有$N$件物品和一个容量是$V$的背包，每件物品只能使用一次。</p><p>第$i$件物品的体积是$v_i$，价值是$w_i$。</p><p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。</p><p>输出<strong>最优选法的方案数</strong>，注意答案可能很大，请输出答案模$10^9+7$的结果。</p><!-- more --><ul><li>输入：</li></ul><p>第一行两个整数$N$和$V$，$0 &lt; N,V \le 1000$，用空格隔开，分别表示物品数量和背包容积。</p><p>接下来有$N$行，每行两个整数$v_i$和$w_i$，$0 &lt; v_i,w_i \le 1000$，用空格隔开，分别表示第$i$件物品的体积和价值。</p><ul><li>输出：</li></ul><p>输出一个整数，表示方案数模$10^9+7$的结果。</p><ul><li>样例输入：</li></ul><p>4 5<br>1 2<br>2 4<br>3 4<br>4 6</p><ul><li>样例输出：</li></ul><p>2</p><ul><li>参考代码:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=1010,mod=1000000009,INF=1000000;</span><br><span class="line">int n,m;</span><br><span class="line">int f[N],g[N];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    g[0]=1;</span><br><span class="line">    for(int i=1;i&lt;=m;i++) f[i]=-INF;</span><br><span class="line">    for(int i=0;i&lt;n;i++) &#123;</span><br><span class="line">        int v,w;</span><br><span class="line">        cin&gt;&gt;v&gt;&gt;w;</span><br><span class="line">        for(int j=m;j&gt;=v;j--) &#123;</span><br><span class="line">            int t=max(f[j],f[j-v]+w);</span><br><span class="line">            int s=0;</span><br><span class="line">            if(t==f[j])s+=g[j];</span><br><span class="line">            if(t==f[j-v]+w)s+=g[j-v];</span><br><span class="line">            if(s&gt;=mod)s-=mod;</span><br><span class="line">            f[j]=t;</span><br><span class="line">            g[j]=s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int maxw=0;</span><br><span class="line">    for(int i=0;i&lt;=m;i++) maxw=max(maxw,f[i]);</span><br><span class="line">    int res=0;</span><br><span class="line">    for(int i=0;i&lt;=m;i++)</span><br><span class="line">        if(maxw==f[i]) &#123;</span><br><span class="line">            res+=g[i];</span><br><span class="line">            if(res&gt;=mod) res-=mod;</span><br><span class="line">        &#125;</span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="求背包问题的方案"><a href="#求背包问题的方案" class="headerlink" title="求背包问题的方案"></a>求背包问题的方案</h4><ul><li>描述：</li></ul><p>有$N$件物品和一个容量是$V$的背包，每件物品只能使用一次。</p><p>第$i$件物品的体积是$v_i$，价值是$w_i$。</p><p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。</p><p>输出<strong>字典序最小的方案</strong>。这里的字典序是指：所选物品的编号所构成的序列。物品的编号范围是$1…N$。</p><!-- more --><ul><li>输入：</li></ul><p>第一行两个整数$N$和$V$，$0 &lt; N,V \le 1000$，用空格隔开，分别表示物品数量和背包容积。</p><p>接下来有$N$行，每行两个整数$v_i$和$w_i$，$0 &lt; v_i,w_i \le 1000$，用空格隔开，分别表示第$i$件物品的体积和价值。</p><ul><li>输出：</li></ul><p>输出一行，包含若干个用空格隔开的整数，表示最优解中所选物品的编号序列，且该编号序列的字典序最小。</p><p>物品编号范围是$1…N$。</p><ul><li>样例输入：</li></ul><p>4 5<br>1 2<br>2 4<br>3 4<br>4 6</p><ul><li>样例输出：</li></ul><p>1 4</p><ul><li>参考代码:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=1010;</span><br><span class="line"></span><br><span class="line">int n,m;</span><br><span class="line">int v[N],w[N],f[N][N];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(int i=1;i&lt;=n;i++) cin&gt;&gt;v[i]&gt;&gt;w[i];</span><br><span class="line">    for(int i=n;i&gt;=1;i--) &#123;</span><br><span class="line">        for(int j=0;j&lt;=m;j++) &#123;</span><br><span class="line">            f[i][j]=f[i+1][j];</span><br><span class="line">            if(j&gt;=v[i]) f[i][j]=max(f[i][j],f[i+1][j-v[i]]+w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int vol=m;</span><br><span class="line">    for(int i=1;i&lt;=n;i++) &#123;</span><br><span class="line">        if(f[i][vol]==f[i+1][vol-v[i]]+w[i]) &#123;</span><br><span class="line">            cout&lt;&lt;i&lt;&lt;&apos; &apos;;</span><br><span class="line">            vol-=v[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="有依赖的背包问题"><a href="#有依赖的背包问题" class="headerlink" title="有依赖的背包问题"></a>有依赖的背包问题</h4><h5 id="非树形依赖的背包问题"><a href="#非树形依赖的背包问题" class="headerlink" title="非树形依赖的背包问题"></a>非树形依赖的背包问题</h5><ul><li>描述：</li></ul><p>金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间金明自己专用的很宽敞的房间。更让他高兴的是，妈妈昨天对他说：“你的房间需要购买哪些物品，怎么布置，你说了算，只要不超过$N$元钱就行”。今天一早，金明就开始做预算了，他把想买的物品分为两类：主件与附件，附件是从属于某个主件的，下表就是一些主件与附件的例子：</p><p>|主件| 附件|</p><p>|电脑| 打印机，扫描仪|</p><p>|书柜| 图书|</p><p>|书桌| 台灯，文具|</p><p>|工作椅| 无|</p><p>如果要买归类为附件的物品，必须先买该附件所属的主件。每个主件可以有0个、1个或2个附件。附件不再有从属于自己的附件。金明想买的东西很多，肯定会超过妈妈限定的$N$元。于是，他把每件物品规定了一个重要度，分为5等：用整数1−5表示，第5等最重要。他还从因特网上查到了每件物品的价格（都是10元的整数倍）。他希望在不超过$N$元（可以等于$N$元）的前提下，使每件物品的价格与重要度的乘积的总和最大。</p><p>设第$j$件物品的价格为$v_[j]$，重要度为$w_[j]$，共选中了$k$件物品，编号依次为$j_1,j_2,…,j_k$，则所求的总和为：<br>$$v_[j_1] \times w_[j_1]+v_[j_2] \times w_[j_2]+ …+v_[j_k] \times w_[j_k]$$</p><p>请你帮助金明设计一个满足要求的购物单。</p><ul><li>输入：</li></ul><p>第1行为两个正整数$n$和$m$，分别表示总钱数和希望购买物品的个数，$n&lt;32000$，$m&lt;60$，用空格隔开。</p><p>从第2行到第$m+1$行，第$j$行给出了编号为$j-1$的物品的基本数据，每行有3个非负整数$v$、$p$、$q$，分别表示该物品的价格、重要度（1-5）、是主件还是附件，$q=0$表示该物品为主件，$q&gt;0$表示该物品为附件且$q$是所属主件的编号，$v&lt;10000$。</p><ul><li>输出：</li></ul><p>一个正整数，为不超过总钱数的物品的价格与重要度乘积的总和的最大值。</p><ul><li>样例输入：</li></ul><p>1000 5<br>800 2 0<br>400 5 1<br>300 5 1<br>400 3 0<br>500 2 0</p><ul><li>样例输出：</li></ul><p>2200</p><ul><li><p>解题思路：分组背包</p></li><li><p>参考代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h5 id="树形依赖的背包问题"><a href="#树形依赖的背包问题" class="headerlink" title="树形依赖的背包问题"></a>树形依赖的背包问题</h5><ul><li>描述：</li></ul><p>有$N$个物品和一个容量是$V$的背包。</p><p>物品之间具有依赖关系，且依赖关系组成一棵树的形状。如果选择一个物品，则必须选择它的父节点。</p><!-- more --><p>如下图所示：</p><p><img src="/2019/10/21/knapsack/2019-10-21_122422.jpg" alt=""></p><p>如果选择物品5，则必须选择物品1和2。这是因为2是5的父节点，1是2的父节点。</p><p>每件物品的编号是$i$，体积是$v_i$，价值是$w_i$，依赖的父节点编号是$p_i$，物品的下标范围是$1…N$。</p><p>求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。</p><p>输出最大价值。</p><ul><li>输入：</li></ul><p>第一行两个整数$N$和$V$，$1 \le N,V \le 100$，用空格隔开，分别表示物品个数和背包容量。</p><p>接下来有$N$行数据，每行数据表示一个物品。<br>第$i$行有三个整数$v_i$,$w_i$,$p_i$，$1 &lt; v_i,w_i \le 100$，用空格隔开，分别表示物品的体积、价值和依赖的物品编号。<br>$p_i==-1$表示根节点，$1 \le p_i \le N$表示内部节点，数据保证所有物品构成一棵树。</p><ul><li>输出：</li></ul><p>输出一个整数，表示最大价值。</p><ul><li>样例输入：</li></ul><p>5 7<br>2 3 -1<br>2 2 1<br>3 5 1<br>4 7 2<br>3 6 2</p><ul><li>样例输出：</li></ul><p>11</p><ul><li><p>解题思路：分组背包+树形dp</p></li><li><p>参考代码:</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=110;</span><br><span class="line">int n,m;</span><br><span class="line">int h[N],e[N],ne[N],idx;</span><br><span class="line">int v[N],w[N],f[N][N];</span><br><span class="line">void add(int a,int b) &#123;</span><br><span class="line">    e[idx]=b,ne[idx]=h[a],h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line">void dfs(int u) &#123;</span><br><span class="line">    for(int i=h[u];i!=-1;i=ne[i]) &#123;</span><br><span class="line">        int son=e[i];</span><br><span class="line">        dfs(son);</span><br><span class="line">        for(int j=m-v[u];j&gt;=0;j--)</span><br><span class="line">            for(int k=0;k&lt;=j;k++)</span><br><span class="line">                f[u][j]=max(f[u][j],f[u][j-k]+f[son][k]);</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=m;i&gt;=v[u];i--) f[u][i]=f[u][i-v[u]]+w[u];</span><br><span class="line">    for(int i=0;i&lt;v[u];i++) f[u][i]=0;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    memset(h,-1,sizeof h);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    int root;</span><br><span class="line">    for(int i=1;i&lt;=n;i++) &#123;</span><br><span class="line">        int p;</span><br><span class="line">        cin&gt;&gt;v[i]&gt;&gt;w[i]&gt;&gt;p;</span><br><span class="line">        if(p==-1) root=i;</span><br><span class="line">        else add(p,i);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root);</span><br><span class="line">    cout&lt;&lt;f[root][m]&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;0-1背包问题&quot;&gt;&lt;a href=&quot;#0-1背包问题&quot; class=&quot;headerlink&quot; title=&quot;0/1背包问题&quot;&gt;&lt;/a&gt;0/1背包问题&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;描述：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有$N$件物品和一个容量是$V$的背包。&lt;/p&gt;
&lt;p&gt;第$i$件物品的体积是$v_i$，价值是$w_i$。&lt;/p&gt;
&lt;p&gt;求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。&lt;br&gt;输出最大价值。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://e99net.github.io/categories/Algorithm/"/>
    
    
      <category term="Knapsack" scheme="https://e99net.github.io/tags/Knapsack/"/>
    
  </entry>
  
  <entry>
    <title>记一道算法编程题</title>
    <link href="https://e99net.github.io/2019/10/21/meituan2019/"/>
    <id>https://e99net.github.io/2019/10/21/meituan2019/</id>
    <published>2019-10-21T03:33:49.258Z</published>
    <updated>2019-10-21T03:50:09.279Z</updated>
    
    <content type="html"><![CDATA[<h4 id="爱健身的小王"><a href="#爱健身的小王" class="headerlink" title="爱健身的小王"></a>爱健身的小王</h4><ul><li>描述：</li></ul><p>小王是一个喜欢健身的人，他每天都会围着一个n*n的场地外侧跑步。<br>他是一个有强迫症的人，每跑n+1个单位长度，他就要在地上做一个标记。<br>当他在一个点重复标记的时候，他就会结束当天的锻炼。<br>显然当n一定时，他每天打标记的数量也是一定的。请你计算出来他每天要打多少标记（最后一次重复标记也要计数）。</p><a id="more"></a><ul><li>输入：</li></ul><p>第一行包含一个正整数t，表示询问的数量。</p><p>第二行包含t个整数，中间用空格隔开，每个整数表示一个询问所给出的n，$1 \le n \le 1000$。</p><ul><li>输出：</li></ul><p>输出共t行，$1 \le t \le 10000$。</p><p>每行包含一个正整数，其中第i行的整数表示第i个询问的答案。</p><ul><li>样例输入：</li></ul><p>2<br>4 8</p><ul><li>样例输出：</li></ul><p>17<br>33</p><ul><li>样例解释：</li></ul><p>对于4*4的场地而言，其边界上的16个点都会被标记，因为起点会被标记两次，所以共17次。</p><ul><li><p>解题思路：最小公倍数</p></li><li><p>参考代码:</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int gcd(int a,int b)&#123;</span><br><span class="line">    return b?gcd(b,a%b):a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int T;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    while(T--) &#123;</span><br><span class="line">        int n;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        int d=gcd(4*n,n+1);</span><br><span class="line">        cout&lt;&lt;4*n/d+1&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;爱健身的小王&quot;&gt;&lt;a href=&quot;#爱健身的小王&quot; class=&quot;headerlink&quot; title=&quot;爱健身的小王&quot;&gt;&lt;/a&gt;爱健身的小王&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;描述：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;小王是一个喜欢健身的人，他每天都会围着一个n*n的场地外侧跑步。&lt;br&gt;他是一个有强迫症的人，每跑n+1个单位长度，他就要在地上做一个标记。&lt;br&gt;当他在一个点重复标记的时候，他就会结束当天的锻炼。&lt;br&gt;显然当n一定时，他每天打标记的数量也是一定的。请你计算出来他每天要打多少标记（最后一次重复标记也要计数）。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://e99net.github.io/categories/Algorithm/"/>
    
    
      <category term="Number theory" scheme="https://e99net.github.io/tags/Number-theory/"/>
    
  </entry>
  
  <entry>
    <title>记五道2020年某企业提前批招聘笔试题</title>
    <link href="https://e99net.github.io/2019/10/07/netease/"/>
    <id>https://e99net.github.io/2019/10/07/netease/</id>
    <published>2019-10-07T02:44:38.279Z</published>
    <updated>2019-11-10T12:15:01.370Z</updated>
    
    <content type="html"><![CDATA[<h4 id="窗口点击模拟"><a href="#窗口点击模拟" class="headerlink" title="窗口点击模拟"></a>窗口点击模拟</h4><ul><li>描述：</li></ul><p>本题需要让你模拟一下在Windows系统里窗囗和鼠标点击的操作，具体如下：</p><ol><li>屏幕分辨率为3840 * 2160，左上角坐标为（0，0），右下角坐标为（3839，2159）</li><li>窗口是一个矩形的形状，由左上角坐标（X，Y），和宽高（W，H），四个数字来定位。左上角坐标为（X，Y）、右下角坐标为（X+W，Y+H），其中左上角坐标一定会在屏幕范围内，其他一些部分可能会超过屏幕范围。</li><li>窗囗的点击和遮挡规则同Windows，但是不考虑关闭窗囗、最大化、最小化和强制置顶的情况。即<br> 3.1 如果发生重叠的话，后面打开的窗口会显示在前面打开的窗口上面<br> 3.2 当鼠标发生一次点击的时候，需要判断点击到了哪个窗口，如果同个坐标有多个窗口，算点击到最上层的那个<br> 3.3 当一个窗囗被点击的时候，会浮动到最上层</li></ol><a id="more"></a><ul><li>输入：</li></ul><p>每个测试输入包含1个测试用例<br>第一行为2个整数N，M。其中N表示打开的窗口数目，M表示鼠标点击的数目，0&lt;N，M&lt;1000<br>接下来N行，每一行四个整数Xi Yi Wi Hi，分别表示第i个窗口（窗口Id为i，从1开始计数）的左上角坐标以及宽高，初始时窗口是按输入的顺序依次打开。其中0&lt;=Xi&lt;3840，0&lt;=Yi&lt;2160，0&lt;Wi&lt;3840，0&lt;Hi&lt;2160<br>再接下来有M行，每一行两个整数xj Yj，分别表示接下来发生的鼠标点击坐标。其中0&lt;=Xj&lt;3840，0&lt;=Yj&lt;2160</p><ul><li>输出：</li></ul><p>对于每次鼠标点击，输出本次点击到的窗口Id。如果没有点击到窗口，输出-1</p><ul><li>样例输入：</li></ul><p>2 4<br>100 100 100 100<br>10 10 150 150<br>105 105<br>180 180<br>105 105<br>1 1</p><ul><li>样例输出：</li></ul><p>2<br>1<br>1<br>-1</p><ul><li>样例说明：</li></ul><p>有2个窗口，第1个窗口左上角坐标为(100,100)，宽和高都是100，则其右下角坐标为(200,200)；<br>第2个窗口左上角坐标为(10,10)，宽和高都是150，则其右下角坐标为(160,160)。</p><p>有4次鼠标点击，第1次点击的位置同时属于1号和2号窗口，但由于2号窗口在上面，所以它被选择并且被置于顶层；<br>第2次点击的位置只属于1号窗口，因此该次点击选择了1号窗口并将其置于顶层，现在1号窗口在上，2号窗口在下；<br>第3次点击的位置同时属于1号和2号窗口的范围，但由于1号窗口在上，所以它被选择；<br>第4次点击的位置不属于任何窗口。</p><ul><li>解题思路：模拟</li></ul><p>用一个结构体数组存给出的窗口信息，根据题意，数组中越靠后的窗口优先级越高，因此，每次点击从数字后面开始扫描，扫到满足点击的窗口就输出对应的编号，并将它提到末尾。</p><ul><li>参考代码:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=1010;</span><br><span class="line">const int M=1010;</span><br><span class="line">int n,m;</span><br><span class="line"></span><br><span class="line">struct win &#123;</span><br><span class="line">    int id,x,y,w,h;</span><br><span class="line">&#125;wins[N];//存窗口的结构体数组</span><br><span class="line"></span><br><span class="line">//将窗口i置于顶层</span><br><span class="line">void top(int i) &#123;</span><br><span class="line">    win t=wins[i];</span><br><span class="line">    for(;i&lt;n-1;i++) wins[i]=wins[i+1];</span><br><span class="line">    wins[n-1]=t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">    for(int i=0;i&lt;n;i++) &#123;</span><br><span class="line">        scanf(&quot;%d%d%d%d&quot;,&amp;wins[i].x,&amp;wins[i].y,&amp;wins[i].w,&amp;wins[i].h);</span><br><span class="line">        wins[i].id=i+1;</span><br><span class="line">    &#125;</span><br><span class="line">    while(m--) &#123;</span><br><span class="line">        int dx,dy,flag=0;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;dx,&amp;dy);</span><br><span class="line">        for(int i=n-1;i&gt;=0;i--) &#123;</span><br><span class="line">            //判断鼠标点击范围</span><br><span class="line">            if(dx&gt;=wins[i].x&amp;&amp;dy&gt;=wins[i].y&amp;&amp;dx&lt;=wins[i].x+wins[i].w&amp;&amp;dy&lt;=wins[i].y+wins[i].h) &#123;</span><br><span class="line">                printf(&quot;%d\n&quot;,wins[i].id);</span><br><span class="line">                top(i);</span><br><span class="line">                flag=1;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(!flag) printf(&quot;-1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Stern-Brocot-tree"><a href="#Stern-Brocot-tree" class="headerlink" title="Stern-Brocot tree"></a>Stern-Brocot tree</h4><ul><li>描述：</li></ul><p>The Stern-Brocot tree is an infinite complete binary tree in which the vertices correspond one-for-one to the positive rational numbers, whose values are ordered from the left to the right as in a search tree.</p><p><img src="/2019/10/07/netease/001.jpg" alt=""></p><p>Figure 1 shows a part of the Stern-Brocot tree, which has thefirst 4 rows. Each node in the tree is marked in a red cycle. The value in the node is the mediant of the left and right fractions. The mediant of two fractions A/B and C/D is defined as(A+C)/(B+D).<br>To construct the Stern-Brocot tree, we first define the left fraction of the root node is 0/1, and the right fraction of the root node is 1/0. So the value in the root node is the mediant of 0/1 and 1/0, which is(0+1)/(1+0)=1/1. Then the value of root node becomes the right fraction of the left child, and the left fraction of the right child. For example, the 1st node in row2 has 0/1 as its left fraction and 1/1(which is the value of its parent node) as its right fraction. So the value of the 1st node in row2 is (0+1)/(1+1)=1/2. For the same reason, the value of the 2nd node in row2 is (1+1)/(1+0)=2/1. This construction progress goes on infinitly. As a result, everypositive rational number can be found on the Stern-Brocot tree, and can be found only once.<br>Given a rational number in form of P/Q, find the position of P/Q in the Stern-Brocot Tree.</p><ul><li>输入：</li></ul><p>Input consists of two integers,P and Q<br>(1&lt;=P,Q&lt;=1000), which represent the rational number P/Q. We promise P and Q are relatively prime.</p><ul><li>输出：</li></ul><p>Output consists of two integers,R and C.<br>R indicates the row index of P/Q in the stern-Brocot Tree,C indicates the index of P/Q in the row.<br>Both B and C are base 1.<br>We promise the position of P/Q is always in the first 12 rows of the Stern-Brocot tree, which means R&lt;=12.</p><ul><li>样例输入：</li></ul><p>5 3</p><ul><li>样例输出：</li></ul><p>4 6</p><ul><li><p>解题思路：数学+二分</p></li><li><p>参考程序：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct Fraction &#123;</span><br><span class="line">    int m,n;</span><br><span class="line">&#125;sl,sr,input;</span><br><span class="line">int row,col;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int summ,sumn;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;input.m,&amp;input.n);</span><br><span class="line">    if(input.m!=1||input.n!=1) &#123;</span><br><span class="line">       //string ans;</span><br><span class="line">       sl.m=0,sr.m=1;</span><br><span class="line">       sl.n=1,sr.n=0;</span><br><span class="line">       row=1;</span><br><span class="line">       col=1;</span><br><span class="line">       while(1)&#123;</span><br><span class="line">            summ=sl.m+sr.m;</span><br><span class="line">            sumn=sl.n+sr.n;</span><br><span class="line">            int temp=input.m*sumn-input.n*summ;</span><br><span class="line">            if(temp&gt;0)&#123; // input.m/input.n&gt;summ/sumn --&gt; input.m*sumn-input.n*summ&gt;0</span><br><span class="line">                // ans+=&apos;R&apos;;</span><br><span class="line">                row++;</span><br><span class="line">                col*=2;</span><br><span class="line">                sl.m=summ;</span><br><span class="line">                sl.n=sumn;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(temp==0) // input.m/input.n==summ/sumn --&gt; input.m*sumn-input.n*summ==0</span><br><span class="line">                break;</span><br><span class="line">            else&#123; // input.m/input.n&lt;summ/sumn --&gt; input.m*sumn-input.n*summ&lt;0</span><br><span class="line">                // ans+=&apos;L&apos;;</span><br><span class="line">                row++;</span><br><span class="line">                col=2*col-1;</span><br><span class="line">                sr.m=summ;</span><br><span class="line">                sr.n=sumn;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d %d\n&quot;,row,col);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="双人数字游戏"><a href="#双人数字游戏" class="headerlink" title="双人数字游戏"></a>双人数字游戏</h4><ul><li>描述：</li></ul><p>游戏规则如下</p><ul><li><p>在棋盘上有N个数字（A1 ~ AN）从左到右排列成一行</p></li><li><p>A，B两个玩家轮流进行游戏，第一回合A玩家行动，第二回合B玩家行动，依次行动直到游戏结束</p></li><li><p>每回合玩家可以选择拿走棋盘上最左边或者最右边的一个数字，其余的都不能拿</p></li><li><p>拿走的数字依次从左到右排列在自己面前</p></li><li><p>棋盘上所有数字被拿走后游戏结束</p></li><li><p>最优策略的说明：在任意局面下，玩家如果取左边的数字或者取右边的数字，最终最优得分都一样，那么只能取左边的数字</p></li></ul><p>当所有数字都被拿走后，A，B两个玩家面前都各有一个数列。</p><p>假设A玩家面前数字从左到右为X1，X2，X3…XM，则他的最终得分Sa计算方式如下（B玩家的得分计算Sb也类似，不赘述）：<br>Sa=abs(X1-0)+abs(X2-X1)+abs(X3-X2)+..+abs(XM-X(M-1))</p><p>请计算在以上的规则下，如果两个玩家都想拿到尽量多的分数，用最优策略进行游戏，计算两个人的最终得分。</p><ul><li>输入：</li></ul><p>第一行一个数字N，一半的测试用例（0&lt;N&lt;=50），一半的测试用例（0&lt;N&lt;=1000）</p><p>第二行N个数字Ai（0&lt;=Ai&lt;=50）</p><ul><li>输出：</li></ul><p>用空格隔开的两个整数Sa和Sb</p><ul><li>样例输入：</li></ul><p>4<br>1 2 3 4</p><ul><li>样例输出：</li></ul><p>7 4</p><ul><li><p>解题思路：模拟</p></li><li><p>参考程序：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int n, a, k = 1;</span><br><span class="line">deque&lt;int&gt; dq;</span><br><span class="line">int pa = 0, sa = 0, pb = 0, sb = 0;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;a);</span><br><span class="line">        dq.push_back(a);</span><br><span class="line">    &#125;</span><br><span class="line">    while (dq.size()) &#123;</span><br><span class="line">        int left = dq.front();</span><br><span class="line">        int right = dq.back();</span><br><span class="line">        if (k % 2) &#123;</span><br><span class="line">            if (abs(left - pa) &gt;= abs(right - pa)) &#123;</span><br><span class="line">                dq.pop_front();</span><br><span class="line">                sa += abs(left - pa);</span><br><span class="line">                pa = left;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                dq.pop_back();</span><br><span class="line">                sa += abs(right - pa);</span><br><span class="line">                pa = right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            if (abs(left - pb) &gt;= abs(right - pb)) &#123;</span><br><span class="line">                dq.pop_front();</span><br><span class="line">                sb += abs(left - pb);</span><br><span class="line">                pb = left;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                dq.pop_back();</span><br><span class="line">                sb += abs(right - pb);</span><br><span class="line">                pb = right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d %d\n&quot;, sa, sb);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="聊天消息排版"><a href="#聊天消息排版" class="headerlink" title="聊天消息排版"></a>聊天消息排版</h4><ul><li>描述</li></ul><p>在网游中，聊天功能是一项非常重要的功能，加上玩家可以打出游戏内置的一些表情图片，因此需要实现一个图文混排系统，如下图所示。<br>玩家在聊天框输入的是一段utf-8编码的文字，且只会包含中文、英文、中英文的标点符号和空格（不会出现换行、回车和制表符）。按照网易游戏的传统，井号（#）是作为一个转义字符，支持下面几种转义行为：</p><ol><li>#加一个数字来表示内置的表情图片，为了简化问题，我们这里只支持20个表情图片，从0开始计数，并且数字是按最长匹配原则去匹配，比如#0表示0号表情图片、#1表示1号表情图片、#19表示19号表情图片、#20则表示2号表情图片后面加数字0。需要注意的是#00表示的是0号表情图片加后面数字0。</li><li>#r表示换行，遇到以后会自动切换到下一行开始排版。</li><li>##表示显示出#这个符号</li><li>如果玩家不按规则输入错误的转义，则按照玩家的输入原样显示，比如#a、#、#、#啊</li></ol><p><img src="/2019/10/07/netease/002.jpg" alt=""></p><p>上图所示的玩家输入为：“Hello world#大家好#r欢迎大家参加#1祝大家取得好成绩”</p><p>排版的时候需要像上图一样，将文字从起始位置开始，依次显示在聊天窗囗里，一些显示规则如下所示：</p><ol><li><p>聊天窗囗的宽度固定为W像素，起始坐标为左上角，坐标为（0，0），右上角坐标为（W-1，0），坐标向右向下增长。任何文字和表情必须显示在窗口内，不能超出窗口。但是高度可以无限向下延伸。</p></li><li><p>显示的字体均为等宽字体，英文（包括英文标点符号和空格）的字体宽度统一为XE，高度统一为YE。中文（包括中文的标点符号）的字体宽度统一为XC，高度统一为YC。</p></li><li><p>每个表情图片的宽高是独立的，0号表情图片的宽度为X0，高度Y0，依次类推，19号表情图片的宽度为×19，高度为Y19。</p></li><li><p>字符（中英文以及标点符号、空格等，下同）与字符之间、字符与表情之间、表情与表情之间都需要额外保留一个PX像素的字间距。每一行第一个字符左边，以及最后一个字符右边不需要保留字间距。</p></li><li><p>当下一个字符或者表情无法在本行W宽度的像素内完整显示的话，则会强行换到下一行首开始显示。遇到#r的时候也会自动换到下一行开始显示下一个字符或表情。</p></li><li><p>在一行里出现高度不同的中英文以及表情的时候，需要将其底部对齐。</p></li><li><p>当一行里没有任何字符或表情，直接被#r换行的时候，这一行的高度算英文字体的高度。</p></li><li><p>每一行里高度最高的字符或表情，需要同上一行的的底部保留PY像素的行间距。第一行上面与最后一行下面不需要保留行间距。</p></li><li><p>最后一个字符或表情显示显示以后，它的右下角坐标则为结束坐标。也就是本题需要求解的问题。输入保证最后不会以#r结尾。</p></li></ol><ul><li>输入：</li></ul><p>每个测试输入包含1个测试用例<br>第一行为7个正整数w，XE，YE，XC，YC，BX，PY<br>第二行为40个正整数x0，Y0，X1，Y1…X19，Y19<br>第三行为长度不超过10000的十六进制编码过的玩家输入，即玩家输入的utf-8编码的数据每个字节的数字转成大写的十六进制表示，不足两位的话前面补0（同c里printf的%x格式化），然后不同字节的十六进制编码表示依次拼接起来。<br>比如Hello的十六进制编码表示为48656C6C6F。<br>前两行的各个数字含义如上文描述，其中50&lt; w &lt;10000，0&lt;其他&lt;50。</p><ul><li>输出：</li></ul><p>输出用空格隔开的两个数字，表示结束坐标</p><ul><li>输入样例：</li></ul><p>60 2 4 3 4 1 3<br>7 6 7 6 7 6 7 6 7 6 7 6 7 6 7 6 7 6 7 6 7 6 7 6 7 6 7 6 7 6 7 6 7 6 7 6 7 6 7 6<br>48656C6C6F20776F726C6423E5A4A7E5AEB6E5A5B<br>D2372E6ACA2E8BF8EE5A4A7E5AEB6E58F82E58AA0<br>E7BD91E69893E99BB7E781ABE6A0A1E59BADE68B9<br>BE881982331E7A59DE5A4A7E5AEB6E58F96E5BE97<br>E5A5BDE68890E7BBA9</p><ul><li>输出样例：</li></ul><p>38 19</p><ul><li><p>解题思路：模拟</p></li><li><p>参考程序：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="黑客行动"><a href="#黑客行动" class="headerlink" title="黑客行动"></a>黑客行动</h4><ul><li>描述：</li></ul><p>钱老板家的电子保险柜被一个神秘的安保函数y=f(x)保护，每次试图开锁时，系统都会调用安保函数代码输入一个(0,1)之间的浮点数x，如果安保函数能输出正确的y数值则可以打开保险柜，否则就会报警。黑客小军想办法获取到了一份这个安保函数的测试程序，但这个程序并不能在钱老板家的系统上直接运行，必须要重新编码一份新的代码才能使用，请帮助小军实现这个安保函数代码！<br>你可以在以下的URL下载这份测试程序的可执行文件，压缩包里包含windows、linux和macos三个平台下的可执行程序：<br><a href="http://guess.zip" target="_blank" rel="noopener">http://guess.zip</a></p><ul><li>输入：</li></ul><p>一个(0,1)的浮点数，精确到小数点后6位</p><ul><li>输出：</li></ul><p>一个浮点数，精确到小数点后6位</p><ul><li>输入样例：</li></ul><p>0.268044</p><ul><li>输出样例：</li></ul><p>2.681916</p><ul><li>备注：</li></ul><p>本题的判题标准，如果你的代码输出的结果四舍五入到小数点后5位与标准答案四舍五入到小数点后5位一致就算正确</p><ul><li><p>解题思路：</p></li><li><p>参考程序：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;窗口点击模拟&quot;&gt;&lt;a href=&quot;#窗口点击模拟&quot; class=&quot;headerlink&quot; title=&quot;窗口点击模拟&quot;&gt;&lt;/a&gt;窗口点击模拟&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;描述：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本题需要让你模拟一下在Windows系统里窗囗和鼠标点击的操作，具体如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;屏幕分辨率为3840 * 2160，左上角坐标为（0，0），右下角坐标为（3839，2159）&lt;/li&gt;
&lt;li&gt;窗口是一个矩形的形状，由左上角坐标（X，Y），和宽高（W，H），四个数字来定位。左上角坐标为（X，Y）、右下角坐标为（X+W，Y+H），其中左上角坐标一定会在屏幕范围内，其他一些部分可能会超过屏幕范围。&lt;/li&gt;
&lt;li&gt;窗囗的点击和遮挡规则同Windows，但是不考虑关闭窗囗、最大化、最小化和强制置顶的情况。即&lt;br&gt; 3.1 如果发生重叠的话，后面打开的窗口会显示在前面打开的窗口上面&lt;br&gt; 3.2 当鼠标发生一次点击的时候，需要判断点击到了哪个窗口，如果同个坐标有多个窗口，算点击到最上层的那个&lt;br&gt; 3.3 当一个窗囗被点击的时候，会浮动到最上层&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://e99net.github.io/categories/Algorithm/"/>
    
    
      <category term="Dynamic Programming" scheme="https://e99net.github.io/tags/Dynamic-Programming/"/>
    
      <category term="Simulation" scheme="https://e99net.github.io/tags/Simulation/"/>
    
  </entry>
  
  <entry>
    <title>洛谷的刷题日常之P1967</title>
    <link href="https://e99net.github.io/2019/10/06/luogu_P1967/"/>
    <id>https://e99net.github.io/2019/10/06/luogu_P1967/</id>
    <published>2019-10-06T11:02:59.655Z</published>
    <updated>2019-10-06T11:54:02.534Z</updated>
    
    <content type="html"><![CDATA[<h4 id="货车运输"><a href="#货车运输" class="headerlink" title="货车运输"></a>货车运输</h4><p>这是一道比较综合的题，非常的niubility（我不会做的题都niubility，QWQ），用到的知识包括图论、倍增、贪心、LCA、生成树、并查集。</p><ul><li>描述：</li></ul><p>A国有n座城市，编号从1到n，城市之间有m条双向道路。每一条道路对车辆都有重量限制，简称限重。现在有q辆货车在运输货物， 司机们想知道每辆车在不超过车辆限重的情况下，最多能运多重的货物。</p><a id="more"></a><ul><li>输入：</li></ul><p>第一行有两个用空格隔开的整数n和m，表示A国有n座城市和m条道路。<br>接下来的m行，每行有3个整数x,y,z，每两个整数之间用一个空格隔开，表示从x号城市到y号城市有一条限重为z的道路。<br>注意：x不等于 y，两座城市之间可能有多条道路。</p><p>接下来一行有一个整数q，表示有q辆货车需要运货。</p><p>接下来的q行，每行有两个整数x、y，用一个空格隔开，表示一辆货车需要从x城市运输货物到y城市。<br>注意：x不等于y。</p><ul><li>输出：</li></ul><p>共有q行，每行一个整数，表示对于每一辆货车，它的最大载重是多少。如果货车不能到达目的地，输出-1。</p><ul><li>输入样例：</li></ul><p>4 3<br>1 2 4<br>2 3 3<br>3 1 1<br>3<br>1 3<br>1 4<br>1 3</p><ul><li>输出样例：</li></ul><p>3<br>-1<br>3</p><ul><li><p>解题思路：</p><ul><li>贪心：因为要使得货车运的货物尽可能重，所以权值较小的边不会被走过。</li><li>图论：根据给出的数据建原始图，然后根据上一步的贪心策略建新图，构造最大生成树。</li><li>生成树：构造最大生成树可以使用Kruskal算法。</li><li>并查集：Kruskal算法可以用并查集维护节点的连通情况。</li><li>LCA：在最大生成树上求最近公共祖先，得到两个节点之间最小边权的最大值，即题中的最大载重。</li><li>倍增：树上倍增法求LCA。</li></ul></li><li><p>参考代码：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define INF 0x3f3f3f3f</span><br><span class="line"></span><br><span class="line">struct road &#123;</span><br><span class="line">    int x,y,z;</span><br><span class="line">&#125;roads[50010];//原始图</span><br><span class="line"></span><br><span class="line">struct edge &#123;</span><br><span class="line">    int to,next,w;</span><br><span class="line">&#125;edges[50010];//存储最大生成树的新图</span><br><span class="line"></span><br><span class="line">//fa数组表示并查集中的父节点，f数组表示树上的父节点，w数组表示最大载重 </span><br><span class="line">int x,y,cnt,head[10010],fa[10010],f[10010][21],deep[10010],w[10010][21],n,m,q;</span><br><span class="line">bool vis[10010];</span><br><span class="line"></span><br><span class="line">//自定义排序规则，边权大的在前面</span><br><span class="line">bool cmp(road x,road y) &#123;</span><br><span class="line">    return x.z&gt;y.z;</span><br><span class="line">&#125;</span><br><span class="line">//前向星存新图</span><br><span class="line">void addroad(int start,int end,int w) &#123;</span><br><span class="line">    edges[++cnt].next=head[start];</span><br><span class="line">    edges[cnt].to=end;</span><br><span class="line">    edges[cnt].w=w;</span><br><span class="line">    head[start]=cnt;</span><br><span class="line">&#125;</span><br><span class="line">//并查集的查找操作</span><br><span class="line">int Find(int x) &#123;</span><br><span class="line">    if(x!=fa[x]) fa[x]=Find(fa[x]);</span><br><span class="line">    return fa[x];</span><br><span class="line">&#125;</span><br><span class="line">//Kruskal算法</span><br><span class="line">void kruskal() &#123;</span><br><span class="line">    sort(roads+1,roads+m+1,cmp);</span><br><span class="line">    for(int i=1;i&lt;=n;i++) fa[i]=i;//并查集的初始化操作</span><br><span class="line">    for(int i=1;i&lt;=m;i++) &#123;</span><br><span class="line">        //并查集的合并操作</span><br><span class="line">        int a=Find(roads[i].x);</span><br><span class="line">        int b=Find(roads[i].y);</span><br><span class="line">        if(a!=b) &#123;</span><br><span class="line">            fa[a]=b;</span><br><span class="line">            //无向图，双向边</span><br><span class="line">            addroad(roads[i].x,roads[i].y,roads[i].z);</span><br><span class="line">            addroad(roads[i].y,roads[i].x,roads[i].z);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//预处理：从根节点进行搜索，求节点深度</span><br><span class="line">void dfs(int node) &#123;</span><br><span class="line">    vis[node]=true;</span><br><span class="line">    for(int i=head[node];i;i=edges[i].next) &#123;//前向星遍历</span><br><span class="line">        int to=edges[i].to;</span><br><span class="line">        if(vis[to]) continue;</span><br><span class="line">        deep[to]=deep[node]+1;//计算深度</span><br><span class="line">        f[to][0]=node;//存父节点</span><br><span class="line">        w[to][0]=edges[i].w;//存节点到父节点的权值</span><br><span class="line">        dfs(to);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//树上倍增法优化求解LCA问题</span><br><span class="line">int lca(int x,int y) &#123;</span><br><span class="line">    int a=Find(x);</span><br><span class="line">    int b=Find(y);</span><br><span class="line">    if(a!=b) return -1;//不连通输出-1</span><br><span class="line">    int ans=INF;</span><br><span class="line">    if(deep[x]&gt;deep[y]) swap(x,y);//始终使得y节点更深</span><br><span class="line">    //将y节点提到与x节点相同的深度</span><br><span class="line">    for(int i=20;i&gt;=0;i--) &#123;</span><br><span class="line">        if(deep[f[y][i]]&gt;=deep[x]) &#123;</span><br><span class="line">            ans=min(ans,w[y][i]);//更新最大载重（最小边权）</span><br><span class="line">            y=f[y][i];//修改y的位置</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(x==y) return ans;//如果位置已经相等，直接返回答案</span><br><span class="line">    //寻找公共祖先</span><br><span class="line">    for(int i=20;i&gt;=0;i--) &#123;</span><br><span class="line">        if(f[x][i]!=f[y][i]) &#123;</span><br><span class="line">            ans=min(ans,min(w[x][i],w[y][i]));//更新最大载重（最小边权）</span><br><span class="line">            x=f[x][i];//修改x的位置</span><br><span class="line">            y=f[y][i];//修改y的位置</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans=min(ans,min(w[x][0],w[y][0]));//更新x,y到公共祖先的最大载重，fa[x][0]、fa[y][0]即为公共祖先 </span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">    for(int i=1;i&lt;=m;i++) &#123;//存原始图</span><br><span class="line">        scanf(&quot;%d%d%d&quot;,&amp;roads[i].x,&amp;roads[i].y,&amp;roads[i].z);</span><br><span class="line">    &#125;</span><br><span class="line">    kruskal();</span><br><span class="line">    for(int i=1;i&lt;=n;i++) &#123;//预处理</span><br><span class="line">        if(!vis[i]) &#123;</span><br><span class="line">            deep[i]=1;</span><br><span class="line">            dfs(i);</span><br><span class="line">            f[i][0]=i;</span><br><span class="line">            w[i][0]=INF;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //LCA初始化</span><br><span class="line">    for(int i=1;i&lt;=20;i++) &#123;</span><br><span class="line">        for(int j=1;j&lt;=n;j++) &#123;</span><br><span class="line">            f[j][i]=f[f[j][i-1]][i-1];</span><br><span class="line">            w[j][i]=min(w[j][i-1],w[f[j][i-1]][i-1]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;q);</span><br><span class="line">    for(int i=1;i&lt;=q;i++) &#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;x,&amp;y);</span><br><span class="line">        printf(&quot;%d\n&quot;,lca(x,y));//O(logn)复杂度回答询问</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;货车运输&quot;&gt;&lt;a href=&quot;#货车运输&quot; class=&quot;headerlink&quot; title=&quot;货车运输&quot;&gt;&lt;/a&gt;货车运输&lt;/h4&gt;&lt;p&gt;这是一道比较综合的题，非常的niubility（我不会做的题都niubility，QWQ），用到的知识包括图论、倍增、贪心、LCA、生成树、并查集。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;描述：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A国有n座城市，编号从1到n，城市之间有m条双向道路。每一条道路对车辆都有重量限制，简称限重。现在有q辆货车在运输货物， 司机们想知道每辆车在不超过车辆限重的情况下，最多能运多重的货物。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://e99net.github.io/categories/Algorithm/"/>
    
    
      <category term="Graph theory" scheme="https://e99net.github.io/tags/Graph-theory/"/>
    
      <category term="LCA" scheme="https://e99net.github.io/tags/LCA/"/>
    
      <category term="Greedy" scheme="https://e99net.github.io/tags/Greedy/"/>
    
      <category term="Union-Find Set" scheme="https://e99net.github.io/tags/Union-Find-Set/"/>
    
      <category term="Spanning tree" scheme="https://e99net.github.io/tags/Spanning-tree/"/>
    
      <category term="Doubling" scheme="https://e99net.github.io/tags/Doubling/"/>
    
  </entry>
  
  <entry>
    <title>洛谷的刷题日常之P1147</title>
    <link href="https://e99net.github.io/2019/10/05/luogu_P1147/"/>
    <id>https://e99net.github.io/2019/10/05/luogu_P1147/</id>
    <published>2019-10-04T16:15:38.897Z</published>
    <updated>2019-10-04T16:23:29.233Z</updated>
    
    <content type="html"><![CDATA[<h4 id="连续自然数和"><a href="#连续自然数和" class="headerlink" title="连续自然数和"></a>连续自然数和</h4><ul><li>描述：</li></ul><p>对一个给定的自然数$M$，求出所有的连续的自然数段，这些连续的自然数段中的全部数之和为$M$。<br>例子：1998+1999+2000+2001+2002 = 10000，所以从1998到2002的一个自然数段为$M=10000$的一个解。</p><a id="more"></a><ul><li>输入：</li></ul><p>包含一个整数的单独一行给出M的值（$10 \le M \le 2000000$）。</p><ul><li>输出：</li></ul><p>每行两个自然数，给出一个满足条件的连续自然数段中的第一个数和最后一个数，两数之间用一个空格隔开，所有输出行的第一个按从小到大的升序排列，对于给定的输入数据，保证至少有一个解。</p><ul><li>输入样例：</li></ul><p>10000</p><ul><li>输出样例：</li></ul><p>18 142<br>297 328<br>388 412<br>1998 2002</p><ul><li><p>解题思路：前缀和+二分</p></li><li><p>参考代码:</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define ll long long</span><br><span class="line">ll sum[2000010];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    ll m;</span><br><span class="line">    scanf(&quot;%lld&quot;,&amp;m);</span><br><span class="line">    for(int i=1;i&lt;=m;i++)  sum[i]=sum[i-1]+i;</span><br><span class="line">    for(int i=1;i&lt;=m-1;i++) &#123;</span><br><span class="line">        ll l=i,r=m-1,mid;</span><br><span class="line">        while(l&lt;=r) &#123;</span><br><span class="line">            mid=(l+r)/2;</span><br><span class="line">            ll t=sum[mid]-sum[i-1];</span><br><span class="line">            if(t==m) &#123;</span><br><span class="line">                printf(&quot;%d %d\n&quot;,i,mid);</span><br><span class="line">                break;</span><br><span class="line">            &#125;else if(t&lt;m) &#123;</span><br><span class="line">                l=mid+1;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                r=mid-1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;连续自然数和&quot;&gt;&lt;a href=&quot;#连续自然数和&quot; class=&quot;headerlink&quot; title=&quot;连续自然数和&quot;&gt;&lt;/a&gt;连续自然数和&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;描述：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对一个给定的自然数$M$，求出所有的连续的自然数段，这些连续的自然数段中的全部数之和为$M$。&lt;br&gt;例子：1998+1999+2000+2001+2002 = 10000，所以从1998到2002的一个自然数段为$M=10000$的一个解。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://e99net.github.io/categories/Algorithm/"/>
    
    
      <category term="Prefix Sum" scheme="https://e99net.github.io/tags/Prefix-Sum/"/>
    
      <category term="Binary Search" scheme="https://e99net.github.io/tags/Binary-Search/"/>
    
  </entry>
  
</feed>
