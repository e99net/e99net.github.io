<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>99°</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://e99net.github.io/"/>
  <updated>2019-10-22T14:59:56.341Z</updated>
  <id>https://e99net.github.io/</id>
  
  <author>
    <name>sqLiu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>总结买卖股票这一类型的几道题</title>
    <link href="https://e99net.github.io/2019/10/22/LeetCode_BestTimeToBuyAndSellStock/"/>
    <id>https://e99net.github.io/2019/10/22/LeetCode_BestTimeToBuyAndSellStock/</id>
    <published>2019-10-22T12:01:17.021Z</published>
    <updated>2019-10-22T14:59:56.341Z</updated>
    
    <content type="html"><![CDATA[<h4 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h4><ul><li>描述：</li></ul><p>给一个数组，数组中的第i个元素代表第i天的股票价格。如果只允许完全至多一次交易（即买进一股股票并卖出这股股票），那么最大收益是多少？</p><p>注意：卖出股票的时间不能早于买进股票的时间。</p><a id="more"></a><ul><li>输入：</li></ul><p>一个数组。</p><ul><li>输出：</li></ul><p>买卖股票的最大收益。</p><ul><li>样例输入1：</li></ul><p>[7,1,5,3,6,4]</p><ul><li>样例输出1：</li></ul><p>5</p><ul><li>样例输入2：</li></ul><p>[7,6,4,3,1]</p><ul><li>样例输出2：</li></ul><p>0</p><ul><li><p>解题思路：贪心法</p></li><li><p>参考代码:</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//复杂度O(n)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">        if(prices.size()&lt;2)</span><br><span class="line">            return 0;</span><br><span class="line">        int max=0,diff=0;</span><br><span class="line">        for(int i=0;i&lt;prices.size()-1;i++) &#123;</span><br><span class="line">            for(int j=i+1;j&lt;prices.size();j++) &#123;</span><br><span class="line">                diff=prices[j]-prices[i];</span><br><span class="line">                if(diff&gt;max) max=diff;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h4><ul><li>描述：</li></ul><p>给一个数组，数组中的第i个元素代表第i天的股票价格。如果允许完成多次交易（即多次买进一股股票并卖出这股股票），那么最大收益是多少？</p><p>注意：不能同时进行多次交易，必须在再次买进股票前卖出股票。</p><ul><li>输入：</li></ul><p>一个数组。</p><ul><li>输出：</li></ul><p>买卖股票的最大收益。</p><ul><li>输入样例1：</li></ul><p>[7,1,5,3,6,4]</p><ul><li>输出样例1：</li></ul><p>7</p><ul><li><p>说明：第二天买进，第三天卖出，获得收益5-1=4；第四天买进，第五天卖出，获得收益6-3=3。总共获得收益4+3=7。</p></li><li><p>输入样例2：</p></li></ul><p>[1,2,3,4,5]</p><ul><li>输出样例2：</li></ul><p>4</p><ul><li><p>说明：第一天买进，第五天卖出，获得收益5-1=4。不能在第一天买进，第二天买进，稍后再卖出它们，因为这算同时进行多次交易。</p></li><li><p>输入样例3：</p></li></ul><p>[7,6,4,3,1]</p><ul><li>输出样例3：</li></ul><p>0</p><ul><li><p>解题思路：贪心法</p></li><li><p>参考代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProfit(vector&lt;int&gt;&amp; prices)&#123;</span><br><span class="line">        int sum=0;</span><br><span class="line">        for(int i=1;i&lt;prices.size();i++) &#123;</span><br><span class="line">            int diff=prices[i]-prices[i-1];</span><br><span class="line">            if(diff&gt;0) sum+=diff;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h4><ul><li>描述：</li></ul><p>给一个数组，数组中的第i个元素代表第i天的股票价格。如果只允许完成最多两次交易（即最多两次买进股票并卖出股票），那么最大收益是多少？</p><p>注意：不能同时进行多次交易，必须在再次买进股票前卖出股票。</p><ul><li>输入：</li></ul><p>一个数组。</p><ul><li>输出：</li></ul><p>买卖股票的最大收益。</p><ul><li>输入样例1：</li></ul><p>[3,3,5,0,0,3,1,4]</p><ul><li>输出样例1：</li></ul><p>6</p><ul><li><p>说明：第四天买进，第六天卖出，获得收益3-0=3；然后第七天买进，第八天卖出，获得收益4-1=3。总共获得收益3+3=6。</p></li><li><p>输入样例2：</p></li></ul><p>[1,2,3,4,5]</p><ul><li>输出样例2：</li></ul><p>4</p><ul><li><p>说明：第一天买进，第五天卖出，获得收益5-1=4。不能在第一天买进，第二天买进，稍后再卖出它们，因为这算同时进行多次交易。</p></li><li><p>输入样例3：</p></li></ul><p>[7,6,4,3,1]</p><ul><li>输出样例3：</li></ul><p>0</p><ul><li><p>解题思路：动态规划</p></li><li><p>参考代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">        if(prices.size()&lt;2)return 0;</span><br><span class="line">        const int n=prices.size();</span><br><span class="line">        vector&lt;int&gt; f(n,0);</span><br><span class="line">        vector&lt;int&gt; g(n,0);</span><br><span class="line">        for(int i=1,valley=prices[0];i&lt;n;i++) &#123;</span><br><span class="line">            valley=min(valley,prices[i]);</span><br><span class="line">            f[i]=max(f[i-1],prices[i]-valley);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=n-2,peak=prices[n-1];i&gt;=0;i--) &#123;</span><br><span class="line">            peak=max(peak,prices[i]);</span><br><span class="line">            g[i]=max(g[i],peak-prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        int max_profit=0;</span><br><span class="line">        for(int i=0;i&lt;n;i++)</span><br><span class="line">            max_profit=max(max_profit,f[i]+g[i]);</span><br><span class="line">        return max_profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="第四题"><a href="#第四题" class="headerlink" title="第四题"></a>第四题</h4><ul><li>描述：</li></ul><p>给一个数组，数组中的第i个元素代表第i天的股票价格。如果只允许完成最多k次交易（即最多k次买进股票并卖出股票），那么最大收益是多少？</p><p>注意：不能同时进行多次交易，必须在再次买进股票前卖出股票。</p><ul><li>输入：</li></ul><p>一个数组和一个数，用空格分隔。</p><ul><li>输出：</li></ul><p>买卖股票的最大收益。</p><ul><li>输入样例1：</li></ul><p>[2,4,1] 2</p><ul><li>输出样例1：</li></ul><p>2</p><ul><li><p>说明：第一天买进，第二天卖出，总共获得收益4-2=2。</p></li><li><p>输入样例2：</p></li></ul><p>[3,2,6,5,0,3] 2</p><ul><li>输出样例2：</li></ul><p>7</p><ul><li><p>说明：第二天买进，第三天卖出，获得收益6-2=4；然后在第五天买进，第六天卖出，获得收益3-0=3。总共获得收益4+3=7。</p></li><li><p>解题思路：动态规划</p></li></ul><p>这道题是第三题的推广<br>如果k的值远大于prices的天数，应该直接用第二题的解法，所以这道题又是第二题和第三题的结合</p><ul><li>参考代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProfit(int k, vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">        if(prices.empty()) return 0;</span><br><span class="line">        const int n=prices.size();</span><br><span class="line">        if(k&gt;=n) return solveMaxProfit(prices);</span><br><span class="line">        int global[k+1]=&#123;0&#125;;</span><br><span class="line">        int local[k+1]=&#123;0&#125;;</span><br><span class="line">        for(int i=0;i&lt;n-1;i++) &#123;</span><br><span class="line">            int diff=prices[i+1]-prices[i];</span><br><span class="line">            for(int j=k;j&gt;=1;j--) &#123;</span><br><span class="line">                local[j]=max(global[j-1]+max(diff,0),local[j]+diff);</span><br><span class="line">                global[j]=max(global[j],local[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return global[k];</span><br><span class="line">    &#125;</span><br><span class="line">    int solveMaxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">        int res=0;</span><br><span class="line">        for(int i=1;i&lt;prices.size();i++) &#123;</span><br><span class="line">            if(prices[i]-prices[i-1]&gt;0) &#123;</span><br><span class="line">                res+=prices[i]-prices[i-1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="第五题"><a href="#第五题" class="headerlink" title="第五题"></a>第五题</h4><ul><li>描述：</li></ul><p>给一个数组，数组中的第i个元素代表第i天的股票价格。如果允许按照以下限制完成多次交易（即多次买进股票并卖出股票），那么最大收益是多少？</p><p>限制1：不能同时进行多次交易，必须在再次买进股票前卖出股票。<br>限制2：在卖出股票后，不能买进下一天的股票（冷却一天）。</p><ul><li>输入：</li></ul><p>一个数组。</p><ul><li>输出：</li></ul><p>买卖股票的最大收益。</p><ul><li>输入样例：</li></ul><p>[1,2,3,0,2]</p><ul><li>输出样例：</li></ul><p>3</p><ul><li><p>说明：第一天买进，第二天卖出，第三天冷却，第四天买进，第五天卖出，总共获得收益1+2=3。</p></li><li><p>解题思路：动态规划</p></li></ul><p><img src="/2019/10/22/LeetCode_BestTimeToBuyAndSellStock/585082-20160229165036642-1352963708.png" alt=""></p><p>状态转移图中：<br>S0 代表没有买入的状态<br>S1 代表买入后等待卖出的状态<br>S2 代表卖出后的状态</p><p>S2与S0的区别是：因为题目要求卖出后必须cooldown一轮，所以卖出进入S2后，必须再进入S0这个等待买入的状态，这一状态转换代表cooldown一轮</p><p>状态转移方程：<br>s0[i] = max(s0[i-1], s2[i-1])<br>s1[i] = max(s1[i-1], s0[i-1] - price[i])<br>s2[i] = s1[i-1] + price[i]</p><ul><li>参考代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">        const int n=prices.size();</span><br><span class="line">        if(n&lt;=1) return 0;</span><br><span class="line">        vector&lt;int&gt; s0(n,0);</span><br><span class="line">        vector&lt;int&gt; s1(n,0);</span><br><span class="line">        vector&lt;int&gt; s2(n,0);</span><br><span class="line">        s1[0]=-prices[0];</span><br><span class="line">        s0[0]=0;</span><br><span class="line">        s2[0]=INT_MIN;</span><br><span class="line">        for(int i=1;i&lt;n;i++) &#123;</span><br><span class="line">            s0[i]=max(s0[i-1],s2[i-1]);</span><br><span class="line">            s1[i]=max(s1[i-1],s0[i-1]-prices[i]);</span><br><span class="line">            s2[i]=s1[i-1]+prices[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return max(s0[n-1],s2[n-1]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="第六题"><a href="#第六题" class="headerlink" title="第六题"></a>第六题</h4><ul><li>描述：</li></ul><p>给一个数组和一个数，数组中的第i个元素代表第i天的股票价格，那个数代表交易费。如果允许完成多次交易（即多次买进股票并卖出股票），且每次交易需要支付交易费，那么最大收益是多少？</p><p>注意：不能同时进行多次交易，必须在再次买进股票前卖出股票。</p><ul><li>输入：</li></ul><p>一个数组prices（$0 &lt; prices.length \le 50000$，$0 &lt; prices[i] &lt; 50000$）和一个数fee（$0 \le fee &lt; 50000$），用空格分隔。</p><ul><li>输出：</li></ul><p>买卖股票的最大收益。</p><ul><li>输入样例：</li></ul><p>[1,3,2,8,4,9] 2</p><ul><li>输出样例：</li></ul><p>8</p><ul><li><p>说明：第一天买进，第四天卖出，第五天买进，第六天卖出，总共获得收益(8-1-2)+(9-4-2)=8。</p></li><li><p>解题思路：动态规划</p></li></ul><p>贪心法不行，当卖出的利润小于交易费时，不应该卖出，否则会亏损。</p><p>状态转移方程：<br>sold[i] = max(sold[i - 1], hold[i - 1] + prices[i] - fee)<br>hold[i] = max(hold[i - 1], sold[i - 1] - prices[i])</p><p>不管是卖出还是保留，第i天的利润只跟第i-1天有关系，所以可以优化空间，用两个变量来表示当前的卖出和保留的利润，</p><ul><li>参考代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProfit(vector&lt;int&gt;&amp; prices, int fee) &#123;</span><br><span class="line">        int sold=0,hold=-prices[0];</span><br><span class="line">        for(int price:prices) &#123;</span><br><span class="line">            int t=sold;</span><br><span class="line">            sold=max(sold,hold+price-fee);</span><br><span class="line">            hold=max(hold,t-price);</span><br><span class="line">        &#125;</span><br><span class="line">        return sold;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;第一题&quot;&gt;&lt;a href=&quot;#第一题&quot; class=&quot;headerlink&quot; title=&quot;第一题&quot;&gt;&lt;/a&gt;第一题&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;描述：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;给一个数组，数组中的第i个元素代表第i天的股票价格。如果只允许完全至多一次交易（即买进一股股票并卖出这股股票），那么最大收益是多少？&lt;/p&gt;
&lt;p&gt;注意：卖出股票的时间不能早于买进股票的时间。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://e99net.github.io/categories/Algorithm/"/>
    
    
      <category term="Dynamic Programming" scheme="https://e99net.github.io/tags/Dynamic-Programming/"/>
    
      <category term="Greedy" scheme="https://e99net.github.io/tags/Greedy/"/>
    
  </entry>
  
  <entry>
    <title>几道比较有意思的字符串题</title>
    <link href="https://e99net.github.io/2019/10/21/string/"/>
    <id>https://e99net.github.io/2019/10/21/string/</id>
    <published>2019-10-21T08:41:40.209Z</published>
    <updated>2019-10-21T08:58:13.122Z</updated>
    
    <content type="html"><![CDATA[<h4 id="整数反转求和"><a href="#整数反转求和" class="headerlink" title="整数反转求和"></a>整数反转求和</h4><ul><li>描述：</li></ul><p>请您写一个reverseAdd函数，该函数分别将输入的两个正整数a和b的数字按照高位在右的方式反转求和。<br>例如，reverseAdd(123,456)=321+654=975。</p><a id="more"></a><ul><li>输入：</li></ul><p>两个正整数a和b，以空格分隔，$1 \le a,b \e 70000$。</p><ul><li>输出：</li></ul><p>输出一个整数，表示两个正整数反转求和的结果。</p><ul><li>样例输入：</li></ul><p>123 456</p><ul><li>样例输出：</li></ul><p>975</p><ul><li>解题思路：</li></ul><p>按照int型来处理两个输入参数会比较麻烦，按照字符串类型来处理两个输入参数则会大大简化处理过程。</p><ul><li>参考代码:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    string n,m;</span><br><span class="line">    while(cin&gt;&gt;n&gt;&gt;m) &#123;</span><br><span class="line">        int x=0,y=0,i;</span><br><span class="line">        if(m[0]==&apos;0&apos;&amp;&amp;n[0]==&apos;0&apos;)</span><br><span class="line">            break;</span><br><span class="line">        for(i=m.size()-1;i&gt;=0;i--)</span><br><span class="line">            x=x*10+m[i]-&apos;0&apos;;</span><br><span class="line">        for(i=n.size()-1;i&gt;=0;i--)</span><br><span class="line">            y=y*10+n[i]-&apos;0&apos;;</span><br><span class="line">        cout&lt;&lt;x+y&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="字符串计数"><a href="#字符串计数" class="headerlink" title="字符串计数"></a>字符串计数</h4><ul><li>描述：</li></ul><p>给定一个仅由小写字母组成且长度不超过106的字符串，将首字符移到末尾并记录所得的字符串，不断重复该操作，虽然记录了无限个字符串，但其中不同字符串的数目却是有限的，那么一共记录了多少个不同的字符串？</p><ul><li>输入：</li></ul><p>给定的字符串。</p><ul><li>输出：</li></ul><p>记录的不同字符串数目。</p><ul><li>输入样例：</li></ul><p>abab</p><ul><li>输出样例：</li></ul><p>2</p><ul><li>解题思路：</li></ul><p>模板题，考查KMP算法next数组的求解</p><ul><li>参考代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=1000007;</span><br><span class="line">char s[N];</span><br><span class="line">int next[N];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    scanf(&quot;%s&quot;,s);</span><br><span class="line">    int n=strlen(s);</span><br><span class="line">    next[0]=-1;</span><br><span class="line">    for(int i=0,j=-1;i&lt;n;)</span><br><span class="line">        if(j==-1||s[i]=s[j]) next[++i]=++j;</span><br><span class="line">        else j=next[j];</span><br><span class="line">    if(n%(n-next[n])) printf(&quot;%d&quot;,n)</span><br><span class="line">    else printf(&quot;%d&quot;,n-next[n]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;整数反转求和&quot;&gt;&lt;a href=&quot;#整数反转求和&quot; class=&quot;headerlink&quot; title=&quot;整数反转求和&quot;&gt;&lt;/a&gt;整数反转求和&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;描述：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;请您写一个reverseAdd函数，该函数分别将输入的两个正整数a和b的数字按照高位在右的方式反转求和。&lt;br&gt;例如，reverseAdd(123,456)=321+654=975。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://e99net.github.io/categories/Algorithm/"/>
    
    
      <category term="String" scheme="https://e99net.github.io/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>背包问题总结</title>
    <link href="https://e99net.github.io/2019/10/21/knapsack/"/>
    <id>https://e99net.github.io/2019/10/21/knapsack/</id>
    <published>2019-10-21T03:51:37.001Z</published>
    <updated>2019-10-22T15:00:50.330Z</updated>
    
    <content type="html"><![CDATA[<h4 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0/1背包问题"></a>0/1背包问题</h4><ul><li>描述：</li></ul><p>有$N$件物品和一个容量是$V$的背包。</p><p>第$i$件物品的体积是$v_i$，价值是$w_i$。</p><p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。<br>输出最大价值。</p><a id="more"></a><ul><li>输入：</li></ul><p>第一行两个整数$N$和$V$，$0 &lt; N,V \le 1000$，用空格隔开，分别表示物品数量和背包容积。</p><p>接下来有$N$行，每行两个整数$v_i$和$w_i$，$0 &lt; v_i,w_i \le 1000$，用空格隔开，分别表示第$i$件物品的体积和价值。</p><ul><li>输出：</li></ul><p>输出一个整数，表示最大价值。</p><ul><li>样例输入：</li></ul><p>4 5<br>1 2<br>2 4<br>3 4<br>4 5</p><ul><li>样例输出：</li></ul><p>8</p><ul><li>参考代码:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=1010;</span><br><span class="line">int n,m;</span><br><span class="line">int f[N];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(int i=0;i&lt;n;i++) &#123;</span><br><span class="line">        int c,w;</span><br><span class="line">        cin&gt;&gt;c&gt;&gt;w;</span><br><span class="line">        for(int j=m;j&gt;=c;j--)</span><br><span class="line">            f[j]=max(f[j],f[j-c]+w);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[m]&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h4><ul><li>描述：</li></ul><p>有$N$种物品和一个容量是$V$的背包，每种物品都有无限件可用。</p><p>第$i$种物品的体积是$v_i$，价值是$w_i$。</p><p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。<br>输出最大价值。</p><!-- more --><ul><li>输入：</li></ul><p>第一行两个整数$N$和$V$，$0 &lt; N,V \le 1000$，用空格隔开，分别表示物品种数和背包容积。</p><p>接下来有$N$行，每行两个整数$v_i$和$w_i$，$0 &lt; v_i,w_i \le 1000$，用空格隔开，分别表示第$i$种物品的体积和价值。</p><ul><li>输出：</li></ul><p>输出一个整数，表示最大价值。</p><ul><li>样例输入：</li></ul><p>4 5<br>1 2<br>2 4<br>3 4<br>4 5</p><ul><li>样例输出：</li></ul><p>10</p><ul><li>参考代码:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=1010;</span><br><span class="line">int n,m;</span><br><span class="line">int f[N];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cin&gt;n&gt;&gt;m;</span><br><span class="line">    for(int i=0;i&lt;n;i++) &#123;</span><br><span class="line">        int c,w;</span><br><span class="line">        cin&gt;&gt;c&gt;&gt;w;</span><br><span class="line">        for(int j=c;j&lt;=m;j++)</span><br><span class="line">            f[j]=max(f[j],f[j-c]+w);</span><br><span class="line">    &#125;</span><br><span class="line">    int res=0;</span><br><span class="line">    for(int i=0;i&lt;=m;i++) res=max(res,f[i]);</span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多重背包问题"><a href="#多重背包问题" class="headerlink" title="多重背包问题"></a>多重背包问题</h4><ul><li>描述：</li></ul><p>有$N$种物品和一个容量是$V$的背包。</p><p>第$i$种物品最多有$s_i$件，每件体积是$v_i$，价值是$w_i$。</p><p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且价值总和最大。<br>输出最大价值。</p><!-- more --><h5 id="暴力-O-N-M-S"><a href="#暴力-O-N-M-S" class="headerlink" title="暴力 O(N*M*S)"></a>暴力 O(N*M*S)</h5><ul><li>输入：</li></ul><p>第一行两个整数$N$和$V$，$0 &lt; N,V \le 100$，用空格隔开，分别表示物品种数和背包容积。</p><p>接下来有$N$行，每行三个整数$v_i$、$w_i$和$s_i$，$0 &lt; v_i,w_i,s_i \le 100$，用空格隔开，分别表示第$i$件物品的体积、价值和数量。</p><ul><li>输出：</li></ul><p>输出一个整数，表示最大价值。</p><ul><li>样例输入：</li></ul><p>4 5<br>1 2 3<br>2 4 1<br>3 4 3<br>4 5 2</p><ul><li>样例输出：</li></ul><p>10</p><ul><li>参考代码:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=110;</span><br><span class="line"></span><br><span class="line">int n,m;</span><br><span class="line">int f[N];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(int i=0;i&lt;n;i++) &#123;</span><br><span class="line">        int c,w,s;</span><br><span class="line">        cin&gt;&gt;c&gt;&gt;w&gt;&gt;s;</span><br><span class="line">        for(int j=m;j&gt;=0;j--)</span><br><span class="line">            for(int k=1;k&lt;=s;k++)</span><br><span class="line">                if(j&gt;=k*c)</span><br><span class="line">                    f[j]=max(f[j],f[j-k*c]+k*w);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[m]&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="二进制优化-O-N-M-log-S"><a href="#二进制优化-O-N-M-log-S" class="headerlink" title="二进制优化 O(N*M*log S)"></a>二进制优化 O(N*M*log S)</h5><ul><li>输入：</li></ul><p>第一行两个整数$N$和$V$，$0 &lt; N \le 1000$，$0 &lt; V \le 2000$，用空格隔开，分别表示物品种数和背包容积。</p><p>接下来有$N$行，每行三个整数$v_i$、$w_i$和$s_i$，$0 &lt; v_i,w_i,s_i \le 2000$，用空格隔开，分别表示第$i$件物品的体积、价值和数量。</p><ul><li>输出：</li></ul><p>输出一个整数，表示最大价值。</p><ul><li>样例输入：</li></ul><p>4 5<br>1 2 3<br>2 4 1<br>3 4 3<br>4 5 2</p><ul><li>样例输出：</li></ul><p>10</p><ul><li>参考代码:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=2010;</span><br><span class="line"></span><br><span class="line">int n,m;</span><br><span class="line">int f[N];</span><br><span class="line">struct Good &#123;</span><br><span class="line">    int v,w;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;Good&gt; goods;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(int i=0;i&lt;n;i++) &#123;</span><br><span class="line">        int v,w,s;</span><br><span class="line">        cin&gt;&gt;v&gt;&gt;w&gt;&gt;s;</span><br><span class="line">        for(int k=1;j&lt;=s;k*=2) &#123;</span><br><span class="line">            s-=k;</span><br><span class="line">            goods.push_back(&#123;v*k,w*k&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        if(s&gt;0) goods.push_back(&#123;v*s,w*s&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    for(auto good:goods)</span><br><span class="line">        for(int j=m;j&gt;=good.v;j--)</span><br><span class="line">            f[j]=max(f[j],f[j-good.v]+good.w);</span><br><span class="line">    cout&lt;&lt;f[m]&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="单调队列优化-O-N-M"><a href="#单调队列优化-O-N-M" class="headerlink" title="单调队列优化 O(N*M)"></a>单调队列优化 O(N*M)</h5><ul><li>输入：</li></ul><p>第一行两个整数$N$和$V$，$0 &lt; N \le 1000$，$0 &lt; V \le 20000$，用空格隔开，分别表示物品种数和背包容积。</p><p>接下来有$N$行，每行三个整数$v_i$、$w_i$和$s_i$，$0 &lt; v_i,w_i,s_i \le 20000$，用空格隔开，分别表示第$i$件物品的体积、价值和数量。</p><ul><li>输出：</li></ul><p>输出一个整数，表示最大价值。</p><ul><li>样例输入：</li></ul><p>4 5<br>1 2 3<br>2 4 1<br>3 4 3<br>4 5 2</p><ul><li>样例输出：</li></ul><p>10</p><ul><li>参考代码:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=20010;</span><br><span class="line"></span><br><span class="line">int n,m;</span><br><span class="line">int f[N],g[N],q[N];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(int i=0;i&lt;n;i++) &#123;</span><br><span class="line">        int c,w,s;</span><br><span class="line">        cin&gt;&gt;c&gt;&gt;w&gt;&gt;s;</span><br><span class="line">        memcpy(g,f,sizeof f);</span><br><span class="line"></span><br><span class="line">        for(int j=0;j&lt;c;j++) &#123;</span><br><span class="line">            int hh=0,tt=-1;</span><br><span class="line">            for(int k=j;k&lt;=m;k+=c) &#123;</span><br><span class="line">                f[k]=g[k];</span><br><span class="line">                if(hh&lt;=tt&amp;&amp;k-s*c&gt;q[hh]) hh++;</span><br><span class="line">                if(hh&lt;=tt) f[k]=max(f[k],g[q[hh]]+(k-q[hh])/c*w);</span><br><span class="line">                while(hh&lt;=tt&amp;&amp;g[q[tt]]-(q[tt]-j)/c*w&lt;=g[k]-(k-j)/c*w) tt--;</span><br><span class="line">                q[++tt]=k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[m]&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="混合背包问题"><a href="#混合背包问题" class="headerlink" title="混合背包问题"></a>混合背包问题</h4><ul><li>描述：</li></ul><p>有$N$种物品和一个容量是$V$的背包。</p><p>物品一共有三类：</p><ul><li>第一类物品只能用1次（01背包）</li><li>第二类物品可以用无限次（完全背包）</li><li>第三类物品最多只能用$s_i$次（多重背包）</li></ul><p>每种体积是$v_i$，价值是$w_i$。</p><p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且价值总和最大。<br>输出最大价值。</p><!-- more --><ul><li>输入：</li></ul><p>第一行两个整数$N$和$V$，$0 &lt; N,V \le 1000$，用空格隔开，分别表示物品数量和背包容积。</p><p>接下来有$N$行，每行三个整数$v_i$、$w_i$和$s_i$，用空格隔开，分别表示第$i$件物品的体积、价值和数量。</p><p>$0 &lt; v_i,w_i \le 1000$，$-1 \le s_i \le 1000$。</p><ul><li>$s_i=-1$表示第$i$种物品只能用1次</li><li>$s_i=0$表示第$i$种物品可以用无限次</li><li>$s_i&gt;0$表示第$i$种物品可以使用$s_i$次</li></ul><ul><li>输出：</li></ul><p>输出一个整数，表示最大价值。</p><ul><li>样例输入：</li></ul><p>4 5<br>1 2 -1<br>2 4 1<br>3 4 0<br>4 5 2</p><ul><li>样例输出：</li></ul><p>8</p><ul><li>参考代码:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=1010;</span><br><span class="line"></span><br><span class="line">int n,m;</span><br><span class="line">int f[N];</span><br><span class="line"></span><br><span class="line">struct Thing &#123;</span><br><span class="line">    int kind;</span><br><span class="line">    int v,w;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Thing&gt; things;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(int i=0;i&lt;n;i++) &#123;</span><br><span class="line">        int v,w,s;</span><br><span class="line">        cin&gt;&gt;v&gt;&gt;w&gt;&gt;s;</span><br><span class="line">        if(s&lt;0) things.push_back(&#123;-1,v,w&#125;);</span><br><span class="line">        else if(s==0) things.push_back(&#123;0,v,w&#125;);</span><br><span class="line">        else &#123;</span><br><span class="line">            for(int k=1;k&lt;=s;k*=2) &#123;</span><br><span class="line">                s-=k;</span><br><span class="line">                things.push_back(&#123;-1,v*k,w*k&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            if(s&gt;0)things.push_back(&#123;-1,v*s,w*s&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(auto thing : things) &#123;</span><br><span class="line">        if(thing.kind&lt;0) &#123;</span><br><span class="line">            for(int j=m;j&gt;=thing.v;j--) f[j]=max(f[j],f[j-thing.v]+thing.w);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            for(int j=thing.v;j&lt;=m;j++) f[j]=max(f[j],f[j-thing.v]+thing.w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[m]&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二维费用的背包问题"><a href="#二维费用的背包问题" class="headerlink" title="二维费用的背包问题"></a>二维费用的背包问题</h4><ul><li>描述：</li></ul><p>有$N$件物品和一个容量是$V$的背包，背包能承受的最大重量是$M$。</p><p>每件物品只能用一次。体积是$v_i$，重量是$m_i$，价值是$w_i$。</p><p>求解将哪些物品装入背包，可使物品总体积不超过背包容量，总重量不超过背包可承受的最大重量，且价值总和最大。<br>输出最大价值。</p><!-- more --><ul><li>输入：</li></ul><p>第一行三个整数$N$、$V$和$M$，$0 &lt; N \le 1000$，$0 &lt; V,M \le 100$，用空格隔开，分别表示物品件数、背包容积和背包可承受的最大重量。</p><p>接下来有$N$行，每行三个整数$v_i$、$m_i$和$w_i$，$0 &lt; v_i,m_i \le 100$，$0 &lt; w_i \le 1000$，用空格隔开，分别表示第$i$件物品的体积、重量和价值。</p><ul><li>输出：</li></ul><p>输出一个整数，表示最大价值。</p><ul><li>样例输入：</li></ul><p>4 5 6<br>1 2 3<br>2 4 4<br>3 4 5<br>4 5 6</p><ul><li>样例输出：</li></ul><p>8</p><ul><li>参考代码:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=110;</span><br><span class="line"></span><br><span class="line">int n,v,m;</span><br><span class="line">int f[N][N];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;v&gt;&gt;m;</span><br><span class="line">    for(int i=0;i&lt;n;i++) &#123;</span><br><span class="line">        int a,b,c;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">        for(int j=v;j&gt;=a;j--)</span><br><span class="line">            for(int k=m;k&gt;=b;k--)</span><br><span class="line">                f[j][k]=max(f[j][k],f[j-a][k-b]+c);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[v][m]&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="分组背包问题"><a href="#分组背包问题" class="headerlink" title="分组背包问题"></a>分组背包问题</h4><ul><li>描述：</li></ul><p>有$N$组物品和一个容量是$V$的背包。</p><p>每组物品有若干个，同一组内的物品最多只能选一个。</p><p>每件物品的体积是$v_{ij}$，价值是$w_{ij}$，其中$i$是组号，$j$是组内编号。</p><p>求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。</p><p>输出最大价值。</p><!-- more --><ul><li>输入：</li></ul><p>第一行有两个整数$N$和$V$，$0 &lt; N,V \le 100$，用空格隔开，分别表示物品组数和背包容量。</p><p>接下来有$N$组数据：</p><ul><li>每组数据第一行有一个整数$S_i$，$0 &lt; S_i \le 100$，表示第$i$个物品组的物品数量；</li><li>每组数据接下来有$S_i$行，每行有两个整数$v_{ij}$和$w_{ij}$，$0 &lt; v_{ij},w_{ij} \le 100$，用空格隔开，分别表示第$i$个物品组的第$j$个物品的体积和价值。</li></ul><ul><li>输出：</li></ul><p>输出一个整数，表示最大价值。</p><ul><li>样例输入：</li></ul><p>3 5<br>2<br>1 2<br>2 4<br>1<br>3 4<br>1<br>4 5</p><ul><li>样例输出：</li></ul><p>8</p><ul><li>参考代码:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=110;</span><br><span class="line"></span><br><span class="line">int n,m;</span><br><span class="line">int f[N],v[N],w[N];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(int i=0;i&lt;n;i++) &#123;</span><br><span class="line">        int s;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        for(int j=0;j&lt;s;j++) cin&gt;&gt;v[j]&lt;&lt;w[j];</span><br><span class="line">        for(int j=m;j&gt;=0;j--)</span><br><span class="line">            for(int k=0;k&lt;s;k++)</span><br><span class="line">                if(j&gt;=v[k])</span><br><span class="line">                    f[j]=max(f[j],f[j-v[k]]+w[k]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[m]&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="背包问题求方案数"><a href="#背包问题求方案数" class="headerlink" title="背包问题求方案数"></a>背包问题求方案数</h4><ul><li>描述：</li></ul><p>有$N$件物品和一个容量是$V$的背包，每件物品只能使用一次。</p><p>第$i$件物品的体积是$v_i$，价值是$w_i$。</p><p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。</p><p>输出<strong>最优选法的方案数</strong>，注意答案可能很大，请输出答案模$10^9+7$的结果。</p><!-- more --><ul><li>输入：</li></ul><p>第一行两个整数$N$和$V$，$0 &lt; N,V \le 1000$，用空格隔开，分别表示物品数量和背包容积。</p><p>接下来有$N$行，每行两个整数$v_i$和$w_i$，$0 &lt; v_i,w_i \le 1000$，用空格隔开，分别表示第$i$件物品的体积和价值。</p><ul><li>输出：</li></ul><p>输出一个整数，表示方案数模$10^9+7$的结果。</p><ul><li>样例输入：</li></ul><p>4 5<br>1 2<br>2 4<br>3 4<br>4 6</p><ul><li>样例输出：</li></ul><p>2</p><ul><li>参考代码:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=1010,mod=1000000009,INF=1000000;</span><br><span class="line">int n,m;</span><br><span class="line">int f[N],g[N];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    g[0]=1;</span><br><span class="line">    for(int i=1;i&lt;=m;i++) f[i]=-INF;</span><br><span class="line">    for(int i=0;i&lt;n;i++) &#123;</span><br><span class="line">        int v,w;</span><br><span class="line">        cin&gt;&gt;v&gt;&gt;w;</span><br><span class="line">        for(int j=m;j&gt;=v;j--) &#123;</span><br><span class="line">            int t=max(f[j],f[j-v]+w);</span><br><span class="line">            int s=0;</span><br><span class="line">            if(t==f[j])s+=g[j];</span><br><span class="line">            if(t==f[j-v]+w)s+=g[j-v];</span><br><span class="line">            if(s&gt;=mod)s-=mod;</span><br><span class="line">            f[j]=t;</span><br><span class="line">            g[j]=s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int maxw=0;</span><br><span class="line">    for(int i=0;i&lt;=m;i++) maxw=max(maxw,f[i]);</span><br><span class="line">    int res=0;</span><br><span class="line">    for(int i=0;i&lt;=m;i++)</span><br><span class="line">        if(maxw==f[i]) &#123;</span><br><span class="line">            res+=g[i];</span><br><span class="line">            if(res&gt;=mod) res-=mod;</span><br><span class="line">        &#125;</span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="求背包问题的方案"><a href="#求背包问题的方案" class="headerlink" title="求背包问题的方案"></a>求背包问题的方案</h4><ul><li>描述：</li></ul><p>有$N$件物品和一个容量是$V$的背包，每件物品只能使用一次。</p><p>第$i$件物品的体积是$v_i$，价值是$w_i$。</p><p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。</p><p>输出<strong>字典序最小的方案</strong>。这里的字典序是指：所选物品的编号所构成的序列。物品的编号范围是$1…N$。</p><!-- more --><ul><li>输入：</li></ul><p>第一行两个整数$N$和$V$，$0 &lt; N,V \le 1000$，用空格隔开，分别表示物品数量和背包容积。</p><p>接下来有$N$行，每行两个整数$v_i$和$w_i$，$0 &lt; v_i,w_i \le 1000$，用空格隔开，分别表示第$i$件物品的体积和价值。</p><ul><li>输出：</li></ul><p>输出一行，包含若干个用空格隔开的整数，表示最优解中所选物品的编号序列，且该编号序列的字典序最小。</p><p>物品编号范围是$1…N$。</p><ul><li>样例输入：</li></ul><p>4 5<br>1 2<br>2 4<br>3 4<br>4 6</p><ul><li>样例输出：</li></ul><p>1 4</p><ul><li>参考代码:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=1010;</span><br><span class="line"></span><br><span class="line">int n,m;</span><br><span class="line">int v[N],w[N],f[N][N];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(int i=1;i&lt;=n;i++) cin&gt;&gt;v[i]&gt;&gt;w[i];</span><br><span class="line">    for(int i=n;i&gt;=1;i--) &#123;</span><br><span class="line">        for(int j=0;j&lt;=m;j++) &#123;</span><br><span class="line">            f[i][j]=f[i+1][j];</span><br><span class="line">            if(j&gt;=v[i]) f[i][j]=max(f[i][j],f[i+1][j-v[i]]+w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int vol=m;</span><br><span class="line">    for(int i=1;i&lt;=n;i++) &#123;</span><br><span class="line">        if(f[i][vol]==f[i+1][vol-v[i]]+w[i]) &#123;</span><br><span class="line">            cout&lt;&lt;i&lt;&lt;&apos; &apos;;</span><br><span class="line">            vol-=v[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="有依赖的背包问题"><a href="#有依赖的背包问题" class="headerlink" title="有依赖的背包问题"></a>有依赖的背包问题</h4><h5 id="非树形依赖的背包问题"><a href="#非树形依赖的背包问题" class="headerlink" title="非树形依赖的背包问题"></a>非树形依赖的背包问题</h5><ul><li>描述：</li></ul><p>金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间金明自己专用的很宽敞的房间。更让他高兴的是，妈妈昨天对他说：“你的房间需要购买哪些物品，怎么布置，你说了算，只要不超过$N$元钱就行”。今天一早，金明就开始做预算了，他把想买的物品分为两类：主件与附件，附件是从属于某个主件的，下表就是一些主件与附件的例子：</p><p>|主件| 附件|</p><p>|电脑| 打印机，扫描仪|</p><p>|书柜| 图书|</p><p>|书桌| 台灯，文具|</p><p>|工作椅| 无|</p><p>如果要买归类为附件的物品，必须先买该附件所属的主件。每个主件可以有0个、1个或2个附件。附件不再有从属于自己的附件。金明想买的东西很多，肯定会超过妈妈限定的$N$元。于是，他把每件物品规定了一个重要度，分为5等：用整数1−5表示，第5等最重要。他还从因特网上查到了每件物品的价格（都是10元的整数倍）。他希望在不超过$N$元（可以等于$N$元）的前提下，使每件物品的价格与重要度的乘积的总和最大。</p><p>设第$j$件物品的价格为$v_[j]$，重要度为$w_[j]$，共选中了$k$件物品，编号依次为$j_1,j_2,…,j_k$，则所求的总和为：<br>$$v_[j_1] \times w_[j_1]+v_[j_2] \times w_[j_2]+ …+v_[j_k] \times w_[j_k]$$</p><p>请你帮助金明设计一个满足要求的购物单。</p><ul><li>输入：</li></ul><p>第1行为两个正整数$n$和$m$，分别表示总钱数和希望购买物品的个数，$n&lt;32000$，$m&lt;60$，用空格隔开。</p><p>从第2行到第$m+1$行，第$j$行给出了编号为$j-1$的物品的基本数据，每行有3个非负整数$v$、$p$、$q$，分别表示该物品的价格、重要度（1-5）、是主件还是附件，$q=0$表示该物品为主件，$q&gt;0$表示该物品为附件且$q$是所属主件的编号，$v&lt;10000$。</p><ul><li>输出：</li></ul><p>一个正整数，为不超过总钱数的物品的价格与重要度乘积的总和的最大值。</p><ul><li>样例输入：</li></ul><p>1000 5<br>800 2 0<br>400 5 1<br>300 5 1<br>400 3 0<br>500 2 0</p><ul><li>样例输出：</li></ul><p>2200</p><ul><li><p>解题思路：分组背包</p></li><li><p>参考代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h5 id="树形依赖的背包问题"><a href="#树形依赖的背包问题" class="headerlink" title="树形依赖的背包问题"></a>树形依赖的背包问题</h5><ul><li>描述：</li></ul><p>有$N$个物品和一个容量是$V$的背包。</p><p>物品之间具有依赖关系，且依赖关系组成一棵树的形状。如果选择一个物品，则必须选择它的父节点。</p><!-- more --><p>如下图所示：</p><p><img src="/2019/10/21/knapsack/2019-10-21_122422.jpg" alt=""></p><p>如果选择物品5，则必须选择物品1和2。这是因为2是5的父节点，1是2的父节点。</p><p>每件物品的编号是$i$，体积是$v_i$，价值是$w_i$，依赖的父节点编号是$p_i$，物品的下标范围是$1…N$。</p><p>求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。</p><p>输出最大价值。</p><ul><li>输入：</li></ul><p>第一行两个整数$N$和$V$，$1 \le N,V \le 100$，用空格隔开，分别表示物品个数和背包容量。</p><p>接下来有$N$行数据，每行数据表示一个物品。<br>第$i$行有三个整数$v_i$,$w_i$,$p_i$，$1 &lt; v_i,w_i \le 100$，用空格隔开，分别表示物品的体积、价值和依赖的物品编号。<br>$p_i==-1$表示根节点，$1 \le p_i \le N$表示内部节点，数据保证所有物品构成一棵树。</p><ul><li>输出：</li></ul><p>输出一个整数，表示最大价值。</p><ul><li>样例输入：</li></ul><p>5 7<br>2 3 -1<br>2 2 1<br>3 5 1<br>4 7 2<br>3 6 2</p><ul><li>样例输出：</li></ul><p>11</p><ul><li><p>解题思路：分组背包+树形dp</p></li><li><p>参考代码:</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=110;</span><br><span class="line">int n,m;</span><br><span class="line">int h[N],e[N],ne[N],idx;</span><br><span class="line">int v[N],w[N],f[N][N];</span><br><span class="line">void add(int a,int b) &#123;</span><br><span class="line">    e[idx]=b,ne[idx]=h[a],h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line">void dfs(int u) &#123;</span><br><span class="line">    for(int i=h[u];i!=-1;i=ne[i]) &#123;</span><br><span class="line">        int son=e[i];</span><br><span class="line">        dfs(son);</span><br><span class="line">        for(int j=m-v[u];j&gt;=0;j--)</span><br><span class="line">            for(int k=0;k&lt;=j;k++)</span><br><span class="line">                f[u][j]=max(f[u][j],f[u][j-k]+f[son][k]);</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=m;i&gt;=v[u];i--) f[u][i]=f[u][i-v[u]]+w[u];</span><br><span class="line">    for(int i=0;i&lt;v[u];i++) f[u][i]=0;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    memset(h,-1,sizeof h);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    int root;</span><br><span class="line">    for(int i=1;i&lt;=n;i++) &#123;</span><br><span class="line">        int p;</span><br><span class="line">        cin&gt;&gt;v[i]&gt;&gt;w[i]&gt;&gt;p;</span><br><span class="line">        if(p==-1) root=i;</span><br><span class="line">        else add(p,i);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root);</span><br><span class="line">    cout&lt;&lt;f[root][m]&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;0-1背包问题&quot;&gt;&lt;a href=&quot;#0-1背包问题&quot; class=&quot;headerlink&quot; title=&quot;0/1背包问题&quot;&gt;&lt;/a&gt;0/1背包问题&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;描述：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有$N$件物品和一个容量是$V$的背包。&lt;/p&gt;
&lt;p&gt;第$i$件物品的体积是$v_i$，价值是$w_i$。&lt;/p&gt;
&lt;p&gt;求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。&lt;br&gt;输出最大价值。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://e99net.github.io/categories/Algorithm/"/>
    
    
      <category term="Knapsack" scheme="https://e99net.github.io/tags/Knapsack/"/>
    
  </entry>
  
  <entry>
    <title>记一道算法编程题</title>
    <link href="https://e99net.github.io/2019/10/21/meituan2019/"/>
    <id>https://e99net.github.io/2019/10/21/meituan2019/</id>
    <published>2019-10-21T03:33:49.258Z</published>
    <updated>2019-10-21T03:50:09.279Z</updated>
    
    <content type="html"><![CDATA[<h4 id="爱健身的小王"><a href="#爱健身的小王" class="headerlink" title="爱健身的小王"></a>爱健身的小王</h4><ul><li>描述：</li></ul><p>小王是一个喜欢健身的人，他每天都会围着一个n*n的场地外侧跑步。<br>他是一个有强迫症的人，每跑n+1个单位长度，他就要在地上做一个标记。<br>当他在一个点重复标记的时候，他就会结束当天的锻炼。<br>显然当n一定时，他每天打标记的数量也是一定的。请你计算出来他每天要打多少标记（最后一次重复标记也要计数）。</p><a id="more"></a><ul><li>输入：</li></ul><p>第一行包含一个正整数t，表示询问的数量。</p><p>第二行包含t个整数，中间用空格隔开，每个整数表示一个询问所给出的n，$1 \le n \le 1000$。</p><ul><li>输出：</li></ul><p>输出共t行，$1 \le t \le 10000$。</p><p>每行包含一个正整数，其中第i行的整数表示第i个询问的答案。</p><ul><li>样例输入：</li></ul><p>2<br>4 8</p><ul><li>样例输出：</li></ul><p>17<br>33</p><ul><li>样例解释：</li></ul><p>对于4*4的场地而言，其边界上的16个点都会被标记，因为起点会被标记两次，所以共17次。</p><ul><li><p>解题思路：最小公倍数</p></li><li><p>参考代码:</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int gcd(int a,int b)&#123;</span><br><span class="line">    return b?gcd(b,a%b):a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int T;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    while(T--) &#123;</span><br><span class="line">        int n;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        int d=gcd(4*n,n+1);</span><br><span class="line">        cout&lt;&lt;4*n/d+1&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;爱健身的小王&quot;&gt;&lt;a href=&quot;#爱健身的小王&quot; class=&quot;headerlink&quot; title=&quot;爱健身的小王&quot;&gt;&lt;/a&gt;爱健身的小王&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;描述：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;小王是一个喜欢健身的人，他每天都会围着一个n*n的场地外侧跑步。&lt;br&gt;他是一个有强迫症的人，每跑n+1个单位长度，他就要在地上做一个标记。&lt;br&gt;当他在一个点重复标记的时候，他就会结束当天的锻炼。&lt;br&gt;显然当n一定时，他每天打标记的数量也是一定的。请你计算出来他每天要打多少标记（最后一次重复标记也要计数）。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://e99net.github.io/categories/Algorithm/"/>
    
    
      <category term="Number theory" scheme="https://e99net.github.io/tags/Number-theory/"/>
    
  </entry>
  
  <entry>
    <title>记五道2020年某企业提前批招聘笔试题</title>
    <link href="https://e99net.github.io/2019/10/07/netease/"/>
    <id>https://e99net.github.io/2019/10/07/netease/</id>
    <published>2019-10-07T02:44:38.279Z</published>
    <updated>2019-10-08T03:10:29.522Z</updated>
    
    <content type="html"><![CDATA[<h4 id="窗口点击模拟"><a href="#窗口点击模拟" class="headerlink" title="窗口点击模拟"></a>窗口点击模拟</h4><ul><li>描述：</li></ul><p>本题需要让你模拟一下在Windows系统里窗囗和鼠标点击的操作，具体如下：</p><ol><li>屏幕分辨率为3840 * 2160，左上角坐标为（0，0），右下角坐标为（3839，2159）</li><li>窗口是一个矩形的形状，由左上角坐标（X，Y），和宽高（W，H），四个数字来定位。左上角坐标为（X，Y）、右下角坐标为（X+W，Y+H），其中左上角坐标一定会在屏幕范围内，其他一些部分可能会超过屏幕范围。</li><li>窗囗的点击和遮挡规则同Windows，但是不考虑关闭窗囗、最大化、最小化和强制置顶的情况。即<br> 3.1 如果发生重叠的话，后面打开的窗口会显示在前面打开的窗口上面<br> 3.2 当鼠标发生一次点击的时候，需要判断点击到了哪个窗口，如果同个坐标有多个窗口，算点击到最上层的那个<br> 3.3 当一个窗囗被点击的时候，会浮动到最上层</li></ol><a id="more"></a><ul><li>输入：</li></ul><p>每个测试输入包含1个测试用例<br>第一行为2个整数N，M。其中N表示打开的窗口数目，M表示鼠标点击的数目，0&lt;N，M&lt;1000<br>接下来N行，每一行四个整数Xi Yi Wi Hi，分别表示第i个窗口（窗口Id为i，从1开始计数）的左上角坐标以及宽高，初始时窗口是按输入的顺序依次打开。其中0&lt;=Xi&lt;3840，0&lt;=Yi&lt;2160，0&lt;Wi&lt;3840，0&lt;Hi&lt;2160<br>再接下来有M行，每一行两个整数xj Yj，分别表示接下来发生的鼠标点击坐标。其中0&lt;=Xj&lt;3840，0&lt;=Yj&lt;2160</p><ul><li>输出：</li></ul><p>对于每次鼠标点击，输出本次点击到的窗口Id。如果没有点击到窗口，输出-1</p><ul><li>样例输入：</li></ul><p>2 4<br>100 100 100 100<br>10 10 150 150<br>105 105<br>180 180<br>105 105<br>1 1</p><ul><li>样例输出：</li></ul><p>2<br>1<br>1<br>-1</p><ul><li>样例说明：</li></ul><p>有2个窗口，第1个窗口左上角坐标为(100,100)，宽和高都是100，则其右下角坐标为(200,200)；<br>第2个窗口左上角坐标为(10,10)，宽和高都是150，则其右下角坐标为(160,160)。</p><p>有4次鼠标点击，第1次点击的位置同时属于1号和2号窗口，但由于2号窗口在上面，所以它被选择并且被置于顶层；<br>第2次点击的位置只属于1号窗口，因此该次点击选择了1号窗口并将其置于顶层，现在1号窗口在上，2号窗口在下；<br>第3次点击的位置同时属于1号和2号窗口的范围，但由于1号窗口在上，所以它被选择；<br>第4次点击的位置不属于任何窗口。</p><ul><li>解题思路：模拟</li></ul><p>用一个结构体数组存给出的窗口信息，根据题意，数组中越靠后的窗口优先级越高，因此，每次点击从数字后面开始扫描，扫到满足点击的窗口就输出对应的编号，并将它提到末尾。</p><ul><li>参考代码:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=1010;</span><br><span class="line">const int M=1010;</span><br><span class="line">int n,m;</span><br><span class="line"></span><br><span class="line">struct win &#123;</span><br><span class="line">    int id,x,y,w,h;</span><br><span class="line">&#125;wins[N];//存窗口的结构体数组</span><br><span class="line"></span><br><span class="line">//将窗口i置于顶层</span><br><span class="line">void top(int i) &#123;</span><br><span class="line">    win t=wins[i];</span><br><span class="line">    for(;i&lt;n-1;i++) wins[i]=wins[i+1];</span><br><span class="line">    wins[n-1]=t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">    for(int i=0;i&lt;n;i++) &#123;</span><br><span class="line">        scanf(&quot;%d%d%d%d&quot;,&amp;wins[i].x,&amp;wins[i].y,&amp;wins[i].w,&amp;wins[i].h);</span><br><span class="line">        wins[i].id=i+1;</span><br><span class="line">    &#125;</span><br><span class="line">    while(m--) &#123;</span><br><span class="line">        int dx,dy,flag=0;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;dx,&amp;dy);</span><br><span class="line">        for(int i=n-1;i&gt;=0;i--) &#123;</span><br><span class="line">            //判断鼠标点击范围</span><br><span class="line">            if(dx&gt;=wins[i].x&amp;&amp;dy&gt;=wins[i].y&amp;&amp;dx&lt;=wins[i].x+wins[i].w&amp;&amp;dy&lt;=wins[i].y+wins[i].h) &#123;</span><br><span class="line">                printf(&quot;%d\n&quot;,wins[i].id);</span><br><span class="line">                top(i);</span><br><span class="line">                flag=1;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(!flag) printf(&quot;-1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Stern-Brocot-tree"><a href="#Stern-Brocot-tree" class="headerlink" title="Stern-Brocot tree"></a>Stern-Brocot tree</h4><ul><li>描述：</li></ul><p>The Stern-Brocot tree is an infinite complete binary tree in which the vertices correspond one-for-one to the positive rational numbers, whose values are ordered from the left to the right as in a search tree.</p><p><img src="/2019/10/07/netease/001.jpg" alt=""></p><p>Figure 1 shows a part of the Stern-Brocot tree, which has thefirst 4 rows. Each node in the tree is marked in a red cycle. The value in the node is the mediant of the left and right fractions. The mediant of two fractions A/B and C/D is defined as(A+C)/(B+D).<br>To construct the Stern-Brocot tree, we first define the left fraction of the root node is 0/1, and the right fraction of the root node is 1/0. So the value in the root node is the mediant of 0/1 and 1/0, which is(0+1)/(1+0)=1/1. Then the value of root node becomes the right fraction of the left child, and the left fraction of the right child. For example, the 1st node in row2 has 0/1 as its left fraction and 1/1(which is the value of its parent node) as its right fraction. So the value of the 1st node in row2 is (0+1)/(1+1)=1/2. For the same reason, the value of the 2nd node in row2 is (1+1)/(1+0)=2/1. This construction progress goes on infinitly. As a result, everypositive rational number can be found on the Stern-Brocot tree, and can be found only once.<br>Given a rational number in form of P/Q, find the position of P/Q in the Stern-Brocot Tree.</p><ul><li>输入：</li></ul><p>Input consists of two integers,P and Q<br>(1&lt;=P,Q&lt;=1000), which represent the rational number P/Q. We promise P and Q are relatively prime.</p><ul><li>输出：</li></ul><p>Output consists of two integers,R and C.<br>R indicates the row index of P/Q in the stern-Brocot Tree,C indicates the index of P/Q in the row.<br>Both B and C are base 1.<br>We promise the position of P/Q is always in the first 12 rows of the Stern-Brocot tree, which means R&lt;=12.</p><ul><li>样例输入：</li></ul><p>5 3</p><ul><li>样例输出：</li></ul><p>4 6</p><ul><li><p>解题思路：数学+二分</p></li><li><p>参考程序：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct Fraction &#123;</span><br><span class="line">    int m,n;</span><br><span class="line">&#125;sl,sr,input;</span><br><span class="line">int row,col;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int summ,sumn;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;input.m,&amp;input.n);</span><br><span class="line">    if(input.m!=1||input.n!=1) &#123;</span><br><span class="line">       //string ans;</span><br><span class="line">       sl.m=0,sr.m=1;</span><br><span class="line">       sl.n=1,sr.n=0;</span><br><span class="line">       row=1;</span><br><span class="line">       col=1;</span><br><span class="line">       while(1)&#123;</span><br><span class="line">            summ=sl.m+sr.m;</span><br><span class="line">            sumn=sl.n+sr.n;</span><br><span class="line">            int temp=input.m*sumn-input.n*summ;</span><br><span class="line">            if(temp&gt;0)&#123; // input.m/input.n&gt;summ/sumn --&gt; input.m*sumn-input.n*summ&gt;0</span><br><span class="line">                // ans+=&apos;R&apos;;</span><br><span class="line">                row++;</span><br><span class="line">                col*=2;</span><br><span class="line">                sl.m=summ;</span><br><span class="line">                sl.n=sumn;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(temp==0) // input.m/input.n==summ/sumn --&gt; input.m*sumn-input.n*summ==0</span><br><span class="line">                break;</span><br><span class="line">            else&#123; // input.m/input.n&lt;summ/sumn --&gt; input.m*sumn-input.n*summ&lt;0</span><br><span class="line">                // ans+=&apos;L&apos;;</span><br><span class="line">                row++;</span><br><span class="line">                col=2*col-1;</span><br><span class="line">                sr.m=summ;</span><br><span class="line">                sr.n=sumn;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d %d\n&quot;,row,col);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="双人数字游戏"><a href="#双人数字游戏" class="headerlink" title="双人数字游戏"></a>双人数字游戏</h4><ul><li>描述：</li></ul><p>游戏规则如下</p><ul><li><p>在棋盘上有N个数字（A1 ~ AN）从左到右排列成一行</p></li><li><p>A，B两个玩家轮流进行游戏，第一回合A玩家行动，第二回合B玩家行动，依次行动直到游戏结束</p></li><li><p>每回合玩家可以选择拿走棋盘上最左边或者最右边的一个数字，其余的都不能拿</p></li><li><p>拿走的数字依次从左到右排列在自己面前</p></li><li><p>棋盘上所有数字被拿走后游戏结束</p></li><li><p>最优策略的说明：在任意局面下，玩家如果取左边的数字或者取右边的数字，最终最优得分都一样，那么只能取左边的数字</p></li></ul><p>当所有数字都被拿走后，A，B两个玩家面前都各有一个数列。</p><p>假设A玩家面前数字从左到右为X1，X2，X3…XM，则他的最终得分Sa计算方式如下（B玩家的得分计算Sb也类似，不赘述）：<br>Sa=abs(X1-0)+abs(X2-X1)+abs(X3-X2)+..+abs(XM-X(M-1))</p><p>请计算在以上的规则下，如果两个玩家都想拿到尽量多的分数，用最优策略进行游戏，计算两个人的最终得分。</p><ul><li>输入：</li></ul><p>第一行一个数字N，一半的测试用例（0&lt;N&lt;=50），一半的测试用例（0&lt;N&lt;=1000）</p><p>第二行N个数字Ai（0&lt;=Ai&lt;=50）</p><ul><li>输出：</li></ul><p>用空格隔开的两个整数Sa和Sb</p><ul><li>样例输入：</li></ul><p>4<br>1 2 3 4</p><ul><li>样例输出：</li></ul><p>7 4</p><ul><li><p>解题思路：模拟</p></li><li><p>参考程序：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int n, a, k = 1;</span><br><span class="line">deque&lt;int&gt; dq;</span><br><span class="line">int pa = 0, sa = 0, pb = 0, sb = 0;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;a);</span><br><span class="line">        dq.push_back(a);</span><br><span class="line">    &#125;</span><br><span class="line">    while (dq.size()) &#123;</span><br><span class="line">        int left = dq.front();</span><br><span class="line">        int right = dq.back();</span><br><span class="line">        if (k % 2) &#123;</span><br><span class="line">            if (abs(left - pa) &gt;= abs(right - pa)) &#123;</span><br><span class="line">                dq.pop_front();</span><br><span class="line">                sa += abs(left - pa);</span><br><span class="line">                pa = left;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                dq.pop_back();</span><br><span class="line">                sa += abs(right - pa);</span><br><span class="line">                pa = right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            if (abs(left - pb) &gt;= abs(right - pb)) &#123;</span><br><span class="line">                dq.pop_front();</span><br><span class="line">                sb += abs(left - pb);</span><br><span class="line">                pb = left;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                dq.pop_back();</span><br><span class="line">                sb += abs(right - pb);</span><br><span class="line">                pb = right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d %d\n&quot;, sa, sb);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="聊天消息排版"><a href="#聊天消息排版" class="headerlink" title="聊天消息排版"></a>聊天消息排版</h4><ul><li>描述</li></ul><p>在网游中，聊天功能是一项非常重要的功能，加上玩家可以打出游戏内置的一些表情图片，因此需要实现一个图文混排系统，如下图所示。<br>玩家在聊天框输入的是一段utf-8编码的文字，且只会包含中文、英文、中英文的标点符号和空格（不会出现换行、回车和制表符）。按照网易游戏的传统，井号（#）是作为一个转义字符，支持下面几种转义行为：</p><ol><li>#加一个数字来表示内置的表情图片，为了简化问题，我们这里只支持20个表情图片，从0开始计数，并且数字是按最长匹配原则去匹配，比如#0表示0号表情图片、#1表示1号表情图片、#19表示19号表情图片、#20则表示2号表情图片后面加数字0。需要注意的是#00表示的是0号表情图片加后面数字0。</li><li>#r表示换行，遇到以后会自动切换到下一行开始排版。</li><li>##表示显示出#这个符号</li><li>如果玩家不按规则输入错误的转义，则按照玩家的输入原样显示，比如#a、#、#、#啊</li></ol><p><img src="/2019/10/07/netease/002.jpg" alt=""></p><p>上图所示的玩家输入为：“Hello world#大家好#r欢迎大家参加#1祝大家取得好成绩”</p><p>排版的时候需要像上图一样，将文字从起始位置开始，依次显示在聊天窗囗里，一些显示规则如下所示：</p><ol><li><p>聊天窗囗的宽度固定为W像素，起始坐标为左上角，坐标为（0，0），右上角坐标为（W-1，0），坐标向右向下增长。任何文字和表情必须显示在窗口内，不能超出窗口。但是高度可以无限向下延伸。</p></li><li><p>显示的字体均为等宽字体，英文（包括英文标点符号和空格）的字体宽度统一为XE，高度统一为YE。中文（包括中文的标点符号）的字体宽度统一为XC，高度统一为YC。</p></li><li><p>每个表情图片的宽高是独立的，0号表情图片的宽度为X0，高度Y0，依次类推，19号表情图片的宽度为×19，高度为Y19。</p></li><li><p>字符（中英文以及标点符号、空格等，下同）与字符之间、字符与表情之间、表情与表情之间都需要额外保留一个PX像素的字间距。每一行第一个字符左边，以及最后一个字符右边不需要保留字间距。</p></li><li><p>当下一个字符或者表情无法在本行W宽度的像素内完整显示的话，则会强行换到下一行首开始显示。遇到#r的时候也会自动换到下一行开始显示下一个字符或表情。</p></li><li><p>在一行里出现高度不同的中英文以及表情的时候，需要将其底部对齐。</p></li><li><p>当一行里没有任何字符或表情，直接被#r换行的时候，这一行的高度算英文字体的高度。</p></li><li><p>每一行里高度最高的字符或表情，需要同上一行的的底部保留PY像素的行间距。第一行上面与最后一行下面不需要保留行间距。</p></li><li><p>最后一个字符或表情显示显示以后，它的右下角坐标则为结束坐标。也就是本题需要求解的问题。输入保证最后不会以#r结尾。</p></li></ol><ul><li>输入：</li></ul><p>每个测试输入包含1个测试用例<br>第一行为7个正整数w，XE，YE，XC，YC，BX，PY<br>第二行为40个正整数x0，Y0，X1，Y1…X19，Y19<br>第三行为长度不超过10000的十六进制编码过的玩家输入，即玩家输入的utf-8编码的数据每个字节的数字转成大写的十六进制表示，不足两位的话前面补0（同c里printf的%x格式化），然后不同字节的十六进制编码表示依次拼接起来。<br>比如Hello的十六进制编码表示为48656C6C6F。<br>前两行的各个数字含义如上文描述，其中50&lt; w &lt;10000，0&lt;其他&lt;50。</p><ul><li>输出：</li></ul><p>输出用空格隔开的两个数字，表示结束坐标</p><ul><li>输入样例：</li></ul><p>60 2 4 3 4 1 3<br>7 6 7 6 7 6 7 6 7 6 7 6 7 6 7 6 7 6 7 6 7 6 7 6 7 6 7 6 7 6 7 6 7 6 7 6 7 6 7 6<br>48656C6C6F20776F726C6423E5A4A7E5AEB6E5A5B<br>D2372E6ACA2E8BF8EE5A4A7E5AEB6E58F82E58AA0<br>E7BD91E69893E99BB7E781ABE6A0A1E59BADE68B9<br>BE881982331E7A59DE5A4A7E5AEB6E58F96E5BE97<br>E5A5BDE68890E7BBA9</p><ul><li>输出样例：</li></ul><p>38 19</p><ul><li><p>解题思路：模拟</p></li><li><p>参考程序：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="黑客行动"><a href="#黑客行动" class="headerlink" title="黑客行动"></a>黑客行动</h4><ul><li>描述：</li></ul><p>钱老板家的电子保险柜被一个神秘的安保函数y=f(x)保护，每次试图开锁时，系统都会调用安保函数代码输入一个(0,1)之间的浮点数x，如果安保函数能输出正确的y数值则可以打开保险柜，否则就会报警。黑客小军想办法获取到了一份这个安保函数的测试程序，但这个程序并不能在钱老板家的系统上直接运行，必须要重新编码一份新的代码才能使用，请帮助小军实现这个安保函数代码！<br>你可以在以下的URL下载这份测试程序的可执行文件，压缩包里包含windows、linux和macos三个平台下的可执行程序：<br><a href="http://guess.zip" target="_blank" rel="noopener">http://guess.zip</a></p><ul><li>输入：</li></ul><p>一个(0,1)的浮点数，精确到小数点后6位</p><ul><li>输出：</li></ul><p>一个浮点数，精确到小数点后6位</p><ul><li>输入样例：</li></ul><p>0.268044</p><ul><li>输出样例：</li></ul><p>2.681916</p><ul><li>备注：</li></ul><p>本题的判题标准，如果你的代码输出的结果四舍五入到小数点后5位与标准答案四舍五入到小数点后5位一致就算正确</p><ul><li><p>解题思路：</p></li><li><p>参考程序：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;窗口点击模拟&quot;&gt;&lt;a href=&quot;#窗口点击模拟&quot; class=&quot;headerlink&quot; title=&quot;窗口点击模拟&quot;&gt;&lt;/a&gt;窗口点击模拟&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;描述：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本题需要让你模拟一下在Windows系统里窗囗和鼠标点击的操作，具体如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;屏幕分辨率为3840 * 2160，左上角坐标为（0，0），右下角坐标为（3839，2159）&lt;/li&gt;
&lt;li&gt;窗口是一个矩形的形状，由左上角坐标（X，Y），和宽高（W，H），四个数字来定位。左上角坐标为（X，Y）、右下角坐标为（X+W，Y+H），其中左上角坐标一定会在屏幕范围内，其他一些部分可能会超过屏幕范围。&lt;/li&gt;
&lt;li&gt;窗囗的点击和遮挡规则同Windows，但是不考虑关闭窗囗、最大化、最小化和强制置顶的情况。即&lt;br&gt; 3.1 如果发生重叠的话，后面打开的窗口会显示在前面打开的窗口上面&lt;br&gt; 3.2 当鼠标发生一次点击的时候，需要判断点击到了哪个窗口，如果同个坐标有多个窗口，算点击到最上层的那个&lt;br&gt; 3.3 当一个窗囗被点击的时候，会浮动到最上层&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://e99net.github.io/categories/Algorithm/"/>
    
    
      <category term="Dynamic Programming" scheme="https://e99net.github.io/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>洛谷的刷题日常之P1967</title>
    <link href="https://e99net.github.io/2019/10/06/luogu_P1967/"/>
    <id>https://e99net.github.io/2019/10/06/luogu_P1967/</id>
    <published>2019-10-06T11:02:59.655Z</published>
    <updated>2019-10-06T11:54:02.534Z</updated>
    
    <content type="html"><![CDATA[<h4 id="货车运输"><a href="#货车运输" class="headerlink" title="货车运输"></a>货车运输</h4><p>这是一道比较综合的题，非常的niubility（我不会做的题都niubility，QWQ），用到的知识包括图论、倍增、贪心、LCA、生成树、并查集。</p><ul><li>描述：</li></ul><p>A国有n座城市，编号从1到n，城市之间有m条双向道路。每一条道路对车辆都有重量限制，简称限重。现在有q辆货车在运输货物， 司机们想知道每辆车在不超过车辆限重的情况下，最多能运多重的货物。</p><a id="more"></a><ul><li>输入：</li></ul><p>第一行有两个用空格隔开的整数n和m，表示A国有n座城市和m条道路。<br>接下来的m行，每行有3个整数x,y,z，每两个整数之间用一个空格隔开，表示从x号城市到y号城市有一条限重为z的道路。<br>注意：x不等于 y，两座城市之间可能有多条道路。</p><p>接下来一行有一个整数q，表示有q辆货车需要运货。</p><p>接下来的q行，每行有两个整数x、y，用一个空格隔开，表示一辆货车需要从x城市运输货物到y城市。<br>注意：x不等于y。</p><ul><li>输出：</li></ul><p>共有q行，每行一个整数，表示对于每一辆货车，它的最大载重是多少。如果货车不能到达目的地，输出-1。</p><ul><li>输入样例：</li></ul><p>4 3<br>1 2 4<br>2 3 3<br>3 1 1<br>3<br>1 3<br>1 4<br>1 3</p><ul><li>输出样例：</li></ul><p>3<br>-1<br>3</p><ul><li><p>解题思路：</p><ul><li>贪心：因为要使得货车运的货物尽可能重，所以权值较小的边不会被走过。</li><li>图论：根据给出的数据建原始图，然后根据上一步的贪心策略建新图，构造最大生成树。</li><li>生成树：构造最大生成树可以使用Kruskal算法。</li><li>并查集：Kruskal算法可以用并查集维护节点的连通情况。</li><li>LCA：在最大生成树上求最近公共祖先，得到两个节点之间最小边权的最大值，即题中的最大载重。</li><li>倍增：树上倍增法求LCA。</li></ul></li><li><p>参考代码：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define INF 0x3f3f3f3f</span><br><span class="line"></span><br><span class="line">struct road &#123;</span><br><span class="line">    int x,y,z;</span><br><span class="line">&#125;roads[50010];//原始图</span><br><span class="line"></span><br><span class="line">struct edge &#123;</span><br><span class="line">    int to,next,w;</span><br><span class="line">&#125;edges[50010];//存储最大生成树的新图</span><br><span class="line"></span><br><span class="line">//fa数组表示并查集中的父节点，f数组表示树上的父节点，w数组表示最大载重 </span><br><span class="line">int x,y,cnt,head[10010],fa[10010],f[10010][21],deep[10010],w[10010][21],n,m,q;</span><br><span class="line">bool vis[10010];</span><br><span class="line"></span><br><span class="line">//自定义排序规则，边权大的在前面</span><br><span class="line">bool cmp(road x,road y) &#123;</span><br><span class="line">    return x.z&gt;y.z;</span><br><span class="line">&#125;</span><br><span class="line">//前向星存新图</span><br><span class="line">void addroad(int start,int end,int w) &#123;</span><br><span class="line">    edges[++cnt].next=head[start];</span><br><span class="line">    edges[cnt].to=end;</span><br><span class="line">    edges[cnt].w=w;</span><br><span class="line">    head[start]=cnt;</span><br><span class="line">&#125;</span><br><span class="line">//并查集的查找操作</span><br><span class="line">int Find(int x) &#123;</span><br><span class="line">    if(x!=fa[x]) fa[x]=Find(fa[x]);</span><br><span class="line">    return fa[x];</span><br><span class="line">&#125;</span><br><span class="line">//Kruskal算法</span><br><span class="line">void kruskal() &#123;</span><br><span class="line">    sort(roads+1,roads+m+1,cmp);</span><br><span class="line">    for(int i=1;i&lt;=n;i++) fa[i]=i;//并查集的初始化操作</span><br><span class="line">    for(int i=1;i&lt;=m;i++) &#123;</span><br><span class="line">        //并查集的合并操作</span><br><span class="line">        int a=Find(roads[i].x);</span><br><span class="line">        int b=Find(roads[i].y);</span><br><span class="line">        if(a!=b) &#123;</span><br><span class="line">            fa[a]=b;</span><br><span class="line">            //无向图，双向边</span><br><span class="line">            addroad(roads[i].x,roads[i].y,roads[i].z);</span><br><span class="line">            addroad(roads[i].y,roads[i].x,roads[i].z);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//预处理：从根节点进行搜索，求节点深度</span><br><span class="line">void dfs(int node) &#123;</span><br><span class="line">    vis[node]=true;</span><br><span class="line">    for(int i=head[node];i;i=edges[i].next) &#123;//前向星遍历</span><br><span class="line">        int to=edges[i].to;</span><br><span class="line">        if(vis[to]) continue;</span><br><span class="line">        deep[to]=deep[node]+1;//计算深度</span><br><span class="line">        f[to][0]=node;//存父节点</span><br><span class="line">        w[to][0]=edges[i].w;//存节点到父节点的权值</span><br><span class="line">        dfs(to);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//树上倍增法优化求解LCA问题</span><br><span class="line">int lca(int x,int y) &#123;</span><br><span class="line">    int a=Find(x);</span><br><span class="line">    int b=Find(y);</span><br><span class="line">    if(a!=b) return -1;//不连通输出-1</span><br><span class="line">    int ans=INF;</span><br><span class="line">    if(deep[x]&gt;deep[y]) swap(x,y);//始终使得y节点更深</span><br><span class="line">    //将y节点提到与x节点相同的深度</span><br><span class="line">    for(int i=20;i&gt;=0;i--) &#123;</span><br><span class="line">        if(deep[f[y][i]]&gt;=deep[x]) &#123;</span><br><span class="line">            ans=min(ans,w[y][i]);//更新最大载重（最小边权）</span><br><span class="line">            y=f[y][i];//修改y的位置</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(x==y) return ans;//如果位置已经相等，直接返回答案</span><br><span class="line">    //寻找公共祖先</span><br><span class="line">    for(int i=20;i&gt;=0;i--) &#123;</span><br><span class="line">        if(f[x][i]!=f[y][i]) &#123;</span><br><span class="line">            ans=min(ans,min(w[x][i],w[y][i]));//更新最大载重（最小边权）</span><br><span class="line">            x=f[x][i];//修改x的位置</span><br><span class="line">            y=f[y][i];//修改y的位置</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans=min(ans,min(w[x][0],w[y][0]));//更新x,y到公共祖先的最大载重，fa[x][0]、fa[y][0]即为公共祖先 </span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">    for(int i=1;i&lt;=m;i++) &#123;//存原始图</span><br><span class="line">        scanf(&quot;%d%d%d&quot;,&amp;roads[i].x,&amp;roads[i].y,&amp;roads[i].z);</span><br><span class="line">    &#125;</span><br><span class="line">    kruskal();</span><br><span class="line">    for(int i=1;i&lt;=n;i++) &#123;//预处理</span><br><span class="line">        if(!vis[i]) &#123;</span><br><span class="line">            deep[i]=1;</span><br><span class="line">            dfs(i);</span><br><span class="line">            f[i][0]=i;</span><br><span class="line">            w[i][0]=INF;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //LCA初始化</span><br><span class="line">    for(int i=1;i&lt;=20;i++) &#123;</span><br><span class="line">        for(int j=1;j&lt;=n;j++) &#123;</span><br><span class="line">            f[j][i]=f[f[j][i-1]][i-1];</span><br><span class="line">            w[j][i]=min(w[j][i-1],w[f[j][i-1]][i-1]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;q);</span><br><span class="line">    for(int i=1;i&lt;=q;i++) &#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;x,&amp;y);</span><br><span class="line">        printf(&quot;%d\n&quot;,lca(x,y));//O(logn)复杂度回答询问</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;货车运输&quot;&gt;&lt;a href=&quot;#货车运输&quot; class=&quot;headerlink&quot; title=&quot;货车运输&quot;&gt;&lt;/a&gt;货车运输&lt;/h4&gt;&lt;p&gt;这是一道比较综合的题，非常的niubility（我不会做的题都niubility，QWQ），用到的知识包括图论、倍增、贪心、LCA、生成树、并查集。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;描述：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A国有n座城市，编号从1到n，城市之间有m条双向道路。每一条道路对车辆都有重量限制，简称限重。现在有q辆货车在运输货物， 司机们想知道每辆车在不超过车辆限重的情况下，最多能运多重的货物。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://e99net.github.io/categories/Algorithm/"/>
    
    
      <category term="Graph theory" scheme="https://e99net.github.io/tags/Graph-theory/"/>
    
      <category term="LCA" scheme="https://e99net.github.io/tags/LCA/"/>
    
      <category term="Greedy" scheme="https://e99net.github.io/tags/Greedy/"/>
    
      <category term="Union-Find Set" scheme="https://e99net.github.io/tags/Union-Find-Set/"/>
    
      <category term="Spanning tree" scheme="https://e99net.github.io/tags/Spanning-tree/"/>
    
      <category term="Doubling" scheme="https://e99net.github.io/tags/Doubling/"/>
    
  </entry>
  
  <entry>
    <title>洛谷的刷题日常之P1147</title>
    <link href="https://e99net.github.io/2019/10/05/luogu_P1147/"/>
    <id>https://e99net.github.io/2019/10/05/luogu_P1147/</id>
    <published>2019-10-04T16:15:38.897Z</published>
    <updated>2019-10-04T16:23:29.233Z</updated>
    
    <content type="html"><![CDATA[<h4 id="连续自然数和"><a href="#连续自然数和" class="headerlink" title="连续自然数和"></a>连续自然数和</h4><ul><li>描述：</li></ul><p>对一个给定的自然数$M$，求出所有的连续的自然数段，这些连续的自然数段中的全部数之和为$M$。<br>例子：1998+1999+2000+2001+2002 = 10000，所以从1998到2002的一个自然数段为$M=10000$的一个解。</p><a id="more"></a><ul><li>输入：</li></ul><p>包含一个整数的单独一行给出M的值（$10 \le M \le 2000000$）。</p><ul><li>输出：</li></ul><p>每行两个自然数，给出一个满足条件的连续自然数段中的第一个数和最后一个数，两数之间用一个空格隔开，所有输出行的第一个按从小到大的升序排列，对于给定的输入数据，保证至少有一个解。</p><ul><li>输入样例：</li></ul><p>10000</p><ul><li>输出样例：</li></ul><p>18 142<br>297 328<br>388 412<br>1998 2002</p><ul><li><p>解题思路：前缀和+二分</p></li><li><p>参考代码:</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define ll long long</span><br><span class="line">ll sum[2000010];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    ll m;</span><br><span class="line">    scanf(&quot;%lld&quot;,&amp;m);</span><br><span class="line">    for(int i=1;i&lt;=m;i++)  sum[i]=sum[i-1]+i;</span><br><span class="line">    for(int i=1;i&lt;=m-1;i++) &#123;</span><br><span class="line">        ll l=i,r=m-1,mid;</span><br><span class="line">        while(l&lt;=r) &#123;</span><br><span class="line">            mid=(l+r)/2;</span><br><span class="line">            ll t=sum[mid]-sum[i-1];</span><br><span class="line">            if(t==m) &#123;</span><br><span class="line">                printf(&quot;%d %d\n&quot;,i,mid);</span><br><span class="line">                break;</span><br><span class="line">            &#125;else if(t&lt;m) &#123;</span><br><span class="line">                l=mid+1;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                r=mid-1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;连续自然数和&quot;&gt;&lt;a href=&quot;#连续自然数和&quot; class=&quot;headerlink&quot; title=&quot;连续自然数和&quot;&gt;&lt;/a&gt;连续自然数和&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;描述：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对一个给定的自然数$M$，求出所有的连续的自然数段，这些连续的自然数段中的全部数之和为$M$。&lt;br&gt;例子：1998+1999+2000+2001+2002 = 10000，所以从1998到2002的一个自然数段为$M=10000$的一个解。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://e99net.github.io/categories/Algorithm/"/>
    
    
      <category term="Prefix Sum" scheme="https://e99net.github.io/tags/Prefix-Sum/"/>
    
      <category term="Binary Search" scheme="https://e99net.github.io/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>记两道2020年某企业秋招的算法编程题</title>
    <link href="https://e99net.github.io/2019/09/26/tourSohu/"/>
    <id>https://e99net.github.io/2019/09/26/tourSohu/</id>
    <published>2019-09-26T12:07:20.889Z</published>
    <updated>2019-10-13T05:46:43.123Z</updated>
    
    <content type="html"><![CDATA[<h4 id="专业题1"><a href="#专业题1" class="headerlink" title="专业题1"></a>专业题1</h4><ul><li>描述：</li></ul><p>一个k（1&lt;=k&lt;=80）位的十进制整数n，我们称其为大整数。现在的问题是，请你设计一个程序，对于给出的某个大整数，找到满足条件p^3+p^2+3 * p&lt;=n的p的最大值。</p><a id="more"></a><ul><li>输入：</li></ul><p>一个大整数n。</p><ul><li>输出：</li></ul><p>一个符合条件的答案值。</p><ul><li>样例输入1：</li></ul><p>1908</p><ul><li>样例输出1：</li></ul><p>12</p><ul><li>样例输入2：</li></ul><p>8620110</p><ul><li>样例输出2：</li></ul><p>204</p><ul><li><p>解题思路：高精度+二分</p></li><li><p>参考代码:</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#偷懒的Python代码</span><br><span class="line">def f(x):</span><br><span class="line">    return x*x*x+x*x+3*x</span><br><span class="line">num=int(input())</span><br><span class="line">left=0;</span><br><span class="line">right=num;</span><br><span class="line">mid=0;</span><br><span class="line">mark=0</span><br><span class="line">while left&lt;right:</span><br><span class="line">    mid=int((left+right)/2)</span><br><span class="line">    #print(&quot;midzhi &quot;,mid)</span><br><span class="line">    fx=f(mid)</span><br><span class="line">    if fx==num:</span><br><span class="line">        ans=mid</span><br><span class="line">        mark=1</span><br><span class="line">        break</span><br><span class="line">    elif fx&gt;num:</span><br><span class="line">        right=mid </span><br><span class="line">    else:</span><br><span class="line">        left=mid+1</span><br><span class="line">if mark==0:</span><br><span class="line">    ans=left-1</span><br><span class="line">print(ans)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int MAXN = 2000;</span><br><span class="line"></span><br><span class="line">struct bign &#123;</span><br><span class="line">    int len, s[MAXN];</span><br><span class="line">    bign () &#123;</span><br><span class="line">        memset(s, 0, sizeof(s));</span><br><span class="line">        len = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    bign (int num) &#123; </span><br><span class="line">        *this = num; </span><br><span class="line">    &#125;</span><br><span class="line">    bign (const char *num) &#123; </span><br><span class="line">        *this = num;</span><br><span class="line">    &#125;</span><br><span class="line">    int operator [] (int a) &#123;</span><br><span class="line">        return s[a];</span><br><span class="line">    &#125;</span><br><span class="line">    bign operator = (const int num) &#123;</span><br><span class="line">        char s[MAXN];</span><br><span class="line">        sprintf(s, &quot;%d&quot;, num);</span><br><span class="line">        *this = s;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">    bign operator = (const char *num) &#123;</span><br><span class="line">        for(int i = 0; num[i] == &apos;0&apos;; num++) ;</span><br><span class="line">        len = strlen(num);</span><br><span class="line">        for(int i = 0; i &lt; len; i++) s[i] = num[len-i-1] - &apos;0&apos;;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">    bign operator + (const bign &amp;b) const &#123;</span><br><span class="line">        bign c;</span><br><span class="line">        c.len = 0;</span><br><span class="line">        for(int i = 0, g = 0; g || i &lt; max(len, b.len); i++) &#123;</span><br><span class="line">            int x = g;</span><br><span class="line">            if(i &lt; len) x += s[i];</span><br><span class="line">            if(i &lt; b.len) x += b.s[i];</span><br><span class="line">            c.s[c.len++] = x % 10;</span><br><span class="line">            g = x / 10;</span><br><span class="line">        &#125;</span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line">    bign operator += (const bign &amp;b) &#123;</span><br><span class="line">        *this = *this + b;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">    void clean() &#123;</span><br><span class="line">        while(len &gt; 1 &amp;&amp; !s[len-1]) len--;</span><br><span class="line">    &#125;</span><br><span class="line">    bign operator * (const bign &amp;b)</span><br><span class="line">    &#123;</span><br><span class="line">        bign c;</span><br><span class="line">        c.len = len + b.len;</span><br><span class="line">        for(int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">            for(int j = 0; j &lt; b.len; j++) &#123;</span><br><span class="line">                c.s[i+j] += s[i] * b.s[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; c.len; i++) &#123;</span><br><span class="line">            c.s[i+1] += c.s[i]/10;</span><br><span class="line">            c.s[i] %= 10;</span><br><span class="line">        &#125;</span><br><span class="line">        c.clean();</span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line">    bign operator *= (const bign &amp;b) &#123;</span><br><span class="line">        *this = *this * b;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">    bign operator - (const bign &amp;b) &#123;</span><br><span class="line">        bign c;</span><br><span class="line">        c.len = 0;</span><br><span class="line">        for(int i = 0, g = 0; i &lt; len; i++) &#123;</span><br><span class="line">            int x = s[i] - g;</span><br><span class="line">            if(i &lt; b.len) x -= b.s[i];</span><br><span class="line">            if(x &gt;= 0) g = 0;</span><br><span class="line">            else &#123;</span><br><span class="line">                g = 1;</span><br><span class="line">                x += 10;</span><br><span class="line">            &#125;</span><br><span class="line">            c.s[c.len++] = x;</span><br><span class="line">        &#125;</span><br><span class="line">        c.clean();</span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line">    bign operator -= (const bign &amp;b) &#123;</span><br><span class="line">        *this = *this - b;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">    bign operator / (const bign &amp;b) &#123;</span><br><span class="line">        bign c, f = 0;</span><br><span class="line">        for(int i = len-1; i &gt;= 0; i--) &#123;</span><br><span class="line">            f = f*10;</span><br><span class="line">            f.s[0] = s[i];</span><br><span class="line">            while(f &gt;= b) &#123;</span><br><span class="line">                f -= b;</span><br><span class="line">                c.s[i]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        c.len = len;</span><br><span class="line">        c.clean();</span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line">    bign operator /= (const bign &amp;b) &#123;</span><br><span class="line">        *this = *this / b;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">    bign operator % (const bign &amp;b) &#123;</span><br><span class="line">        bign r = *this / b;</span><br><span class="line">        r = *this - r*b;</span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br><span class="line">    bign operator %= (const bign &amp;b) &#123;</span><br><span class="line">        *this = *this % b;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">    bign operator ++() &#123;</span><br><span class="line">        return *this+=1;</span><br><span class="line">    &#125;</span><br><span class="line">    bign operator --() &#123;</span><br><span class="line">        return *this-=1;</span><br><span class="line">    &#125;</span><br><span class="line">    bool operator &lt; (const bign &amp;b) &#123;</span><br><span class="line">        if(len != b.len) return len &lt; b.len;</span><br><span class="line">        for(int i = len-1; i &gt;= 0; i--) &#123;</span><br><span class="line">            if(s[i] != b.s[i]) return s[i] &lt; b.s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    bool operator &gt; (const bign &amp;b) &#123;</span><br><span class="line">        if(len != b.len) return len &gt; b.len;</span><br><span class="line">        for(int i = len-1; i &gt;= 0; i--) &#123;</span><br><span class="line">            if(s[i] != b.s[i]) return s[i] &gt; b.s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    bool operator == (const bign &amp;b) &#123;</span><br><span class="line">        return !(*this &gt; b) &amp;&amp; !(*this &lt; b);</span><br><span class="line">    &#125;</span><br><span class="line">    bool operator != (const bign &amp;b) &#123;</span><br><span class="line">        return !(*this == b);</span><br><span class="line">    &#125;</span><br><span class="line">    bool operator &lt;= (const bign &amp;b) &#123;</span><br><span class="line">        return *this &lt; b || *this == b;</span><br><span class="line">    &#125;</span><br><span class="line">    bool operator &gt;= (const bign &amp;b) &#123;</span><br><span class="line">        return *this &gt; b || *this == b;</span><br><span class="line">    &#125;</span><br><span class="line">    bign operator !() &#123;</span><br><span class="line">        bign s=1;</span><br><span class="line">        for(bign i=1;i&lt;=*this;++i)</span><br><span class="line">            s*=i; return s;</span><br><span class="line">    &#125;</span><br><span class="line">    bign operator ^ (const bign&amp; b) &#123;</span><br><span class="line">        bign s=1;</span><br><span class="line">        for(bign i=0;i&lt;b;++i)</span><br><span class="line">            s*=*this;return s;</span><br><span class="line">    &#125;</span><br><span class="line">    bign sqrt() &#123;</span><br><span class="line">        bign c=*this/2;</span><br><span class="line">        while((c*c)&gt;*this) c/=2;</span><br><span class="line">        while((c*c)&lt;=*this) ++c;</span><br><span class="line">        return c-1;</span><br><span class="line">    &#125;</span><br><span class="line">    /*string operator *()&#123;</span><br><span class="line">        string op=&quot;Hello World&quot;;</span><br><span class="line">        return op;</span><br><span class="line">    &#125;*/</span><br><span class="line">    string str() const &#123;</span><br><span class="line">        string res = &quot;&quot;;</span><br><span class="line">        for(int i = 0; i &lt; len; i++) res = char(s[i]+&apos;0&apos;) + res;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">istream&amp; operator &gt;&gt; (istream &amp;in, bign &amp;x) &#123;</span><br><span class="line">    string s;</span><br><span class="line">    in &gt;&gt; s;</span><br><span class="line">    x = s.c_str();</span><br><span class="line">    return in;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream&amp; operator &lt;&lt; (ostream &amp;out, const bign &amp;x) &#123;</span><br><span class="line">    out &lt;&lt; x.str();</span><br><span class="line">    return out;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    // bign a,b;</span><br><span class="line">    // cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    // cout&lt;&lt;a+b;</span><br><span class="line">    bign left=0,n,mid,value,ans;</span><br><span class="line">    int mark=0;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    bign right=n;</span><br><span class="line">    while(left&lt;right) &#123;</span><br><span class="line">        mid=(left+right)/2;</span><br><span class="line">        value=mid*mid*mid+mid*mid+(bign)3*mid;</span><br><span class="line">        if(value==n) &#123;</span><br><span class="line">            ans=mid;mark=1;break;</span><br><span class="line">        &#125;else if(value&gt;n) &#123;</span><br><span class="line">            right=mid;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            left=mid+1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(mark==0) ans=left-1;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="专业题2"><a href="#专业题2" class="headerlink" title="专业题2"></a>专业题2</h4><ul><li>描述：</li></ul><p>在一个棋盘上有N个处于不同位置的棋子，每个棋子所在的位置都可以用坐标(X,Y)来表示，并且任一棋子每次可以向上、下、左、右移动单位长度。如果想让所有棋子进入一个水平线，彼此靠近，即它们最后的位置是(X,Y)、(X+1,Y)、……、(X+N,Y)，水平线上棋子的最后顺序是任意的，那么最少需要移动多少次棋子？<br>注意：两个或两个以上的棋子不能在同一时间处于同一位置。</p><ul><li>输入：</li></ul><p>第一行是一个整数N，表示棋子数，1&lt;=N&lt;=10000。后面的N行分别是每个棋子的初始位置，包含空格分开的整数x、y，-10000&lt;=x,y&lt;=10000。</p><ul><li>输出：</li></ul><p>仅有一行一个值，表示使棋子移到水平线彼此相邻位置的最小移动次数。</p><ul><li>样例输入：</li></ul><p>5<br>1 2<br>2 2<br>1 3<br>3 -2<br>3 3</p><ul><li>样例输出：</li></ul><p>8</p><ul><li><p>解题思路：中位数、贪心</p><ul><li>先将棋子移动到同一水平线，这一水平线的位置应该是它们纵坐标的中位数，可通过排序后得到中位数b，这样就能使得移动的总步数$\sum_{i=1}^{n}abs(y_i-b)$最少。</li><li>然后要让棋子彼此靠近，先对横坐标从小到大排序，假设起点是a，那么要求$\sum_{i=1}^{n}abs(a+i-x_i)$，即$\sum_{i=1}^{n}abs(a-(x_i-i))$，也即$\sum_{i=1}^{n}abs((x_i-i)-a)$。当a是$x_i-i$序列的中位数时，可使移动步数最少，同样地，这个中位数可以通过排序后得到。</li><li>将上述两步的结果相加，得到的就是最后结果了。</li></ul></li><li><p>参考代码:</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int a[10010],b[10010],n,i,x,y,ans;</span><br><span class="line">int main() &#123;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(i=1;i&lt;=n;i++) scanf(&quot;%d%d&quot;,&amp;a[i],&amp;b[i]);</span><br><span class="line">    sort(b+1,b+n+1);</span><br><span class="line">    y=b[n+1&gt;&gt;1];</span><br><span class="line">    sort(a+1,a+n+1);</span><br><span class="line">    for(i=1;i&lt;=n;i++) a[i]-=i;</span><br><span class="line">    sort(a+1,a+n+1);</span><br><span class="line">    x=a[n+1&gt;&gt;1]; </span><br><span class="line">    for(i=1;i&lt;=n;i++) ans+=abs(a[i]-x)+abs(b[i]-y);</span><br><span class="line">    printf(&quot;%d\n&quot;,ans); </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;专业题1&quot;&gt;&lt;a href=&quot;#专业题1&quot; class=&quot;headerlink&quot; title=&quot;专业题1&quot;&gt;&lt;/a&gt;专业题1&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;描述：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一个k（1&amp;lt;=k&amp;lt;=80）位的十进制整数n，我们称其为大整数。现在的问题是，请你设计一个程序，对于给出的某个大整数，找到满足条件p^3+p^2+3 * p&amp;lt;=n的p的最大值。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://e99net.github.io/categories/Algorithm/"/>
    
    
      <category term="Number theory" scheme="https://e99net.github.io/tags/Number-theory/"/>
    
      <category term="Greedy" scheme="https://e99net.github.io/tags/Greedy/"/>
    
  </entry>
  
  <entry>
    <title>洛谷的刷题日常之P1880</title>
    <link href="https://e99net.github.io/2019/09/24/luogu_P1880/"/>
    <id>https://e99net.github.io/2019/09/24/luogu_P1880/</id>
    <published>2019-09-24T03:16:45.340Z</published>
    <updated>2019-10-06T12:12:45.330Z</updated>
    
    <content type="html"><![CDATA[<h4 id="石子合并"><a href="#石子合并" class="headerlink" title="石子合并"></a>石子合并</h4><p>先看一道比luogu p1880简单的题目。</p><ul><li>描述：</li></ul><p>有n堆石子排成一排，每堆石子有一定的数量，将n堆石子合并成一堆。合并的规则是每次只能合并相邻的两堆石子，合并的花费为这两堆石子的总数。石子经过n-1次合并后成为一堆，求总的最小花费和最大花费。</p><a id="more"></a><ul><li>输入：</li></ul><p>有多组测试数据，输入到文件结束。每组测试数据的第1行有一个整数n，表示有n堆石子，n&lt;250。接下来的一行有n个数，分别表示这n堆石子的数目。每堆石子至少一颗，最多10000颗。</p><ul><li>输出：</li></ul><p>总的最小花费和最大花费。</p><ul><li>输入样例：</li></ul><p>3<br>2 4 5</p><ul><li>输出样例：</li></ul><p>17<br>20</p><ul><li><p>解题思路：区间DP</p></li><li><p>参考代码:</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int INF=1&lt;&lt;30;</span><br><span class="line">const int N=300;</span><br><span class="line">int n,sum[N];</span><br><span class="line"></span><br><span class="line">int Minval()&#123;</span><br><span class="line">    int dp[N][N]；</span><br><span class="line">    for(int i=1;i&lt;=n;i++) dp[i][i]=0;</span><br><span class="line">    for(int len=1;len&lt;n;len++)</span><br><span class="line">        for(int i=1;i&lt;=n-len;i++) &#123;</span><br><span class="line">            int j=i+len;</span><br><span class="line">            dp[i][j]=INF;</span><br><span class="line">            for(int k=i;k&lt;j;k++)</span><br><span class="line">                dp[i][j]=min(dp[i][j],dp[i][k]+dp[k+1][j]+sum[j]-sum[i-1]);</span><br><span class="line">        &#125;</span><br><span class="line">    return dp[1][n];</span><br><span class="line">&#125;</span><br><span class="line">int Maxval()&#123;</span><br><span class="line">    int dp[N][N];</span><br><span class="line">    for(int i=1;i&lt;=n;i++) dp[i][i]=0;</span><br><span class="line">    for(int len=1;len&lt;n;len++)</span><br><span class="line">        for(int i=1;i&lt;=n-len;i++) &#123;</span><br><span class="line">            int j=i+len;</span><br><span class="line">            dp[i][j]=-INF;</span><br><span class="line">            for(int k=i;k&lt;j;k++)</span><br><span class="line">                dp[i][j]=max(dp[i][j],dp[i][k]+dp[k+1][j]+sum[j]-sum[i-1]);</span><br><span class="line">        &#125;</span><br><span class="line">    return dp[1][n];</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    sum[0]=0;</span><br><span class="line">    for(int i=1;i&lt;=n;i++) &#123;</span><br><span class="line">        int x;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">        sum[i]=sum[i-1]+x;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n%d&quot;,Minval(),Maxval());</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="环形石子合并"><a href="#环形石子合并" class="headerlink" title="环形石子合并"></a>环形石子合并</h4><p>接下来就可以着手解决luogu p1880了。如果按照上面的解法解这道题，会出现“min值永远比正确答案大1”的“奇怪”现象，这是因为没有考虑环形的缘故。</p><ul><li>描述：</li></ul><p>在一个圆形操场的四周摆放N堆石子,现要将石子有次序地合并成一堆.规定每次只能选相邻的2堆合并成新的一堆，并将新的一堆的石子数，记为该次合并的得分。</p><p>试设计出1个算法,计算出将N堆石子合并成1堆的最小得分和最大得分.</p><!-- more --><ul><li>输入：</li></ul><p>数据的第1行试正整数N,1≤N≤100,表示有N堆石子.第2行有N个数,分别表示每堆石子的个数.</p><ul><li>输出：</li></ul><p>输出共2行,第1行为最小得分,第2行为最大得分.</p><ul><li>输入样例：</li></ul><p>4<br>4 5 9 4</p><ul><li>输出样例：</li></ul><p>43<br>54</p><ul><li><p>解题思路：</p><ul><li>区间DP</li><li>处理环形情况的通用套路：在任意位置把环断开成链，复制一倍接在末尾</li></ul></li><li><p>参考代码:</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int INF=1&lt;&lt;30;</span><br><span class="line">const int N=240;</span><br><span class="line">int n,sum[N],x,arr[N];</span><br><span class="line"></span><br><span class="line">int Minval()&#123;</span><br><span class="line">    int dp[N][N],ans=INF;</span><br><span class="line">    for(int i=1;i&lt;=n;i++) dp[i][i]=0;</span><br><span class="line">    for(int len=1;len&lt;n;len++)</span><br><span class="line">        for(int i=1;i&lt;=2*n-len;i++) &#123;</span><br><span class="line">            int j=i+len;</span><br><span class="line">            dp[i][j]=INF;</span><br><span class="line">            for(int k=i;k&lt;j;k++)</span><br><span class="line">                dp[i][j]=min(dp[i][j],dp[i][k]+dp[k+1][j]+sum[j]-sum[i-1]);</span><br><span class="line">        &#125;</span><br><span class="line">    for(int i=1;i&lt;=n;i++) &#123;</span><br><span class="line">        ans=ans&gt;dp[i][i+n-1]?dp[i][i+n-1]:ans;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int Maxval()&#123;</span><br><span class="line">    int dp[N][N],ans=-INF;</span><br><span class="line">    for(int i=1;i&lt;=n;i++) dp[i][i]=0;</span><br><span class="line">    for(int len=1;len&lt;n;len++)</span><br><span class="line">        for(int i=1;i&lt;=2*n-len;i++) &#123;</span><br><span class="line">            int j=i+len;</span><br><span class="line">            dp[i][j]=-INF;</span><br><span class="line">            for(int k=i;k&lt;j;k++)</span><br><span class="line">                dp[i][j]=max(dp[i][j],dp[i][k]+dp[k+1][j]+sum[j]-sum[i-1]);</span><br><span class="line">        &#125;</span><br><span class="line">    for(int i=1;i&lt;=n;i++) &#123;</span><br><span class="line">        ans=ans&lt;dp[i][i+n-1]?dp[i][i+n-1]:ans;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    sum[0]=0;</span><br><span class="line">    for(int i=1;i&lt;=n;i++) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;arr[i]);</span><br><span class="line">        arr[i+n]=arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=2*n;i++) &#123;</span><br><span class="line">        sum[i]=sum[i-1]+arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n%d&quot;,Minval(),Maxval());</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>相似题目：</li></ul><p>hdu 3506 “Monkey Party”</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;石子合并&quot;&gt;&lt;a href=&quot;#石子合并&quot; class=&quot;headerlink&quot; title=&quot;石子合并&quot;&gt;&lt;/a&gt;石子合并&lt;/h4&gt;&lt;p&gt;先看一道比luogu p1880简单的题目。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;描述：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有n堆石子排成一排，每堆石子有一定的数量，将n堆石子合并成一堆。合并的规则是每次只能合并相邻的两堆石子，合并的花费为这两堆石子的总数。石子经过n-1次合并后成为一堆，求总的最小花费和最大花费。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://e99net.github.io/categories/Algorithm/"/>
    
    
      <category term="Dynamic Programming" scheme="https://e99net.github.io/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>记三道2020年某企业秋招笔试题</title>
    <link href="https://e99net.github.io/2019/09/24/cmbcc/"/>
    <id>https://e99net.github.io/2019/09/24/cmbcc/</id>
    <published>2019-09-24T02:30:06.499Z</published>
    <updated>2019-10-12T02:12:55.595Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-n-中每位数字乘积最大的值"><a href="#1-n-中每位数字乘积最大的值" class="headerlink" title="1 ~ n 中每位数字乘积最大的值"></a>1 ~ n 中每位数字乘积最大的值</h4><ul><li>描述：</li></ul><p>99°是一位爱好爬山的小青年，他每次在爬山过程中都会遇到很多小猴子，小猴子们喜欢向他提这样一种问题：在1 ~ n中找一个数字m，使得m的各个数位乘积最大。99°不擅长回答这种问题，你能帮他写一个程序得到结果吗？</p><a id="more"></a><ul><li>样例输入1：</li></ul><p>100</p><ul><li>样例输出1：</li></ul><p>81</p><p>提示：9 * 9 = 81</p><ul><li>样例输入2：</li></ul><p>6</p><ul><li>样例输出2：</li></ul><p>6</p><ul><li><p>解题思路：贪心</p><ul><li>尽量把每一位变成9，每次都向前借一位来减</li><li>n比10小就返回n，n为0就返回1</li></ul></li><li><p>参考代码:</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define ll long long</span><br><span class="line"></span><br><span class="line">ll solve(int n) &#123;</span><br><span class="line">    if(n==0) return 1;</span><br><span class="line">    if(n&lt;10) return n;</span><br><span class="line">    else return max(solve(n/10-1)*9,solve(n/10)*(n%10));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    printf(&quot;%lld&quot;,solve(n));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="完成可能有前置任务的任务"><a href="#完成可能有前置任务的任务" class="headerlink" title="完成可能有前置任务的任务"></a>完成可能有前置任务的任务</h4><ul><li>描述：</li></ul><p>99°要完成n个任务，它制定了一个计划，计划第i天完成第i个任务，每个任务可能有前置任务，在完成第i个任务时，必须先完成它的前置任务才行。问99°要想实现它的计划，每天至少要完成多少个任务？</p><ul><li>输入：</li></ul><p>一个整数n，表示要完成的任务数，2&lt;=n&lt;=10000。接下来n行，每行第一个数字k表示该任务的前置任务数，剩下的k个数字分别表示前置任务编号。</p><ul><li>输出：</li></ul><p>n个数字，每个数字以一个空格间隔，表示每天至少完成的任务数。</p><ul><li>样例输入：</li></ul><p>3<br>1 2<br>0<br>2 1 2</p><ul><li>样例输出：</li></ul><p>2 0 1</p><p>说明：任务1有1个前置任务2，第1天要想完成任务1，需先完成任务2，所以第1天至少完成2个任务。第2天计划完成任务2，因为任务2已在第一天完成，且任务2无前置任务，所以第2天至少完成0个任务。第3天计划完成任务3，任务3有两个前置任务1、2，在前两天都已完成，所以这一天只需完成任务3，至少完成1个任务即可。</p><ul><li>样例输入：</li></ul><p>5<br>4 2 3 4 5<br>1 1<br>2 1 2<br>0<br>1 3</p><ul><li>样例输出：</li></ul><p>5 0 0 0 0</p><p>说明：第1个任务有4个前置任务2、3、4、5，要想完成1，需先完成2、3、4、5，那么第1天至少完成5个任务。接下来的第2、3、4、5天每天完成0个任务，因为在第1天已完成全部5个任务。</p><ul><li><p>解题思路：开哈希数组</p></li><li><p>参考程序：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=10005;</span><br><span class="line">int n,res[N],v[N];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int k,x;</span><br><span class="line">    memset(res,0,sizeof res);</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(int i=1;i&lt;=n;i++) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;k);</span><br><span class="line">        while(k--) &#123;</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">            if(!v[x]) &#123;</span><br><span class="line">                v[x]=1;</span><br><span class="line">                res[i]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(!v[i]) &#123;</span><br><span class="line">            res[i]++;</span><br><span class="line">            v[i]=1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=n;i++) &#123;</span><br><span class="line">        printf(&quot;%d &quot;,res[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="将数组元素变为非递减"><a href="#将数组元素变为非递减" class="headerlink" title="将数组元素变为非递减"></a>将数组元素变为非递减</h4><ul><li>描述</li></ul><p>99°给出一个包含$n$个整数的数组$a_i$，99°每次可以选择数组中若干个下标不同的元素，对选中的每个元素执行下列改变：假设选中的元素为$x$，那么就将$x$替换为$(x+1) mod m$，即选中的每个元素自增1，如果变为$m$则归零。<br>请问最少执行多少次操作，99°可以把这个数组变为一个数组元素非递减的数组。</p><ul><li>输入：</li></ul><p>第一行两个整数$n$和$m$，用一个空格分隔；<br>第二行$n$个整数$a_1$,$a_2$,…,$a_n$表示数组，每两个整数之间用一个空格分隔。<br>输入满足$1&lt;=n,m&lt;=300000;0 &lt;= a_i &lt; m$ 。</p><ul><li>输出：</li></ul><p>一个整数，表示最少需要的操作次数。</p><ul><li>输入样例1：</li></ul><p>6 8<br>7 5 6 3 2 1</p><ul><li>输出样例1：</li></ul><p>3</p><ul><li>输入样例2：</li></ul><p>3 2<br>1 0 1</p><ul><li>输出样例2：</li></ul><p>1</p><ul><li>输入样例3：</li></ul><p>3 2<br>1 0 0</p><ul><li>输出样例3：</li></ul><p>1</p><ul><li><p>解题思路：线性dp</p></li><li><p>参考程序：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define INF 0x3f3f3f3f</span><br><span class="line">const int N=300005;</span><br><span class="line">int n,m,a[N],dp[N];</span><br><span class="line"></span><br><span class="line">inline int move(int i,int j) &#123;</span><br><span class="line">    int ans=j-a[i];</span><br><span class="line">    if(a[i]&gt;j) ans+=m;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int t,ans=INF;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">    for(int i=0;i&lt;m;i++)   //初始化dp数组</span><br><span class="line">        dp[i]=move(0,i);</span><br><span class="line">    for(int i=1;i&lt;n;i++) &#123;</span><br><span class="line">        t=dp[0];</span><br><span class="line">        for(int j=0;j&lt;m;j++) &#123;</span><br><span class="line">            t=min(t,dp[j]);</span><br><span class="line">            dp[j]=max(t,move(i,j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for(int i=0;i&lt;m;i++)</span><br><span class="line">        ans=min(ans,dp[i]);</span><br><span class="line">    printf(&quot;%d\n&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-n-中每位数字乘积最大的值&quot;&gt;&lt;a href=&quot;#1-n-中每位数字乘积最大的值&quot; class=&quot;headerlink&quot; title=&quot;1 ~ n 中每位数字乘积最大的值&quot;&gt;&lt;/a&gt;1 ~ n 中每位数字乘积最大的值&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;描述：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;99°是一位爱好爬山的小青年，他每次在爬山过程中都会遇到很多小猴子，小猴子们喜欢向他提这样一种问题：在1 ~ n中找一个数字m，使得m的各个数位乘积最大。99°不擅长回答这种问题，你能帮他写一个程序得到结果吗？&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://e99net.github.io/categories/Algorithm/"/>
    
    
      <category term="Dynamic Programming" scheme="https://e99net.github.io/tags/Dynamic-Programming/"/>
    
      <category term="Greedy" scheme="https://e99net.github.io/tags/Greedy/"/>
    
  </entry>
  
  <entry>
    <title>记一道2020年某企业提前批招聘的机试题</title>
    <link href="https://e99net.github.io/2019/09/21/spdb/"/>
    <id>https://e99net.github.io/2019/09/21/spdb/</id>
    <published>2019-09-21T11:20:15.013Z</published>
    <updated>2019-09-24T02:57:39.061Z</updated>
    
    <content type="html"><![CDATA[<h4 id="字符串是否由子串拼接而成"><a href="#字符串是否由子串拼接而成" class="headerlink" title="字符串是否由子串拼接而成"></a>字符串是否由子串拼接而成</h4><ul><li>描述：</li></ul><p>给出一个非空的字符串，判断这个字符串是否由它的一个子串进行多次首尾拼接构成。<br>例如，“abcabcabc”满足条件，因为它是由“abc”首尾拼接而成，而“abcab”则不满足条件。</p><a id="more"></a><ul><li>输入：</li></ul><p>abcabcabc</p><ul><li>输出：</li></ul><p>true</p><ul><li>参考代码:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    string str;</span><br><span class="line">    cin&gt;&gt;str;</span><br><span class="line">    int n=str.size();</span><br><span class="line">    int m,flag;</span><br><span class="line">    for(int i=n/2;i&gt;=1;i--) &#123;</span><br><span class="line">        flag=0;</span><br><span class="line">        if(n%i==0)&#123;</span><br><span class="line">            m=n/i;</span><br><span class="line">            for(int j=0;j&lt;i;j++)&#123;</span><br><span class="line">                for(int k=1;k&lt;m;k++) &#123;</span><br><span class="line">                    if(str[j]!=str[j+k*i]) &#123;</span><br><span class="line">                        flag=1;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if(flag) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(!flag) &#123;</span><br><span class="line">                printf(&quot;true&quot;);</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;false&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;字符串是否由子串拼接而成&quot;&gt;&lt;a href=&quot;#字符串是否由子串拼接而成&quot; class=&quot;headerlink&quot; title=&quot;字符串是否由子串拼接而成&quot;&gt;&lt;/a&gt;字符串是否由子串拼接而成&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;描述：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;给出一个非空的字符串，判断这个字符串是否由它的一个子串进行多次首尾拼接构成。&lt;br&gt;例如，“abcabcabc”满足条件，因为它是由“abc”首尾拼接而成，而“abcab”则不满足条件。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://e99net.github.io/categories/Algorithm/"/>
    
    
      <category term="String" scheme="https://e99net.github.io/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>C++的输入与输出</title>
    <link href="https://e99net.github.io/2019/08/25/InputandOutputOfCpp/"/>
    <id>https://e99net.github.io/2019/08/25/InputandOutputOfCpp/</id>
    <published>2019-08-25T07:35:30.848Z</published>
    <updated>2019-08-25T07:38:59.207Z</updated>
    
    <content type="html"><![CDATA[<p>输入时：<br>float型输入用%f。<br>double型输入用%lf。</p><a id="more"></a><p>输出时：<br>最好是都用%f输出。<br>在G++中，double类型若用%lf输出可能会错，而在C++中，double类型用%lf输出是正确的。<br>printf() 函数中不存在 %lf。</p><p>总结：<br>输入 double 用 %lf 输出用 %f。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;输入时：&lt;br&gt;float型输入用%f。&lt;br&gt;double型输入用%lf。&lt;/p&gt;
    
    </summary>
    
      <category term="memo" scheme="https://e99net.github.io/categories/memo/"/>
    
    
      <category term="C/C++" scheme="https://e99net.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>用Git进行简单有效的项目版本控制管理</title>
    <link href="https://e99net.github.io/2019/03/02/git/"/>
    <id>https://e99net.github.io/2019/03/02/git/</id>
    <published>2019-03-02T11:50:07.770Z</published>
    <updated>2019-03-02T11:59:41.342Z</updated>
    
    <content type="html"><![CDATA[<p>Git是一个非常强大的项目版本控制管理工具，在单机环境下，可以简单有效地使用Git</p><a id="more"></a><ul><li>常用的Git命令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;[提交点名称]&quot;</span><br><span class="line">git status</span><br><span class="line">git log</span><br><span class="line">git reset --hard HEAD^^</span><br><span class="line">get reset --hard [Git生成的版本号，不必写全，无歧义即可]</span><br><span class="line">git checkout -- [文件]</span><br></pre></td></tr></table></figure></li></ul><p>以上这些命令就足以较好地管理自己的项目目录了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Git是一个非常强大的项目版本控制管理工具，在单机环境下，可以简单有效地使用Git&lt;/p&gt;
    
    </summary>
    
      <category term="memo" scheme="https://e99net.github.io/categories/memo/"/>
    
    
      <category term="Git" scheme="https://e99net.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>makefile文件的不同写法</title>
    <link href="https://e99net.github.io/2019/02/23/otherKindOfMakefile/"/>
    <id>https://e99net.github.io/2019/02/23/otherKindOfMakefile/</id>
    <published>2019-02-23T03:50:46.528Z</published>
    <updated>2019-02-23T03:55:09.817Z</updated>
    
    <content type="html"><![CDATA[<ul><li>封装so库时的写法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">CC=gcc</span><br><span class="line"></span><br><span class="line">SRCS=mylib.c</span><br><span class="line"></span><br><span class="line">OBJS=$(SRCS:.c=.o)</span><br><span class="line"></span><br><span class="line">EXEC=libmylib.so</span><br><span class="line"></span><br><span class="line">start: $(OBJS)</span><br><span class="line">    $(CC) -o $(EXEC) $(OBJS) -shared</span><br><span class="line"></span><br><span class="line">.c.o:</span><br><span class="line">    $(CC) -o $@ -c $&lt; -fPIC</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">    rm -rf $(OBJS)</span><br></pre></td></tr></table></figure><a id="more"></a><ul><li>C/C++混合编程的写法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">CC=g++</span><br><span class="line"></span><br><span class="line">SRCS=main.cpp\</span><br><span class="line">    udp.cpp</span><br><span class="line"></span><br><span class="line">OBJS=$(SRCS:.cpp=.o)</span><br><span class="line"></span><br><span class="line">EXEC=myudp</span><br><span class="line"></span><br><span class="line">start: $(OBJS)</span><br><span class="line">    $(CC) -o $(EXEC) $(OBJS)</span><br><span class="line"></span><br><span class="line">.cpp.o:</span><br><span class="line">    $(CC) -o $@ -c $&lt; -DMYLINUX</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">    rm -rf $(OBJS)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;封装so库时的写法&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;CC=gcc&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SRCS=mylib.c&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;OBJS=$(SRCS:.c=.o)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;EXEC=libmylib.so&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;start: $(OBJS)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    $(CC) -o $(EXEC) $(OBJS) -shared&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.c.o:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    $(CC) -o $@ -c $&amp;lt; -fPIC&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;clean:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    rm -rf $(OBJS)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="memo" scheme="https://e99net.github.io/categories/memo/"/>
    
    
      <category term="C/C++" scheme="https://e99net.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>循序渐进写makefile</title>
    <link href="https://e99net.github.io/2019/02/23/writeMakefile/"/>
    <id>https://e99net.github.io/2019/02/23/writeMakefile/</id>
    <published>2019-02-23T03:11:15.605Z</published>
    <updated>2019-02-23T04:22:53.639Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>准备工作</p><ul><li><p>main.cpp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;a.h&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    test();</span><br><span class="line">    cout &lt;&lt; &quot;hello world&quot; &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>a.h</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#ifndef AH_H</span><br><span class="line">#define AH_H</span><br><span class="line">void test();</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></li><li><p>a.cpp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;I am test\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><a id="more"></a><ul><li>版本0</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">start:</span><br><span class="line">    g++ -o a.o -c a.cpp</span><br><span class="line">    g++ -o main.o -c main.cpp</span><br><span class="line">    g++ -o myapp a.o main.o</span><br></pre></td></tr></table></figure><ul><li>版本1</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">start:</span><br><span class="line">    g++ -o a.o -c a.cpp</span><br><span class="line">    g++ -o main.o -c main.cpp</span><br><span class="line">    g++ -o myapp a.o main.o</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">    rm -rf a.o main.o</span><br></pre></td></tr></table></figure><ul><li>版本2</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CC=g++</span><br><span class="line"></span><br><span class="line">EXEC=myapp</span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line">    $(CC) -o a.o -c a.cpp</span><br><span class="line">    $(CC) -o main.o -c main.cpp</span><br><span class="line">    $(CC) -o $(EXEC) a.o main.o</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">    rm -rf a.o main.o</span><br></pre></td></tr></table></figure><ul><li>版本3</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">CC=g++</span><br><span class="line"></span><br><span class="line">SRCS=main.cpp\</span><br><span class="line">        a.cpp</span><br><span class="line"></span><br><span class="line">OBJS=main.o\</span><br><span class="line">        a.o</span><br><span class="line"></span><br><span class="line">EXEC=myapp</span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line">    $(CC) -o $(OBJS) -c $(SRCS)</span><br><span class="line">    $(CC) -o $(EXEC) $(OBJS)</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">    rm -rf $(OBJS)</span><br></pre></td></tr></table></figure><ul><li>版本4</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">CC=g++</span><br><span class="line"></span><br><span class="line">SRCS=main.cpp\</span><br><span class="line">        a.cpp</span><br><span class="line"></span><br><span class="line">OBJS=main.o\</span><br><span class="line">        a.o</span><br><span class="line"></span><br><span class="line">EXEC=myapp</span><br><span class="line"></span><br><span class="line">start: a.o main.o</span><br><span class="line">    $(CC) -o $(EXEC) $(OBJS)</span><br><span class="line"></span><br><span class="line">a.o main.o:</span><br><span class="line">    $(CC) -o $(OBJS) -c $(SRCS)</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">    rm -rf $(OBJS)</span><br></pre></td></tr></table></figure><ul><li>最终版本</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">CC=g++</span><br><span class="line"></span><br><span class="line">SRCS=main.cpp\</span><br><span class="line">        a.cpp</span><br><span class="line"></span><br><span class="line">OBJS=$(SRCS:.cpp=.o)</span><br><span class="line"></span><br><span class="line">EXEC=myapp</span><br><span class="line"></span><br><span class="line">start: $(OBJS)</span><br><span class="line">        $(CC) -o $(EXEC) $(OBJS)</span><br><span class="line"></span><br><span class="line">.cpp.o:</span><br><span class="line">        $(CC) -o $@ -c $&lt;</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">        rm -rf $(OBJS)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;准备工作&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;main.cpp&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;quot;a.h&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;using namespace std;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int main()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    test();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cout &amp;lt;&amp;lt; &amp;quot;hello world&amp;quot; &amp;lt;&amp;lt; endl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;a.h&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#ifndef AH_H&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#define AH_H&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void test();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#endif&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;a.cpp&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void test()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    printf(&amp;quot;I am test\n&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="memo" scheme="https://e99net.github.io/categories/memo/"/>
    
    
      <category term="C/C++" scheme="https://e99net.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>Win7开机界面英文转中文</title>
    <link href="https://e99net.github.io/2019/02/10/EnToChOfBootloader/"/>
    <id>https://e99net.github.io/2019/02/10/EnToChOfBootloader/</id>
    <published>2019-02-10T03:56:23.237Z</published>
    <updated>2019-02-10T07:44:35.550Z</updated>
    
    <content type="html"><![CDATA[<p>打开cmd命令提示符并执行如下命令</p><ul><li>将操作系统启动选择菜单的显示语言修改为简体中文<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcdedit /set &#123;bootmgr&#125; locale zh-CN</span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><ul><li><p>将当前Windows操作系统F8高级启动菜单的显示语言修改为简体中文</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcdedit /set &#123;current&#125; locale zh-CN</span><br></pre></td></tr></table></figure></li><li><p>将Windows内存诊断工具的显示语言修改为简体中文</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcdedit /set &#123;memdiag&#125; locale zh-CN</span><br></pre></td></tr></table></figure></li><li><p>将休眠恢复时的显示语言修改为简体中文</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcdedit /set &#123;视机器而定的一段字符&#125; locale zh-CN</span><br></pre></td></tr></table></figure></li></ul><p>注意：视机器而定的一段字符形如526bf864-88ef-11de-9b8c-e613e975374f，这段字符可通过以下命令进行查看<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcdedit /enum all</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;打开cmd命令提示符并执行如下命令&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将操作系统启动选择菜单的显示语言修改为简体中文&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;bcdedit /set &amp;#123;bootmgr&amp;#125; locale zh-CN&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="memo" scheme="https://e99net.github.io/categories/memo/"/>
    
    
      <category term="Water" scheme="https://e99net.github.io/tags/Water/"/>
    
  </entry>
  
  <entry>
    <title>用UltraISO制作Ubuntu18.04的启动U盘</title>
    <link href="https://e99net.github.io/2019/02/02/USBofUbuntu/"/>
    <id>https://e99net.github.io/2019/02/02/USBofUbuntu/</id>
    <published>2019-02-02T14:41:58.789Z</published>
    <updated>2019-09-21T11:54:52.784Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>从Ubuntu官网下载18.04系统的iso文件，并安装UltraISO软件</p></li><li><p>确保用来制作启动盘的U盘是FAT32格式的，否则，可将U盘格式化为FAT32格式</p></li></ol><a id="more"></a><ol start="3"><li><p>点击UltraISO的红色框内按钮<br><img src="/2019/02/02/USBofUbuntu/20170916135522757.png" alt=""></p></li><li><p>找到Ubuntu ISO文件并选中，点击打开<br><img src="/2019/02/02/USBofUbuntu/20170916135636024.png" alt=""><br>打开后的界面如下图所示<br><img src="/2019/02/02/USBofUbuntu/20170916135757851.png" alt=""></p></li><li><p>点击“启动→写入硬盘映像…”<br><img src="/2019/02/02/USBofUbuntu/20170916140000287.png" alt=""></p></li><li><p>写入方式选择USB-HDD+或者USB-HDD都可以<br><img src="/2019/02/02/USBofUbuntu/20170916140040427.png" alt=""></p></li><li><p>点击“便捷启动→写入新的驱动器引导扇区→Syslinux”,选择“是”，完成后“确定”<br><img src="/2019/02/02/USBofUbuntu/20170916140325642.png" alt=""><br><img src="/2019/02/02/USBofUbuntu/20170916140507610.png" alt=""><br><img src="/2019/02/02/USBofUbuntu/20170916140541363.png" alt=""></p></li><li><p>点击“写入”，选择“是”。<br><img src="/2019/02/02/USBofUbuntu/20170916140938127.png" alt=""></p></li><li><p>写入需要等待一段时间，完成后如下图。此时，选择“返回”并退出UltraISO即可<br><img src="/2019/02/02/USBofUbuntu/20170916141128817.png" alt=""></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;p&gt;从Ubuntu官网下载18.04系统的iso文件，并安装UltraISO软件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;确保用来制作启动盘的U盘是FAT32格式的，否则，可将U盘格式化为FAT32格式&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="memo" scheme="https://e99net.github.io/categories/memo/"/>
    
    
      <category term="Water" scheme="https://e99net.github.io/tags/Water/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu上的各种软件问题解决之道</title>
    <link href="https://e99net.github.io/2019/02/02/SolofMatlabOnUbuntu/"/>
    <id>https://e99net.github.io/2019/02/02/SolofMatlabOnUbuntu/</id>
    <published>2019-02-02T14:17:20.516Z</published>
    <updated>2019-02-02T14:41:36.433Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Ubuntu上的Matlab无法以普通用户身份运行"><a href="#Ubuntu上的Matlab无法以普通用户身份运行" class="headerlink" title="Ubuntu上的Matlab无法以普通用户身份运行"></a>Ubuntu上的Matlab无法以普通用户身份运行</h2><p>给“/home/用户名/.matlab”这个文件目录递归授予超级权限<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod 777 .matlab -R</span><br></pre></td></tr></table></figure></p><h2 id="CLion无法用快捷方式启动"><a href="#CLion无法用快捷方式启动" class="headerlink" title="CLion无法用快捷方式启动"></a>CLion无法用快捷方式启动</h2><p>先在Terminal中启动CLion，然后点击菜单栏Tools下面的Create Desktop Entry即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Ubuntu上的Matlab无法以普通用户身份运行&quot;&gt;&lt;a href=&quot;#Ubuntu上的Matlab无法以普通用户身份运行&quot; class=&quot;headerlink&quot; title=&quot;Ubuntu上的Matlab无法以普通用户身份运行&quot;&gt;&lt;/a&gt;Ubuntu上的Mat
      
    
    </summary>
    
      <category term="memo" scheme="https://e99net.github.io/categories/memo/"/>
    
    
      <category term="Linux" scheme="https://e99net.github.io/tags/Linux/"/>
    
      <category term="Matlab" scheme="https://e99net.github.io/tags/Matlab/"/>
    
  </entry>
  
  <entry>
    <title>强化学习介绍</title>
    <link href="https://e99net.github.io/2018/11/12/A_intro_to_RL/"/>
    <id>https://e99net.github.io/2018/11/12/A_intro_to_RL/</id>
    <published>2018-11-12T12:10:15.619Z</published>
    <updated>2019-01-05T12:11:57.067Z</updated>
    
    <content type="html"><![CDATA[<h4 id="蒙特卡罗-VS-TD学习方法"><a href="#蒙特卡罗-VS-TD学习方法" class="headerlink" title="蒙特卡罗 VS TD学习方法"></a>蒙特卡罗 VS TD学习方法</h4><p>我们有两种学习方式：</p><ul><li>在episode的最后收集奖励并计算最大期望将来奖励：蒙特卡罗方法</li><li>估计每一步的奖励：时序差分学习</li></ul><a id="more"></a><h5 id="蒙特卡罗"><a href="#蒙特卡罗" class="headerlink" title="蒙特卡罗"></a>蒙特卡罗</h5><p>当episode结束时（智能体到达一个“终止状态”），智能体视其总共的累计奖励来知晓它做的怎么样。在蒙特卡罗方法中，只有在游戏的最后才会收到奖励。</p><p>然后，带着新增的知识开启一轮新游戏。智能体每次迭代会做出更好的决策。</p><h4 id="探索-开发的权衡"><a href="#探索-开发的权衡" class="headerlink" title="探索/开发的权衡"></a>探索/开发的权衡</h4><ul><li>探索是发现有关环境的更多信息</li><li>开发是开发已知的信息，使得奖励最大化</li></ul><p>强化学习智能体的目标是最大化期望的累计奖励，然而，我们会陷入一个共同的陷阱。</p><p>我们必须定义一个规则帮助我们处理这种权衡。</p><h4 id="强化学习的三种方法"><a href="#强化学习的三种方法" class="headerlink" title="强化学习的三种方法"></a>强化学习的三种方法</h4><p>解决强化学习问题的三种方法是：基于值、基于策略、基于模型。</p><h5 id="基于值"><a href="#基于值" class="headerlink" title="基于值"></a>基于值</h5><p>在基于值的强化学习中，目标是优化值函数</p><blockquote><p>值函数告知我们智能体在每个状态得到的最大期望将来奖励</p></blockquote><p>每个状态的值是在那个状态的智能体期望在将来累计的奖励总数。<br>$$<br>V_\pi(s)=\mathbb{E_\pi}[R_{t+1}+\gamma R_{t+2}+\gamma ^2 R_{t+3}+…|S_t =s]<br>$$<br>智能体会使用这个值函数去在每一步选择一个状态，选择的状态具有最大的值。</p><h5 id="基于策略"><a href="#基于策略" class="headerlink" title="基于策略"></a>基于策略</h5><p>在基于策略的强化学习中，我们想不使用值函数而直接优化策略函数$\mathtt{\pi}(s)$。</p><p>策略是在一个给定的时间对智能体行为的定义。<br>$$<br>a=\pi(s)<br>$$<br>我们学习一个策略函数，使每个状态映射到对应的最好动作。</p><p>我们有两种策略：</p><ul><li>固定策略：一种在给定状态总会返回相同动作的策略。</li><li>随机策略：随动作输出分布概率。</li></ul><p>$$<br>\text{Stochastic policy:} \ \pi(a|s)=\mathbb{P}[A_t=a|S_t=s]<br>$$</p><p>策略直接表明每一步应该采取的最好动作。</p><h5 id="基于模型"><a href="#基于模型" class="headerlink" title="基于模型"></a>基于模型</h5><p>在基于模型的强化学习中，我们对环境建模。这意味着我们创建了一个环境行为的模型。</p><p>问题是每个环境都需要一个不同的模型表示。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;蒙特卡罗-VS-TD学习方法&quot;&gt;&lt;a href=&quot;#蒙特卡罗-VS-TD学习方法&quot; class=&quot;headerlink&quot; title=&quot;蒙特卡罗 VS TD学习方法&quot;&gt;&lt;/a&gt;蒙特卡罗 VS TD学习方法&lt;/h4&gt;&lt;p&gt;我们有两种学习方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在episode的最后收集奖励并计算最大期望将来奖励：蒙特卡罗方法&lt;/li&gt;
&lt;li&gt;估计每一步的奖励：时序差分学习&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="memo" scheme="https://e99net.github.io/categories/memo/"/>
    
    
      <category term="Reinforcement Learning" scheme="https://e99net.github.io/tags/Reinforcement-Learning/"/>
    
  </entry>
  
  <entry>
    <title>Latex处理参考文献</title>
    <link href="https://e99net.github.io/2018/11/02/reference_of_latex/"/>
    <id>https://e99net.github.io/2018/11/02/reference_of_latex/</id>
    <published>2018-11-02T13:48:12.079Z</published>
    <updated>2018-11-02T13:51:28.363Z</updated>
    
    <content type="html"><![CDATA[<p>使用cite宏包可以生成参考文献</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\usepackage&#123;cite&#125;</span><br><span class="line">\cite&#123;b3,b4,b5,b6,b7,b8&#125;</span><br></pre></td></tr></table></figure><p>生成的参考文献格式为：[3]-[8]</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用cite宏包可以生成参考文献&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;
      
    
    </summary>
    
      <category term="memo" scheme="https://e99net.github.io/categories/memo/"/>
    
    
      <category term="Latex" scheme="https://e99net.github.io/tags/Latex/"/>
    
  </entry>
  
</feed>
