<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>99°</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://e99net.github.io/"/>
  <updated>2020-10-04T18:46:33.000Z</updated>
  <id>https://e99net.github.io/</id>
  
  <author>
    <name>sqLiu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>macOS新手上路</title>
    <link href="https://e99net.github.io/2020/10/05/new_to_macOS/"/>
    <id>https://e99net.github.io/2020/10/05/new_to_macOS/</id>
    <published>2020-10-04T18:46:33.000Z</published>
    <updated>2020-10-04T18:46:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>安装软件</p><ul><li>Hands Off!</li><li>Proxifier</li><li>The Unarchiver</li><li>Itsycal</li><li>BetterTouchTool</li><li>Alfred 4</li><li>HandShaker</li></ul><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;安装软件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Hands Off!&lt;/li&gt;
&lt;li&gt;Proxifier&lt;/li&gt;
&lt;li&gt;The Unarchiver&lt;/li&gt;
&lt;li&gt;Itsycal&lt;/li&gt;
&lt;li&gt;BetterTouchTool&lt;/li&gt;
&lt;li&gt;Alfred 4&lt;/li&gt;
&lt;li&gt;HandShaker&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="memo" scheme="https://e99net.github.io/categories/memo/"/>
    
    
      <category term="Water" scheme="https://e99net.github.io/tags/Water/"/>
    
  </entry>
  
  <entry>
    <title>前n小的和</title>
    <link href="https://e99net.github.io/2020/03/15/first_n_small_sum/"/>
    <id>https://e99net.github.io/2020/03/15/first_n_small_sum/</id>
    <published>2020-03-15T05:07:25.941Z</published>
    <updated>2020-03-15T05:21:42.235Z</updated>
    
    <content type="html"><![CDATA[<h4 id="两序列前n小的两数和"><a href="#两序列前n小的两数和" class="headerlink" title="两序列前n小的两数和"></a>两序列前n小的两数和</h4><ul><li>描述：有两个长度都是N的序列A和B，在A和B中各取一个数相加可以得到$N^2$个和，求这$N^2$个和中最小的N个。</li></ul><a id="more"></a><ul><li>输入：</li></ul><p>第一行输入一个正整数N，$1 \le N \le 100000$，表示序列长度；</p><p>第二行输入N个整数$A_i$，满足$A_i \le A_{i+1}$且$A_i \le 10^9$；</p><p>第二行输入N个整数$B_i$，满足$B_i \le B_{i+1}$且$B_i \le 10^9$。</p><ul><li>输出：</li></ul><p>输出仅一行，包含N个整数，从小到大输出这N个最小的和，相邻数字之间用空格隔开。</p><ul><li>样例输入：</li></ul><p>3<br>2 6 6<br>1 4 8</p><ul><li>样例输出：</li></ul><p>3 6 7</p><ul><li>解题思路：</li></ul><p>由题意可得A和B是两个升序排列的序列，其中：</p><p>A[1]+B[1] &lt;= A[2]+B[1] &lt;= … &lt;= A[N]+B[1]</p><p>A[1]+B[2] &lt;= A[2]+B[2] &lt;= … &lt;= A[N]+B[2]</p><p>……</p><p>A[1]+B[N] &lt;= A[2]+B[N] &lt;= … &lt;= A[N]+B[N]</p><p>接下来，就相当于要将这N个有序队列进行合并排序：</p><p>首先，将这N个队列中的第一个元素放入一个堆中；</p><p>然后；每次取出堆中的最小值。若这个最小值来自于第k个队列，那么，就将第k个队列的下一个元素放入堆中。</p><p>时间复杂度：O(NlogN)。</p><p>堆可用优先队列实现，此题需要的是一个小顶堆。</p><ul><li>参考代码:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=1e5+10;</span><br><span class="line">typedef pair&lt;int,int&gt; PII;</span><br><span class="line">int n;</span><br><span class="line">int a[N],b[N],next_of_a[N];</span><br><span class="line">int i;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt; &gt; pq;//小顶堆</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(i=1;i&lt;=n;i++)</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">    for(i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;b[i]);</span><br><span class="line">        next_of_a[i]=2;</span><br><span class="line">        pq.push(&#123;a[1]+b[i],i&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    while(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%d &quot;,pq.top().first);</span><br><span class="line">        i=pq.top().second;</span><br><span class="line">        pq.pop();</span><br><span class="line">        pq.push(&#123;a[next_of_a[i]++]+b[i],i&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;两序列前n小的两数和&quot;&gt;&lt;a href=&quot;#两序列前n小的两数和&quot; class=&quot;headerlink&quot; title=&quot;两序列前n小的两数和&quot;&gt;&lt;/a&gt;两序列前n小的两数和&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;描述：有两个长度都是N的序列A和B，在A和B中各取一个数相加可以得到$N^2$个和，求这$N^2$个和中最小的N个。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://e99net.github.io/categories/Algorithm/"/>
    
    
      <category term="Heap" scheme="https://e99net.github.io/tags/Heap/"/>
    
  </entry>
  
  <entry>
    <title>数组跳跃问题</title>
    <link href="https://e99net.github.io/2019/11/17/simpleproblemofjump/"/>
    <id>https://e99net.github.io/2019/11/17/simpleproblemofjump/</id>
    <published>2019-11-17T06:01:03.776Z</published>
    <updated>2020-03-15T05:06:51.634Z</updated>
    
    <content type="html"><![CDATA[<h4 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a>跳跃游戏</h4><ul><li>描述：给定数组arr，arr[i]=k代表可以从位置i向右跳1 ~ k个距离。比如，arr[2]=3，代表从位置2可以跳到位置3、位置4或位置5。如果从位置0出发，返回最少跳几次能跳到arr最后的位置上。如果arr长度为N，要求实现时间复杂度为O(N)、额外空间复杂度为O(1)的解法。</li></ul><a id="more"></a><ul><li>输入：</li></ul><p>第一行输入一个正整数N，$1 \le N \le 100$，表示数组的元素数。</p><p>第二行输入N个数，用空格隔开，表示一个数组中的所有数。</p><ul><li>输出：</li></ul><p>输出一个整数，表示最少跳几次。</p><ul><li>样例输入：</li></ul><p>6<br>3 2 3 1 1 4</p><ul><li>样例输出：</li></ul><p>2</p><ul><li>样例解释：</li></ul><p>arr[0]=3，选择跳到位置2；arr[2]=3，可以跳到最后的位置。所以返回2。</p><ul><li>解题思路：</li></ul><p>这道题是一道简单的不能再简单的“水题”，可以说是动态规划的入门题。会者不难，难者不会。</p><p>思路太简单，略，←_←。直接上代码。<br>感觉和剑指offer上“股票的最大利润”一题有点像。</p><ul><li>参考代码:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int jump(vector&lt;int&gt;&amp; arr) &#123;</span><br><span class="line">        if(arr.empty()) return 0;</span><br><span class="line">        int jump=0;</span><br><span class="line">        int cur=0;</span><br><span class="line">        int next=0;</span><br><span class="line">        for(int i=0;i&lt;arr.size();i++) &#123;</span><br><span class="line">            if(cur&lt;i) &#123;</span><br><span class="line">                jump++;</span><br><span class="line">                cur=next;</span><br><span class="line">            &#125;</span><br><span class="line">            next=max(next,i+arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return jump;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;跳跃游戏&quot;&gt;&lt;a href=&quot;#跳跃游戏&quot; class=&quot;headerlink&quot; title=&quot;跳跃游戏&quot;&gt;&lt;/a&gt;跳跃游戏&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;描述：给定数组arr，arr[i]=k代表可以从位置i向右跳1 ~ k个距离。比如，arr[2]=3，代表从位置2可以跳到位置3、位置4或位置5。如果从位置0出发，返回最少跳几次能跳到arr最后的位置上。如果arr长度为N，要求实现时间复杂度为O(N)、额外空间复杂度为O(1)的解法。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://e99net.github.io/categories/Algorithm/"/>
    
    
      <category term="Dynamic Programming" scheme="https://e99net.github.io/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>一道算法编程题</title>
    <link href="https://e99net.github.io/2019/11/10/liulishuo/"/>
    <id>https://e99net.github.io/2019/11/10/liulishuo/</id>
    <published>2019-11-10T12:12:51.364Z</published>
    <updated>2019-11-10T12:31:33.803Z</updated>
    
    <content type="html"><![CDATA[<h4 id="火车站台数量"><a href="#火车站台数量" class="headerlink" title="火车站台数量"></a>火车站台数量</h4><ul><li>描述：假设已知某个火车站的所有过往列车的到达arrival和离开departure时间（同一天），如果要求所有列车都不等待直接进站，问至少需要多少个站台。无需考虑晚点等特殊情况。</li></ul><a id="more"></a><ul><li>输入：</li></ul><p>第一行输入一个正整数N，$1 \le N \le 100$，表示过往列车数。</p><p>第二行输入N个字符串，每个字符串表示列车的到达时间，字符串之间用空格隔开。</p><p>第三行输入N个字符串，每个字符串表示列车的离开时间，字符串之间用空格隔开。</p><ul><li>输出：</li></ul><p>输出一个整数，表示最少需要的站台数。</p><ul><li>样例输入：</li></ul><p>6<br>9:00 9:40 9:50 11:00 15:00 18:00<br>9:10 12:00 11:20 11:30 19:00 20:00</p><ul><li>样例输出：</li></ul><p>3</p><ul><li>样例解释：</li></ul><p>最多有3辆列车同时进站（在11:00到11:20之间），所以至少需要3个火车站台。</p><ul><li>解题思路：</li></ul><p>题目要求找到所有时间中同时在车站的列车的最大数量。一个简单的方案是逐个检查每个车辆的停发时间段，然后看有多少个时间段区间与其有重合，记录最多的重合区间数目，即为待求解的答案。易知，此方法的时间复杂度为O(n^2)。<br>认真思考后，其实可以有O(nlog_2 n)时间复杂度的方法。思路是将所有的事件 (到达或离开)按时间顺序排序，然后只记录当前还在车站（未离开的）列车。所有时间点中最多数量列车即待求解的答案。<br>例如，对于上面样例输入，将所有事件按时间排序后得到：</p><table><thead><tr><th>时间</th><th>事件</th><th>需要的站台数量</th></tr></thead><tbody><tr><td>9:00</td><td>Arrival</td><td>1</td><td></td></tr><tr><td>9:10</td><td>Departure</td><td>0</td><td></td></tr><tr><td>9:40</td><td>Arrival</td><td>1</td><td></td></tr><tr><td>9:50</td><td>Arrival</td><td>2</td><td></td></tr><tr><td>11:00</td><td>Arrival</td><td><strong>3</strong></td><td></td></tr><tr><td>11:20</td><td>Departure</td><td>2</td><td></td></tr><tr><td>11:30</td><td>Departure</td><td>1</td><td></td></tr><tr><td>12:00</td><td>Departure</td><td>0</td><td></td></tr><tr><td>15:00</td><td>Arrival</td><td>1</td><td></td></tr><tr><td>18:00</td><td>Arrival</td><td>2</td><td></td></tr><tr><td>19:00</td><td>Departure</td><td>1</td><td></td></tr><tr><td>20:00</td><td>Departure</td><td>0</td><td></td></tr></tbody></table><p>最多需要的站台数量是3，时间段为11:00 ~ 11:20</p><p>注意，在算法实现时，只需对到达时间arr数组，和离开时间dep数组进行单独排序，然后将两个有序数组再进行归并操作。</p><ul><li>参考代码:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;火车站台数量&quot;&gt;&lt;a href=&quot;#火车站台数量&quot; class=&quot;headerlink&quot; title=&quot;火车站台数量&quot;&gt;&lt;/a&gt;火车站台数量&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;描述：假设已知某个火车站的所有过往列车的到达arrival和离开departure时间（同一天），如果要求所有列车都不等待直接进站，问至少需要多少个站台。无需考虑晚点等特殊情况。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://e99net.github.io/categories/Algorithm/"/>
    
    
      <category term="Simulation" scheme="https://e99net.github.io/tags/Simulation/"/>
    
  </entry>
  
  <entry>
    <title>两道算法编程题</title>
    <link href="https://e99net.github.io/2019/11/10/webank/"/>
    <id>https://e99net.github.io/2019/11/10/webank/</id>
    <published>2019-11-10T11:15:19.892Z</published>
    <updated>2019-11-10T12:07:22.337Z</updated>
    
    <content type="html"><![CDATA[<h4 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h4><ul><li>描述：</li></ul><p>你需要对一个数组进行排序（升序），每一次，你可以将一个数移动到任意位置，这一次操作的代价是这个数的大小。最少需要多少代价才能将整个数组排序？</p><a id="more"></a><ul><li>输入：</li></ul><p>第一行输入一个正整数N，$1 \le N \le 100$，表示数组元素个数。</p><p>第二行输入N个整数，整数之间用空格隔开。</p><ul><li>输出：</li></ul><p>输出一个整数，表示将整个数组排序的最小代价。</p><ul><li>样例输入：</li></ul><p>4<br>8 1 2 3</p><ul><li>样例输出：</li></ul><p>6</p><ul><li>解题思路：</li></ul><p>求出里面和最大的升序数组，用数组和减去它就是结果了。因为最终的数组和原来的数组，差别就在于那些移动了位置的数，要让移动位置的代价最小，当然就是让移动位置的数的和最小，等价于不移动位置的数的和最大，而最大的升序数组和就是能够不移动位置的最大子数组。<br>最大的升序数组和可用dp求出。</p><ul><li>参考代码:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="取棋子"><a href="#取棋子" class="headerlink" title="取棋子"></a>取棋子</h4><ul><li>描述：</li></ul><p>西西有一个N行N列的棋盘，其中某些格子上放有棋子（黑子或白子）。西西不希望棋盘上有两个相邻的格子放 着颜色相同的棋子，与第i行 第j列的格子相邻的格子为：</p><p>第i-1行第j列的格子（当i&gt;1时）；</p><p>第i+1行第j列的格子（当i&lt;N时）；</p><p>第i行第i-1列的格子（当i&gt;1时）；</p><p>第i行第i+1列的格子（当i&lt;N时）。</p><p>现在，西西可以取走棋盘上的某些棋子，使得剩下的棋子中，任意两个颜色相同的棋子所在的格子不相邻。<br>那么， 棋盘上最多剩下多少个棋子？</p><ul><li>输入：</li></ul><p>第一行输入一个正整数N，$N \le 50$，表示棋盘的行列数。</p><p>接下来的N行，每行有N个整数，整数之间用空格隔开，表示棋盘每行每列防止棋子的情况。<br>整数取值只能是0、1、2，分别表示该格未放棋子、放的是黑子、放的是白子。</p><ul><li>输出：</li></ul><p>输出一个整数，表示棋盘上最多剩下的棋子数。</p><ul><li>样例输入：</li></ul><ul><li>样例输出：</li></ul><ul><li>解题思路：</li></ul><p>给每个棋子设置一个度(0 1 2 3 4)。一个棋子周围每有一个同样颜色的棋子，那就让它的度加1，最小为0，最大为4。然后从棋盘里逐个删掉度是4的并且更新棋盘(周围的同样颜色的棋子度要剪1)，然后删掉度是3的，以此类推知道所有棋子度是0，看这时候删了多少棋子。</p><p>用4个hash set分别保存度为1 2 3 4的点，每删一个度为4的点，就更新所有它周围的节点，然后再继续进行删除。对黑的进行一次删除，再对白的进行一次删除，就能求出结果了。</p><p>这个方法对相连的度为4的点还要额外讨论。<br><img src="/2019/11/10/webank/20191110200143.jpg" alt=""><br>图中的两个点度都为4，但删绿的总共删四个，删红的 总共删五个。<br>所以又想出一个方法：先取连通的区域 统计如果在国际象棋棋盘中 黑格和白格点数 然后删少的。<br>在上图中就是黑7白4，删白的。<br><img src="/2019/11/10/webank/20191110200530.jpg" alt=""><br>五个同色棋子，白格一个，黑格四个，删白格。<br>但这种方法还是有badcase。</p><p>所以……我也不知道咋做！</p><ul><li>参考代码:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;数组排序&quot;&gt;&lt;a href=&quot;#数组排序&quot; class=&quot;headerlink&quot; title=&quot;数组排序&quot;&gt;&lt;/a&gt;数组排序&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;描述：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;你需要对一个数组进行排序（升序），每一次，你可以将一个数移动到任意位置，这一次操作的代价是这个数的大小。最少需要多少代价才能将整个数组排序？&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://e99net.github.io/categories/Algorithm/"/>
    
    
      <category term="Dynamic Programming" scheme="https://e99net.github.io/tags/Dynamic-Programming/"/>
    
      <category term="Greedy" scheme="https://e99net.github.io/tags/Greedy/"/>
    
  </entry>
  
  <entry>
    <title>宽搜手工写队列</title>
    <link href="https://e99net.github.io/2019/10/26/bytedance_2019_2/"/>
    <id>https://e99net.github.io/2019/10/26/bytedance_2019_2/</id>
    <published>2019-10-26T07:10:04.956Z</published>
    <updated>2019-10-26T07:52:46.047Z</updated>
    
    <content type="html"><![CDATA[<h4 id="二维数组区块计数"><a href="#二维数组区块计数" class="headerlink" title="二维数组区块计数"></a>二维数组区块计数</h4><ul><li>描述：</li></ul><p>输入一个只包含0和1的二维数组，上下左右和对角相邻的1组成一个区块，0不形成区块，求数组中的区块个数。</p><a id="more"></a><ul><li>输入：</li></ul><p>第一行输入两个正整数N和M，N表示数组行数，M表示数组列数。</p><p>接下来N行，每行表示数组对应的一行，每行包含M个整数，整数之间用空格隔开。</p><ul><li>输出：</li></ul><p>输出一个整数，表示数组中区块的个数。</p><ul><li>数据范围：</li></ul><p>$0 \le N,M,N*M \le 10^6$</p><ul><li>样例输入：</li></ul><p>3 3<br>0 1 0<br>1 0 0<br>1 0 1</p><ul><li>样例输出：</li></ul><p>2</p><ul><li>样例解释：</li></ul><p>数组右下角的1单独构成一个区块，其他的3个1对角或上下相邻，构成另一个区块。</p><ul><li><p>解题思路：宽搜/深搜</p></li><li><p>参考代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">//dfs</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef pair&lt;int,int&gt; PII;</span><br><span class="line">const int N=1000010;</span><br><span class="line">int n,m;</span><br><span class="line">int g[N];</span><br><span class="line"></span><br><span class="line">void dfs(int x,int y) &#123;</span><br><span class="line">    g[x*m+y]=0;</span><br><span class="line">    for(int i=-1;i&lt;=1;i++)</span><br><span class="line">        for(int j=-1;j&lt;=1;j++) &#123;</span><br><span class="line">            int a=x+i,b=y+j;</span><br><span class="line">            if(a&gt;=0&amp;&amp;a&lt;n&amp;&amp;b&gt;=0&amp;&amp;b&lt;m&amp;&amp;g[a*m+b])</span><br><span class="line">                dfs(a,b);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">    for(int i=0,k=0;i&lt;n;i++)</span><br><span class="line">        for(int j=0;j&lt;m;j++,k++)</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;g[k]);</span><br><span class="line">    int res=0;</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">        for(int j=0;j&lt;m;j++) &#123;</span><br><span class="line">            if(g[i*m+j]) &#123;</span><br><span class="line">                res++;</span><br><span class="line">                dfs(i,j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;,res);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">//bfs，用STL中的queue</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef pair&lt;int,int&gt; PII;</span><br><span class="line">const int N=1000010;</span><br><span class="line"></span><br><span class="line">int n,m;</span><br><span class="line">int g[N];</span><br><span class="line"></span><br><span class="line">void bfs(int sx,int sy) &#123;</span><br><span class="line">    queue&lt;PII&gt; q;</span><br><span class="line">    q.push(&#123;sx,sy&#125;);</span><br><span class="line">    g[sx*m+sy]=0;</span><br><span class="line"></span><br><span class="line">    while(q.size()) &#123;</span><br><span class="line">        auto t=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        int x=t.first,y=t.second;</span><br><span class="line"></span><br><span class="line">        for(int i=-1;i&lt;=1;i++)</span><br><span class="line">            for(int j=-1;j&lt;=1;j++) &#123;</span><br><span class="line">                int a=x+i,b=y+j;</span><br><span class="line">                if(a&gt;=0&amp;&amp;a&lt;n&amp;&amp;b&gt;=0&amp;&amp;b&lt;m&amp;&amp;g[a*m+b]) &#123;</span><br><span class="line">                    g[a*m+b]=0;</span><br><span class="line">                    q.push(&#123;a,b&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">    for(int i=0,k=0;i&lt;n;i++)</span><br><span class="line">        for(int j=0;j&lt;m;j++,k++)</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;g[k]);</span><br><span class="line"></span><br><span class="line">    int res=0;</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">        for(int j=0;j&lt;m;j++)</span><br><span class="line">            if(g[i*m+j]) &#123;</span><br><span class="line">                res++;</span><br><span class="line">                bfs(i,j);</span><br><span class="line">            &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;,res);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">//bfs，用手工写的队列</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef pair&lt;int,int&gt; PII;</span><br><span class="line">const int N=1000010;</span><br><span class="line"></span><br><span class="line">int n,m;</span><br><span class="line">int g[N];</span><br><span class="line">PII q[N];</span><br><span class="line"></span><br><span class="line">void bfs(int sx,int sy) &#123;</span><br><span class="line">    int hh=0,tt=0;</span><br><span class="line">    q[0]=&#123;sx,sy&#125;;</span><br><span class="line">    g[sx*m+sy]=0;</span><br><span class="line">    while(hh&lt;=tt) &#123;</span><br><span class="line">        PII t=q[hh++];</span><br><span class="line">        int x=t.first,y=t.second;</span><br><span class="line">        for(int i=-1;i&lt;=1;i++)</span><br><span class="line">            for(int j=-1;j&lt;=1;j++) &#123;</span><br><span class="line">                int a=x+i,b=y+j;</span><br><span class="line">                if(a&gt;=0&amp;&amp;a&lt;n&amp;&amp;b&gt;=0&amp;&amp;b&lt;m&amp;&amp;g[a*m+b]) &#123;</span><br><span class="line">                    g[a*m+b]=0;</span><br><span class="line">                    q[++tt]=&#123;a,b&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">    for(int i=0,k=0;i&lt;n;i++)</span><br><span class="line">        for(int j=0;j&lt;m;j++,k++)</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;g[k]);</span><br><span class="line"></span><br><span class="line">    int res=0;</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">        for(int j=0;j&lt;m;j++)</span><br><span class="line">            if(g[i*m+j]) &#123;</span><br><span class="line">                res++;</span><br><span class="line">                bfs(i,j);</span><br><span class="line">            &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;,res);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行时间：<ul><li>用dfs：1003ms</li><li>用bfs：<ul><li>用STL中的queue：1932ms</li><li>用手工写的队列：1036ms</li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;二维数组区块计数&quot;&gt;&lt;a href=&quot;#二维数组区块计数&quot; class=&quot;headerlink&quot; title=&quot;二维数组区块计数&quot;&gt;&lt;/a&gt;二维数组区块计数&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;描述：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;输入一个只包含0和1的二维数组，上下左右和对角相邻的1组成一个区块，0不形成区块，求数组中的区块个数。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://e99net.github.io/categories/Algorithm/"/>
    
    
      <category term="DFS" scheme="https://e99net.github.io/tags/DFS/"/>
    
      <category term="BFS" scheme="https://e99net.github.io/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>立方体塔</title>
    <link href="https://e99net.github.io/2019/10/26/bytedance_2019_1/"/>
    <id>https://e99net.github.io/2019/10/26/bytedance_2019_1/</id>
    <published>2019-10-26T05:16:58.977Z</published>
    <updated>2019-10-26T06:23:10.941Z</updated>
    
    <content type="html"><![CDATA[<ul><li>描述：</li></ul><p>小方有w个白色立方体和b个黑色立方体，现在小方想把它们堆成一个立方体塔。</p><p>一座高度为h的立方体塔，最底层有h个立方体，每往上一层，所需立方体减一，直到最高层只需要一个立方体。</p><p>为了让这座塔看起来美观，小方希望每一层都只能用一种颜色的立方体。</p><p>小方希望把这座塔叠的尽可能高，因此他想知道塔的最大高度是多少，以及这个高度的立方体塔能有几种。</p><p>两种立方体塔，当且仅当至少有一层的颜色是不同的，则被认为是不同的。</p><a id="more"></a><ul><li>输入：</li></ul><p>共一行，包含两个整数w和b。</p><ul><li>输出：</li></ul><p>共一行，包含两个整数h和c，分别表示最高塔的高度以及此高度塔的种类数。</p><p>因为种类数可能较多，请将c对$10^9+7$取模后的值输出。</p><ul><li>数据范围：</li></ul><p>$0 \le w,b \le 10^5$</p><ul><li>样例输入：</li></ul><p>1 1<br>4 6</p><ul><li>样例输出：</li></ul><p>1 2<br>4 2</p><ul><li>解题思路：0/1背包问题求方案数</li></ul><p>假设用到的白色块总数是a，那么“1到h层有多少种选法使得白色块总数是a”就是最后此高度塔的种类数。1到h层有多少种选法使得白色块总数是a，即选出1 ~ h中的若干数，让这些数的加和是a。a不是确定的，还要枚举一下a。对于每个a都求一个f[a]，那么$\sum f[a]$就是答案。</p><p>f(i,j)是在考虑前i个物品的情况下，体积是j的方案数，有$f(i,j)=f(i-1,j)+f(i-1,j-v[i])$，做恒等变形得$f(j)=f(j)+f(j-i)$，在这里v[i]就是i，第i个物品的体积就是i。</p><ul><li>参考代码:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=100010,mod=1e9+7;</span><br><span class="line"></span><br><span class="line">int f[N];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n,m;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line"></span><br><span class="line">    int h=1;</span><br><span class="line">    while(h*(h+1)/2&lt;=n+m) h++;</span><br><span class="line">    h--;</span><br><span class="line"></span><br><span class="line">    //swap(n,m);</span><br><span class="line"></span><br><span class="line">    f[0]=1;</span><br><span class="line">    for(int i=1;i&lt;=h;i++) &#123;</span><br><span class="line">        for(int j=n;j&gt;=i;j--) &#123;</span><br><span class="line">            f[j]=(f[j]+f[j-i])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int res=0;</span><br><span class="line">    for(int i=0;i&lt;=n;i++)</span><br><span class="line">        if(h*(h+1)/2-i&lt;=m)</span><br><span class="line">            res=(res+f[i])%mod;</span><br><span class="line"></span><br><span class="line">    printf(&quot;%d %d\n&quot;,h,res);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码是滚动数组优化之后f变成一维的情况。f[N]等同于f[N][N],<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">f[0]=1;</span><br><span class="line">for(int i=1;i&lt;=h;i++) &#123;</span><br><span class="line">    for(int j=n;j&gt;=i;j--) &#123;</span><br><span class="line">        f[j]=(f[j]+f[j-i])%mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>等同于<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">f[0][0]=1;</span><br><span class="line">for(int i=1;i&lt;=h;i++)</span><br><span class="line">    for(int j=0;j&lt;=n;j++) &#123;</span><br><span class="line">        f[i][j]=f[i-1][j];//不选第i个物品</span><br><span class="line">        if(j&gt;=i) f[i][j]+=f[i-1][j-i];//如果体积够的话就可以选第i个物品</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>二维变成一维的过程是对代码做恒等变形的过程，f[i][j]=f[i-1][j]和f[j]=f[j]就完全一样了，可以删掉（f[j]本来就等于f[j]）。</p><p>if(j&gt;=i)可以写到第二个循环里去，将for(int j=0;j&lt;=n;j++)变成for(int j=i;j&lt;=n;j++)，因为j &lt; i时循环压根不会执行。</p><p>剩下的就是对f[i][j]+=f[i-1][j-i]的变形，如果j从小到大枚举，那么f[i][j]+=f[i-1][j-i]不会等价于f[j]+=f[j-i]：<br>i是大于0的，所以j-i一定是小于j的，从小到大枚举j的话会先算f[j-i]再算f[j]，先算f[j-i]的时候是在第i层算的，那f[j]+=f[j-i]就等价于f[i][j]+=f[i][j-i]，而不等价于f[i][j]+=f[i-1][j-i]。</p><p>将j改为从大到小枚举（for(int j=n;j&gt;=i;j–)）的话就可以了，此时j-i还是比j小，但变成f[j-i]在f[j]后面算（因为j从大到小枚举），此时f[j-i]用的就不是第i层的f[j-i]（因为还没算到），而是上一层——第i-1层的f[j-i]（还没被更新），那f[j]+=f[j-i]就和f[i][j]+=f[i-1][j-i]等价了。</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;描述：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;小方有w个白色立方体和b个黑色立方体，现在小方想把它们堆成一个立方体塔。&lt;/p&gt;
&lt;p&gt;一座高度为h的立方体塔，最底层有h个立方体，每往上一层，所需立方体减一，直到最高层只需要一个立方体。&lt;/p&gt;
&lt;p&gt;为了让这座塔看起来美观，小方希望每一层都只能用一种颜色的立方体。&lt;/p&gt;
&lt;p&gt;小方希望把这座塔叠的尽可能高，因此他想知道塔的最大高度是多少，以及这个高度的立方体塔能有几种。&lt;/p&gt;
&lt;p&gt;两种立方体塔，当且仅当至少有一层的颜色是不同的，则被认为是不同的。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://e99net.github.io/categories/Algorithm/"/>
    
    
      <category term="Knapsack" scheme="https://e99net.github.io/tags/Knapsack/"/>
    
  </entry>
  
  <entry>
    <title>总结买卖股票这一类型的几道题</title>
    <link href="https://e99net.github.io/2019/10/22/LeetCode_BestTimeToBuyAndSellStock/"/>
    <id>https://e99net.github.io/2019/10/22/LeetCode_BestTimeToBuyAndSellStock/</id>
    <published>2019-10-22T12:01:17.021Z</published>
    <updated>2019-10-22T14:59:56.341Z</updated>
    
    <content type="html"><![CDATA[<h4 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h4><ul><li>描述：</li></ul><p>给一个数组，数组中的第i个元素代表第i天的股票价格。如果只允许完全至多一次交易（即买进一股股票并卖出这股股票），那么最大收益是多少？</p><p>注意：卖出股票的时间不能早于买进股票的时间。</p><a id="more"></a><ul><li>输入：</li></ul><p>一个数组。</p><ul><li>输出：</li></ul><p>买卖股票的最大收益。</p><ul><li>样例输入1：</li></ul><p>[7,1,5,3,6,4]</p><ul><li>样例输出1：</li></ul><p>5</p><ul><li>样例输入2：</li></ul><p>[7,6,4,3,1]</p><ul><li>样例输出2：</li></ul><p>0</p><ul><li><p>解题思路：贪心法</p></li><li><p>参考代码:</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//复杂度O(n)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">        if(prices.size()&lt;2)</span><br><span class="line">            return 0;</span><br><span class="line">        int max=0,diff=0;</span><br><span class="line">        for(int i=0;i&lt;prices.size()-1;i++) &#123;</span><br><span class="line">            for(int j=i+1;j&lt;prices.size();j++) &#123;</span><br><span class="line">                diff=prices[j]-prices[i];</span><br><span class="line">                if(diff&gt;max) max=diff;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h4><ul><li>描述：</li></ul><p>给一个数组，数组中的第i个元素代表第i天的股票价格。如果允许完成多次交易（即多次买进一股股票并卖出这股股票），那么最大收益是多少？</p><p>注意：不能同时进行多次交易，必须在再次买进股票前卖出股票。</p><ul><li>输入：</li></ul><p>一个数组。</p><ul><li>输出：</li></ul><p>买卖股票的最大收益。</p><ul><li>输入样例1：</li></ul><p>[7,1,5,3,6,4]</p><ul><li>输出样例1：</li></ul><p>7</p><ul><li><p>说明：第二天买进，第三天卖出，获得收益5-1=4；第四天买进，第五天卖出，获得收益6-3=3。总共获得收益4+3=7。</p></li><li><p>输入样例2：</p></li></ul><p>[1,2,3,4,5]</p><ul><li>输出样例2：</li></ul><p>4</p><ul><li><p>说明：第一天买进，第五天卖出，获得收益5-1=4。不能在第一天买进，第二天买进，稍后再卖出它们，因为这算同时进行多次交易。</p></li><li><p>输入样例3：</p></li></ul><p>[7,6,4,3,1]</p><ul><li>输出样例3：</li></ul><p>0</p><ul><li><p>解题思路：贪心法</p></li><li><p>参考代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProfit(vector&lt;int&gt;&amp; prices)&#123;</span><br><span class="line">        int sum=0;</span><br><span class="line">        for(int i=1;i&lt;prices.size();i++) &#123;</span><br><span class="line">            int diff=prices[i]-prices[i-1];</span><br><span class="line">            if(diff&gt;0) sum+=diff;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h4><ul><li>描述：</li></ul><p>给一个数组，数组中的第i个元素代表第i天的股票价格。如果只允许完成最多两次交易（即最多两次买进股票并卖出股票），那么最大收益是多少？</p><p>注意：不能同时进行多次交易，必须在再次买进股票前卖出股票。</p><ul><li>输入：</li></ul><p>一个数组。</p><ul><li>输出：</li></ul><p>买卖股票的最大收益。</p><ul><li>输入样例1：</li></ul><p>[3,3,5,0,0,3,1,4]</p><ul><li>输出样例1：</li></ul><p>6</p><ul><li><p>说明：第四天买进，第六天卖出，获得收益3-0=3；然后第七天买进，第八天卖出，获得收益4-1=3。总共获得收益3+3=6。</p></li><li><p>输入样例2：</p></li></ul><p>[1,2,3,4,5]</p><ul><li>输出样例2：</li></ul><p>4</p><ul><li><p>说明：第一天买进，第五天卖出，获得收益5-1=4。不能在第一天买进，第二天买进，稍后再卖出它们，因为这算同时进行多次交易。</p></li><li><p>输入样例3：</p></li></ul><p>[7,6,4,3,1]</p><ul><li>输出样例3：</li></ul><p>0</p><ul><li><p>解题思路：动态规划</p></li><li><p>参考代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">        if(prices.size()&lt;2)return 0;</span><br><span class="line">        const int n=prices.size();</span><br><span class="line">        vector&lt;int&gt; f(n,0);</span><br><span class="line">        vector&lt;int&gt; g(n,0);</span><br><span class="line">        for(int i=1,valley=prices[0];i&lt;n;i++) &#123;</span><br><span class="line">            valley=min(valley,prices[i]);</span><br><span class="line">            f[i]=max(f[i-1],prices[i]-valley);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=n-2,peak=prices[n-1];i&gt;=0;i--) &#123;</span><br><span class="line">            peak=max(peak,prices[i]);</span><br><span class="line">            g[i]=max(g[i],peak-prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        int max_profit=0;</span><br><span class="line">        for(int i=0;i&lt;n;i++)</span><br><span class="line">            max_profit=max(max_profit,f[i]+g[i]);</span><br><span class="line">        return max_profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="第四题"><a href="#第四题" class="headerlink" title="第四题"></a>第四题</h4><ul><li>描述：</li></ul><p>给一个数组，数组中的第i个元素代表第i天的股票价格。如果只允许完成最多k次交易（即最多k次买进股票并卖出股票），那么最大收益是多少？</p><p>注意：不能同时进行多次交易，必须在再次买进股票前卖出股票。</p><ul><li>输入：</li></ul><p>一个数组和一个数，用空格分隔。</p><ul><li>输出：</li></ul><p>买卖股票的最大收益。</p><ul><li>输入样例1：</li></ul><p>[2,4,1] 2</p><ul><li>输出样例1：</li></ul><p>2</p><ul><li><p>说明：第一天买进，第二天卖出，总共获得收益4-2=2。</p></li><li><p>输入样例2：</p></li></ul><p>[3,2,6,5,0,3] 2</p><ul><li>输出样例2：</li></ul><p>7</p><ul><li><p>说明：第二天买进，第三天卖出，获得收益6-2=4；然后在第五天买进，第六天卖出，获得收益3-0=3。总共获得收益4+3=7。</p></li><li><p>解题思路：动态规划</p></li></ul><p>这道题是第三题的推广<br>如果k的值远大于prices的天数，应该直接用第二题的解法，所以这道题又是第二题和第三题的结合</p><ul><li>参考代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProfit(int k, vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">        if(prices.empty()) return 0;</span><br><span class="line">        const int n=prices.size();</span><br><span class="line">        if(k&gt;=n) return solveMaxProfit(prices);</span><br><span class="line">        int global[k+1]=&#123;0&#125;;</span><br><span class="line">        int local[k+1]=&#123;0&#125;;</span><br><span class="line">        for(int i=0;i&lt;n-1;i++) &#123;</span><br><span class="line">            int diff=prices[i+1]-prices[i];</span><br><span class="line">            for(int j=k;j&gt;=1;j--) &#123;</span><br><span class="line">                local[j]=max(global[j-1]+max(diff,0),local[j]+diff);</span><br><span class="line">                global[j]=max(global[j],local[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return global[k];</span><br><span class="line">    &#125;</span><br><span class="line">    int solveMaxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">        int res=0;</span><br><span class="line">        for(int i=1;i&lt;prices.size();i++) &#123;</span><br><span class="line">            if(prices[i]-prices[i-1]&gt;0) &#123;</span><br><span class="line">                res+=prices[i]-prices[i-1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="第五题"><a href="#第五题" class="headerlink" title="第五题"></a>第五题</h4><ul><li>描述：</li></ul><p>给一个数组，数组中的第i个元素代表第i天的股票价格。如果允许按照以下限制完成多次交易（即多次买进股票并卖出股票），那么最大收益是多少？</p><p>限制1：不能同时进行多次交易，必须在再次买进股票前卖出股票。<br>限制2：在卖出股票后，不能买进下一天的股票（冷却一天）。</p><ul><li>输入：</li></ul><p>一个数组。</p><ul><li>输出：</li></ul><p>买卖股票的最大收益。</p><ul><li>输入样例：</li></ul><p>[1,2,3,0,2]</p><ul><li>输出样例：</li></ul><p>3</p><ul><li><p>说明：第一天买进，第二天卖出，第三天冷却，第四天买进，第五天卖出，总共获得收益1+2=3。</p></li><li><p>解题思路：动态规划</p></li></ul><p><img src="/2019/10/22/LeetCode_BestTimeToBuyAndSellStock/585082-20160229165036642-1352963708.png" alt=""></p><p>状态转移图中：<br>S0 代表没有买入的状态<br>S1 代表买入后等待卖出的状态<br>S2 代表卖出后的状态</p><p>S2与S0的区别是：因为题目要求卖出后必须cooldown一轮，所以卖出进入S2后，必须再进入S0这个等待买入的状态，这一状态转换代表cooldown一轮</p><p>状态转移方程：<br>s0[i] = max(s0[i-1], s2[i-1])<br>s1[i] = max(s1[i-1], s0[i-1] - price[i])<br>s2[i] = s1[i-1] + price[i]</p><ul><li>参考代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">        const int n=prices.size();</span><br><span class="line">        if(n&lt;=1) return 0;</span><br><span class="line">        vector&lt;int&gt; s0(n,0);</span><br><span class="line">        vector&lt;int&gt; s1(n,0);</span><br><span class="line">        vector&lt;int&gt; s2(n,0);</span><br><span class="line">        s1[0]=-prices[0];</span><br><span class="line">        s0[0]=0;</span><br><span class="line">        s2[0]=INT_MIN;</span><br><span class="line">        for(int i=1;i&lt;n;i++) &#123;</span><br><span class="line">            s0[i]=max(s0[i-1],s2[i-1]);</span><br><span class="line">            s1[i]=max(s1[i-1],s0[i-1]-prices[i]);</span><br><span class="line">            s2[i]=s1[i-1]+prices[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return max(s0[n-1],s2[n-1]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="第六题"><a href="#第六题" class="headerlink" title="第六题"></a>第六题</h4><ul><li>描述：</li></ul><p>给一个数组和一个数，数组中的第i个元素代表第i天的股票价格，那个数代表交易费。如果允许完成多次交易（即多次买进股票并卖出股票），且每次交易需要支付交易费，那么最大收益是多少？</p><p>注意：不能同时进行多次交易，必须在再次买进股票前卖出股票。</p><ul><li>输入：</li></ul><p>一个数组prices（$0 &lt; prices.length \le 50000$，$0 &lt; prices[i] &lt; 50000$）和一个数fee（$0 \le fee &lt; 50000$），用空格分隔。</p><ul><li>输出：</li></ul><p>买卖股票的最大收益。</p><ul><li>输入样例：</li></ul><p>[1,3,2,8,4,9] 2</p><ul><li>输出样例：</li></ul><p>8</p><ul><li><p>说明：第一天买进，第四天卖出，第五天买进，第六天卖出，总共获得收益(8-1-2)+(9-4-2)=8。</p></li><li><p>解题思路：动态规划</p></li></ul><p>贪心法不行，当卖出的利润小于交易费时，不应该卖出，否则会亏损。</p><p>状态转移方程：<br>sold[i] = max(sold[i - 1], hold[i - 1] + prices[i] - fee)<br>hold[i] = max(hold[i - 1], sold[i - 1] - prices[i])</p><p>不管是卖出还是保留，第i天的利润只跟第i-1天有关系，所以可以优化空间，用两个变量来表示当前的卖出和保留的利润，</p><ul><li>参考代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProfit(vector&lt;int&gt;&amp; prices, int fee) &#123;</span><br><span class="line">        int sold=0,hold=-prices[0];</span><br><span class="line">        for(int price:prices) &#123;</span><br><span class="line">            int t=sold;</span><br><span class="line">            sold=max(sold,hold+price-fee);</span><br><span class="line">            hold=max(hold,t-price);</span><br><span class="line">        &#125;</span><br><span class="line">        return sold;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;第一题&quot;&gt;&lt;a href=&quot;#第一题&quot; class=&quot;headerlink&quot; title=&quot;第一题&quot;&gt;&lt;/a&gt;第一题&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;描述：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;给一个数组，数组中的第i个元素代表第i天的股票价格。如果只允许完全至多一次交易（即买进一股股票并卖出这股股票），那么最大收益是多少？&lt;/p&gt;
&lt;p&gt;注意：卖出股票的时间不能早于买进股票的时间。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://e99net.github.io/categories/Algorithm/"/>
    
    
      <category term="Dynamic Programming" scheme="https://e99net.github.io/tags/Dynamic-Programming/"/>
    
      <category term="Greedy" scheme="https://e99net.github.io/tags/Greedy/"/>
    
  </entry>
  
  <entry>
    <title>几道比较有意思的字符串题</title>
    <link href="https://e99net.github.io/2019/10/21/string/"/>
    <id>https://e99net.github.io/2019/10/21/string/</id>
    <published>2019-10-21T08:41:40.209Z</published>
    <updated>2020-12-20T13:35:39.928Z</updated>
    
    <content type="html"><![CDATA[<h4 id="整数反转求和"><a href="#整数反转求和" class="headerlink" title="整数反转求和"></a>整数反转求和</h4><ul><li>描述：</li></ul><p>请您写一个reverseAdd函数，该函数分别将输入的两个正整数a和b的数字按照高位在右的方式反转求和。<br>例如，reverseAdd(123,456)=321+654=975。</p><a id="more"></a><ul><li>输入：</li></ul><p>两个正整数a和b，以空格分隔，$1 \le a,b \le 70000$。</p><ul><li>输出：</li></ul><p>输出一个整数，表示两个正整数反转求和的结果。</p><ul><li>样例输入：</li></ul><p>123 456</p><ul><li>样例输出：</li></ul><p>975</p><ul><li>解题思路：</li></ul><p>按照int型来处理两个输入参数会比较麻烦，按照字符串类型来处理两个输入参数则会大大简化处理过程。</p><ul><li>参考代码:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    string n,m;</span><br><span class="line">    while(cin&gt;&gt;n&gt;&gt;m) &#123;</span><br><span class="line">        int x=0,y=0,i;</span><br><span class="line">        if(m[0]==&apos;0&apos;&amp;&amp;n[0]==&apos;0&apos;)</span><br><span class="line">            break;</span><br><span class="line">        for(i=m.size()-1;i&gt;=0;i--)</span><br><span class="line">            x=x*10+m[i]-&apos;0&apos;;</span><br><span class="line">        for(i=n.size()-1;i&gt;=0;i--)</span><br><span class="line">            y=y*10+n[i]-&apos;0&apos;;</span><br><span class="line">        cout&lt;&lt;x+y&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="字符串计数"><a href="#字符串计数" class="headerlink" title="字符串计数"></a>字符串计数</h4><ul><li>描述：</li></ul><p>给定一个仅由小写字母组成且长度不超过106的字符串，将首字符移到末尾并记录所得的字符串，不断重复该操作，虽然记录了无限个字符串，但其中不同字符串的数目却是有限的，那么一共记录了多少个不同的字符串？</p><ul><li>输入：</li></ul><p>给定的字符串。</p><ul><li>输出：</li></ul><p>记录的不同字符串数目。</p><ul><li>输入样例：</li></ul><p>abab</p><ul><li>输出样例：</li></ul><p>2</p><ul><li>解题思路：</li></ul><p>模板题，考查KMP算法next数组的求解</p><ul><li>参考代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=1000007;</span><br><span class="line">char s[N];</span><br><span class="line">int next[N];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    scanf(&quot;%s&quot;,s);</span><br><span class="line">    int n=strlen(s);</span><br><span class="line">    next[0]=-1;</span><br><span class="line">    for(int i=0,j=-1;i&lt;n;)</span><br><span class="line">        if(j==-1||s[i]=s[j]) next[++i]=++j;</span><br><span class="line">        else j=next[j];</span><br><span class="line">    if(n%(n-next[n])) printf(&quot;%d&quot;,n)</span><br><span class="line">    else printf(&quot;%d&quot;,n-next[n]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;整数反转求和&quot;&gt;&lt;a href=&quot;#整数反转求和&quot; class=&quot;headerlink&quot; title=&quot;整数反转求和&quot;&gt;&lt;/a&gt;整数反转求和&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;描述：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;请您写一个reverseAdd函数，该函数分别将输入的两个正整数a和b的数字按照高位在右的方式反转求和。&lt;br&gt;例如，reverseAdd(123,456)=321+654=975。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://e99net.github.io/categories/Algorithm/"/>
    
    
      <category term="String" scheme="https://e99net.github.io/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>背包问题总结</title>
    <link href="https://e99net.github.io/2019/10/21/knapsack/"/>
    <id>https://e99net.github.io/2019/10/21/knapsack/</id>
    <published>2019-10-21T03:51:37.001Z</published>
    <updated>2019-10-22T15:00:50.330Z</updated>
    
    <content type="html"><![CDATA[<h4 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0/1背包问题"></a>0/1背包问题</h4><ul><li>描述：</li></ul><p>有$N$件物品和一个容量是$V$的背包。</p><p>第$i$件物品的体积是$v_i$，价值是$w_i$。</p><p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。<br>输出最大价值。</p><a id="more"></a><ul><li>输入：</li></ul><p>第一行两个整数$N$和$V$，$0 &lt; N,V \le 1000$，用空格隔开，分别表示物品数量和背包容积。</p><p>接下来有$N$行，每行两个整数$v_i$和$w_i$，$0 &lt; v_i,w_i \le 1000$，用空格隔开，分别表示第$i$件物品的体积和价值。</p><ul><li>输出：</li></ul><p>输出一个整数，表示最大价值。</p><ul><li>样例输入：</li></ul><p>4 5<br>1 2<br>2 4<br>3 4<br>4 5</p><ul><li>样例输出：</li></ul><p>8</p><ul><li>参考代码:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=1010;</span><br><span class="line">int n,m;</span><br><span class="line">int f[N];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(int i=0;i&lt;n;i++) &#123;</span><br><span class="line">        int c,w;</span><br><span class="line">        cin&gt;&gt;c&gt;&gt;w;</span><br><span class="line">        for(int j=m;j&gt;=c;j--)</span><br><span class="line">            f[j]=max(f[j],f[j-c]+w);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[m]&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h4><ul><li>描述：</li></ul><p>有$N$种物品和一个容量是$V$的背包，每种物品都有无限件可用。</p><p>第$i$种物品的体积是$v_i$，价值是$w_i$。</p><p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。<br>输出最大价值。</p><!-- more --><ul><li>输入：</li></ul><p>第一行两个整数$N$和$V$，$0 &lt; N,V \le 1000$，用空格隔开，分别表示物品种数和背包容积。</p><p>接下来有$N$行，每行两个整数$v_i$和$w_i$，$0 &lt; v_i,w_i \le 1000$，用空格隔开，分别表示第$i$种物品的体积和价值。</p><ul><li>输出：</li></ul><p>输出一个整数，表示最大价值。</p><ul><li>样例输入：</li></ul><p>4 5<br>1 2<br>2 4<br>3 4<br>4 5</p><ul><li>样例输出：</li></ul><p>10</p><ul><li>参考代码:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=1010;</span><br><span class="line">int n,m;</span><br><span class="line">int f[N];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cin&gt;n&gt;&gt;m;</span><br><span class="line">    for(int i=0;i&lt;n;i++) &#123;</span><br><span class="line">        int c,w;</span><br><span class="line">        cin&gt;&gt;c&gt;&gt;w;</span><br><span class="line">        for(int j=c;j&lt;=m;j++)</span><br><span class="line">            f[j]=max(f[j],f[j-c]+w);</span><br><span class="line">    &#125;</span><br><span class="line">    int res=0;</span><br><span class="line">    for(int i=0;i&lt;=m;i++) res=max(res,f[i]);</span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多重背包问题"><a href="#多重背包问题" class="headerlink" title="多重背包问题"></a>多重背包问题</h4><ul><li>描述：</li></ul><p>有$N$种物品和一个容量是$V$的背包。</p><p>第$i$种物品最多有$s_i$件，每件体积是$v_i$，价值是$w_i$。</p><p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且价值总和最大。<br>输出最大价值。</p><!-- more --><h5 id="暴力-O-N-M-S"><a href="#暴力-O-N-M-S" class="headerlink" title="暴力 O(N*M*S)"></a>暴力 O(N*M*S)</h5><ul><li>输入：</li></ul><p>第一行两个整数$N$和$V$，$0 &lt; N,V \le 100$，用空格隔开，分别表示物品种数和背包容积。</p><p>接下来有$N$行，每行三个整数$v_i$、$w_i$和$s_i$，$0 &lt; v_i,w_i,s_i \le 100$，用空格隔开，分别表示第$i$件物品的体积、价值和数量。</p><ul><li>输出：</li></ul><p>输出一个整数，表示最大价值。</p><ul><li>样例输入：</li></ul><p>4 5<br>1 2 3<br>2 4 1<br>3 4 3<br>4 5 2</p><ul><li>样例输出：</li></ul><p>10</p><ul><li>参考代码:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=110;</span><br><span class="line"></span><br><span class="line">int n,m;</span><br><span class="line">int f[N];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(int i=0;i&lt;n;i++) &#123;</span><br><span class="line">        int c,w,s;</span><br><span class="line">        cin&gt;&gt;c&gt;&gt;w&gt;&gt;s;</span><br><span class="line">        for(int j=m;j&gt;=0;j--)</span><br><span class="line">            for(int k=1;k&lt;=s;k++)</span><br><span class="line">                if(j&gt;=k*c)</span><br><span class="line">                    f[j]=max(f[j],f[j-k*c]+k*w);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[m]&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="二进制优化-O-N-M-log-S"><a href="#二进制优化-O-N-M-log-S" class="headerlink" title="二进制优化 O(N*M*log S)"></a>二进制优化 O(N*M*log S)</h5><ul><li>输入：</li></ul><p>第一行两个整数$N$和$V$，$0 &lt; N \le 1000$，$0 &lt; V \le 2000$，用空格隔开，分别表示物品种数和背包容积。</p><p>接下来有$N$行，每行三个整数$v_i$、$w_i$和$s_i$，$0 &lt; v_i,w_i,s_i \le 2000$，用空格隔开，分别表示第$i$件物品的体积、价值和数量。</p><ul><li>输出：</li></ul><p>输出一个整数，表示最大价值。</p><ul><li>样例输入：</li></ul><p>4 5<br>1 2 3<br>2 4 1<br>3 4 3<br>4 5 2</p><ul><li>样例输出：</li></ul><p>10</p><ul><li>参考代码:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=2010;</span><br><span class="line"></span><br><span class="line">int n,m;</span><br><span class="line">int f[N];</span><br><span class="line">struct Good &#123;</span><br><span class="line">    int v,w;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;Good&gt; goods;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(int i=0;i&lt;n;i++) &#123;</span><br><span class="line">        int v,w,s;</span><br><span class="line">        cin&gt;&gt;v&gt;&gt;w&gt;&gt;s;</span><br><span class="line">        for(int k=1;j&lt;=s;k*=2) &#123;</span><br><span class="line">            s-=k;</span><br><span class="line">            goods.push_back(&#123;v*k,w*k&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        if(s&gt;0) goods.push_back(&#123;v*s,w*s&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    for(auto good:goods)</span><br><span class="line">        for(int j=m;j&gt;=good.v;j--)</span><br><span class="line">            f[j]=max(f[j],f[j-good.v]+good.w);</span><br><span class="line">    cout&lt;&lt;f[m]&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="单调队列优化-O-N-M"><a href="#单调队列优化-O-N-M" class="headerlink" title="单调队列优化 O(N*M)"></a>单调队列优化 O(N*M)</h5><ul><li>输入：</li></ul><p>第一行两个整数$N$和$V$，$0 &lt; N \le 1000$，$0 &lt; V \le 20000$，用空格隔开，分别表示物品种数和背包容积。</p><p>接下来有$N$行，每行三个整数$v_i$、$w_i$和$s_i$，$0 &lt; v_i,w_i,s_i \le 20000$，用空格隔开，分别表示第$i$件物品的体积、价值和数量。</p><ul><li>输出：</li></ul><p>输出一个整数，表示最大价值。</p><ul><li>样例输入：</li></ul><p>4 5<br>1 2 3<br>2 4 1<br>3 4 3<br>4 5 2</p><ul><li>样例输出：</li></ul><p>10</p><ul><li>参考代码:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=20010;</span><br><span class="line"></span><br><span class="line">int n,m;</span><br><span class="line">int f[N],g[N],q[N];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(int i=0;i&lt;n;i++) &#123;</span><br><span class="line">        int c,w,s;</span><br><span class="line">        cin&gt;&gt;c&gt;&gt;w&gt;&gt;s;</span><br><span class="line">        memcpy(g,f,sizeof f);</span><br><span class="line"></span><br><span class="line">        for(int j=0;j&lt;c;j++) &#123;</span><br><span class="line">            int hh=0,tt=-1;</span><br><span class="line">            for(int k=j;k&lt;=m;k+=c) &#123;</span><br><span class="line">                f[k]=g[k];</span><br><span class="line">                if(hh&lt;=tt&amp;&amp;k-s*c&gt;q[hh]) hh++;</span><br><span class="line">                if(hh&lt;=tt) f[k]=max(f[k],g[q[hh]]+(k-q[hh])/c*w);</span><br><span class="line">                while(hh&lt;=tt&amp;&amp;g[q[tt]]-(q[tt]-j)/c*w&lt;=g[k]-(k-j)/c*w) tt--;</span><br><span class="line">                q[++tt]=k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[m]&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="混合背包问题"><a href="#混合背包问题" class="headerlink" title="混合背包问题"></a>混合背包问题</h4><ul><li>描述：</li></ul><p>有$N$种物品和一个容量是$V$的背包。</p><p>物品一共有三类：</p><ul><li>第一类物品只能用1次（01背包）</li><li>第二类物品可以用无限次（完全背包）</li><li>第三类物品最多只能用$s_i$次（多重背包）</li></ul><p>每种体积是$v_i$，价值是$w_i$。</p><p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且价值总和最大。<br>输出最大价值。</p><!-- more --><ul><li>输入：</li></ul><p>第一行两个整数$N$和$V$，$0 &lt; N,V \le 1000$，用空格隔开，分别表示物品数量和背包容积。</p><p>接下来有$N$行，每行三个整数$v_i$、$w_i$和$s_i$，用空格隔开，分别表示第$i$件物品的体积、价值和数量。</p><p>$0 &lt; v_i,w_i \le 1000$，$-1 \le s_i \le 1000$。</p><ul><li>$s_i=-1$表示第$i$种物品只能用1次</li><li>$s_i=0$表示第$i$种物品可以用无限次</li><li>$s_i&gt;0$表示第$i$种物品可以使用$s_i$次</li></ul><ul><li>输出：</li></ul><p>输出一个整数，表示最大价值。</p><ul><li>样例输入：</li></ul><p>4 5<br>1 2 -1<br>2 4 1<br>3 4 0<br>4 5 2</p><ul><li>样例输出：</li></ul><p>8</p><ul><li>参考代码:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=1010;</span><br><span class="line"></span><br><span class="line">int n,m;</span><br><span class="line">int f[N];</span><br><span class="line"></span><br><span class="line">struct Thing &#123;</span><br><span class="line">    int kind;</span><br><span class="line">    int v,w;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Thing&gt; things;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(int i=0;i&lt;n;i++) &#123;</span><br><span class="line">        int v,w,s;</span><br><span class="line">        cin&gt;&gt;v&gt;&gt;w&gt;&gt;s;</span><br><span class="line">        if(s&lt;0) things.push_back(&#123;-1,v,w&#125;);</span><br><span class="line">        else if(s==0) things.push_back(&#123;0,v,w&#125;);</span><br><span class="line">        else &#123;</span><br><span class="line">            for(int k=1;k&lt;=s;k*=2) &#123;</span><br><span class="line">                s-=k;</span><br><span class="line">                things.push_back(&#123;-1,v*k,w*k&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            if(s&gt;0)things.push_back(&#123;-1,v*s,w*s&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(auto thing : things) &#123;</span><br><span class="line">        if(thing.kind&lt;0) &#123;</span><br><span class="line">            for(int j=m;j&gt;=thing.v;j--) f[j]=max(f[j],f[j-thing.v]+thing.w);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            for(int j=thing.v;j&lt;=m;j++) f[j]=max(f[j],f[j-thing.v]+thing.w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[m]&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二维费用的背包问题"><a href="#二维费用的背包问题" class="headerlink" title="二维费用的背包问题"></a>二维费用的背包问题</h4><ul><li>描述：</li></ul><p>有$N$件物品和一个容量是$V$的背包，背包能承受的最大重量是$M$。</p><p>每件物品只能用一次。体积是$v_i$，重量是$m_i$，价值是$w_i$。</p><p>求解将哪些物品装入背包，可使物品总体积不超过背包容量，总重量不超过背包可承受的最大重量，且价值总和最大。<br>输出最大价值。</p><!-- more --><ul><li>输入：</li></ul><p>第一行三个整数$N$、$V$和$M$，$0 &lt; N \le 1000$，$0 &lt; V,M \le 100$，用空格隔开，分别表示物品件数、背包容积和背包可承受的最大重量。</p><p>接下来有$N$行，每行三个整数$v_i$、$m_i$和$w_i$，$0 &lt; v_i,m_i \le 100$，$0 &lt; w_i \le 1000$，用空格隔开，分别表示第$i$件物品的体积、重量和价值。</p><ul><li>输出：</li></ul><p>输出一个整数，表示最大价值。</p><ul><li>样例输入：</li></ul><p>4 5 6<br>1 2 3<br>2 4 4<br>3 4 5<br>4 5 6</p><ul><li>样例输出：</li></ul><p>8</p><ul><li>参考代码:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=110;</span><br><span class="line"></span><br><span class="line">int n,v,m;</span><br><span class="line">int f[N][N];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;v&gt;&gt;m;</span><br><span class="line">    for(int i=0;i&lt;n;i++) &#123;</span><br><span class="line">        int a,b,c;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">        for(int j=v;j&gt;=a;j--)</span><br><span class="line">            for(int k=m;k&gt;=b;k--)</span><br><span class="line">                f[j][k]=max(f[j][k],f[j-a][k-b]+c);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[v][m]&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="分组背包问题"><a href="#分组背包问题" class="headerlink" title="分组背包问题"></a>分组背包问题</h4><ul><li>描述：</li></ul><p>有$N$组物品和一个容量是$V$的背包。</p><p>每组物品有若干个，同一组内的物品最多只能选一个。</p><p>每件物品的体积是$v_{ij}$，价值是$w_{ij}$，其中$i$是组号，$j$是组内编号。</p><p>求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。</p><p>输出最大价值。</p><!-- more --><ul><li>输入：</li></ul><p>第一行有两个整数$N$和$V$，$0 &lt; N,V \le 100$，用空格隔开，分别表示物品组数和背包容量。</p><p>接下来有$N$组数据：</p><ul><li>每组数据第一行有一个整数$S_i$，$0 &lt; S_i \le 100$，表示第$i$个物品组的物品数量；</li><li>每组数据接下来有$S_i$行，每行有两个整数$v_{ij}$和$w_{ij}$，$0 &lt; v_{ij},w_{ij} \le 100$，用空格隔开，分别表示第$i$个物品组的第$j$个物品的体积和价值。</li></ul><ul><li>输出：</li></ul><p>输出一个整数，表示最大价值。</p><ul><li>样例输入：</li></ul><p>3 5<br>2<br>1 2<br>2 4<br>1<br>3 4<br>1<br>4 5</p><ul><li>样例输出：</li></ul><p>8</p><ul><li>参考代码:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=110;</span><br><span class="line"></span><br><span class="line">int n,m;</span><br><span class="line">int f[N],v[N],w[N];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(int i=0;i&lt;n;i++) &#123;</span><br><span class="line">        int s;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        for(int j=0;j&lt;s;j++) cin&gt;&gt;v[j]&lt;&lt;w[j];</span><br><span class="line">        for(int j=m;j&gt;=0;j--)</span><br><span class="line">            for(int k=0;k&lt;s;k++)</span><br><span class="line">                if(j&gt;=v[k])</span><br><span class="line">                    f[j]=max(f[j],f[j-v[k]]+w[k]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[m]&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="背包问题求方案数"><a href="#背包问题求方案数" class="headerlink" title="背包问题求方案数"></a>背包问题求方案数</h4><ul><li>描述：</li></ul><p>有$N$件物品和一个容量是$V$的背包，每件物品只能使用一次。</p><p>第$i$件物品的体积是$v_i$，价值是$w_i$。</p><p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。</p><p>输出<strong>最优选法的方案数</strong>，注意答案可能很大，请输出答案模$10^9+7$的结果。</p><!-- more --><ul><li>输入：</li></ul><p>第一行两个整数$N$和$V$，$0 &lt; N,V \le 1000$，用空格隔开，分别表示物品数量和背包容积。</p><p>接下来有$N$行，每行两个整数$v_i$和$w_i$，$0 &lt; v_i,w_i \le 1000$，用空格隔开，分别表示第$i$件物品的体积和价值。</p><ul><li>输出：</li></ul><p>输出一个整数，表示方案数模$10^9+7$的结果。</p><ul><li>样例输入：</li></ul><p>4 5<br>1 2<br>2 4<br>3 4<br>4 6</p><ul><li>样例输出：</li></ul><p>2</p><ul><li>参考代码:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=1010,mod=1000000009,INF=1000000;</span><br><span class="line">int n,m;</span><br><span class="line">int f[N],g[N];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    g[0]=1;</span><br><span class="line">    for(int i=1;i&lt;=m;i++) f[i]=-INF;</span><br><span class="line">    for(int i=0;i&lt;n;i++) &#123;</span><br><span class="line">        int v,w;</span><br><span class="line">        cin&gt;&gt;v&gt;&gt;w;</span><br><span class="line">        for(int j=m;j&gt;=v;j--) &#123;</span><br><span class="line">            int t=max(f[j],f[j-v]+w);</span><br><span class="line">            int s=0;</span><br><span class="line">            if(t==f[j])s+=g[j];</span><br><span class="line">            if(t==f[j-v]+w)s+=g[j-v];</span><br><span class="line">            if(s&gt;=mod)s-=mod;</span><br><span class="line">            f[j]=t;</span><br><span class="line">            g[j]=s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int maxw=0;</span><br><span class="line">    for(int i=0;i&lt;=m;i++) maxw=max(maxw,f[i]);</span><br><span class="line">    int res=0;</span><br><span class="line">    for(int i=0;i&lt;=m;i++)</span><br><span class="line">        if(maxw==f[i]) &#123;</span><br><span class="line">            res+=g[i];</span><br><span class="line">            if(res&gt;=mod) res-=mod;</span><br><span class="line">        &#125;</span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="求背包问题的方案"><a href="#求背包问题的方案" class="headerlink" title="求背包问题的方案"></a>求背包问题的方案</h4><ul><li>描述：</li></ul><p>有$N$件物品和一个容量是$V$的背包，每件物品只能使用一次。</p><p>第$i$件物品的体积是$v_i$，价值是$w_i$。</p><p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。</p><p>输出<strong>字典序最小的方案</strong>。这里的字典序是指：所选物品的编号所构成的序列。物品的编号范围是$1…N$。</p><!-- more --><ul><li>输入：</li></ul><p>第一行两个整数$N$和$V$，$0 &lt; N,V \le 1000$，用空格隔开，分别表示物品数量和背包容积。</p><p>接下来有$N$行，每行两个整数$v_i$和$w_i$，$0 &lt; v_i,w_i \le 1000$，用空格隔开，分别表示第$i$件物品的体积和价值。</p><ul><li>输出：</li></ul><p>输出一行，包含若干个用空格隔开的整数，表示最优解中所选物品的编号序列，且该编号序列的字典序最小。</p><p>物品编号范围是$1…N$。</p><ul><li>样例输入：</li></ul><p>4 5<br>1 2<br>2 4<br>3 4<br>4 6</p><ul><li>样例输出：</li></ul><p>1 4</p><ul><li>参考代码:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=1010;</span><br><span class="line"></span><br><span class="line">int n,m;</span><br><span class="line">int v[N],w[N],f[N][N];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(int i=1;i&lt;=n;i++) cin&gt;&gt;v[i]&gt;&gt;w[i];</span><br><span class="line">    for(int i=n;i&gt;=1;i--) &#123;</span><br><span class="line">        for(int j=0;j&lt;=m;j++) &#123;</span><br><span class="line">            f[i][j]=f[i+1][j];</span><br><span class="line">            if(j&gt;=v[i]) f[i][j]=max(f[i][j],f[i+1][j-v[i]]+w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int vol=m;</span><br><span class="line">    for(int i=1;i&lt;=n;i++) &#123;</span><br><span class="line">        if(f[i][vol]==f[i+1][vol-v[i]]+w[i]) &#123;</span><br><span class="line">            cout&lt;&lt;i&lt;&lt;&apos; &apos;;</span><br><span class="line">            vol-=v[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="有依赖的背包问题"><a href="#有依赖的背包问题" class="headerlink" title="有依赖的背包问题"></a>有依赖的背包问题</h4><h5 id="非树形依赖的背包问题"><a href="#非树形依赖的背包问题" class="headerlink" title="非树形依赖的背包问题"></a>非树形依赖的背包问题</h5><ul><li>描述：</li></ul><p>金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间金明自己专用的很宽敞的房间。更让他高兴的是，妈妈昨天对他说：“你的房间需要购买哪些物品，怎么布置，你说了算，只要不超过$N$元钱就行”。今天一早，金明就开始做预算了，他把想买的物品分为两类：主件与附件，附件是从属于某个主件的，下表就是一些主件与附件的例子：</p><p>|主件| 附件|</p><p>|电脑| 打印机，扫描仪|</p><p>|书柜| 图书|</p><p>|书桌| 台灯，文具|</p><p>|工作椅| 无|</p><p>如果要买归类为附件的物品，必须先买该附件所属的主件。每个主件可以有0个、1个或2个附件。附件不再有从属于自己的附件。金明想买的东西很多，肯定会超过妈妈限定的$N$元。于是，他把每件物品规定了一个重要度，分为5等：用整数1−5表示，第5等最重要。他还从因特网上查到了每件物品的价格（都是10元的整数倍）。他希望在不超过$N$元（可以等于$N$元）的前提下，使每件物品的价格与重要度的乘积的总和最大。</p><p>设第$j$件物品的价格为$v_[j]$，重要度为$w_[j]$，共选中了$k$件物品，编号依次为$j_1,j_2,…,j_k$，则所求的总和为：<br>$$v_[j_1] \times w_[j_1]+v_[j_2] \times w_[j_2]+ …+v_[j_k] \times w_[j_k]$$</p><p>请你帮助金明设计一个满足要求的购物单。</p><ul><li>输入：</li></ul><p>第1行为两个正整数$n$和$m$，分别表示总钱数和希望购买物品的个数，$n&lt;32000$，$m&lt;60$，用空格隔开。</p><p>从第2行到第$m+1$行，第$j$行给出了编号为$j-1$的物品的基本数据，每行有3个非负整数$v$、$p$、$q$，分别表示该物品的价格、重要度（1-5）、是主件还是附件，$q=0$表示该物品为主件，$q&gt;0$表示该物品为附件且$q$是所属主件的编号，$v&lt;10000$。</p><ul><li>输出：</li></ul><p>一个正整数，为不超过总钱数的物品的价格与重要度乘积的总和的最大值。</p><ul><li>样例输入：</li></ul><p>1000 5<br>800 2 0<br>400 5 1<br>300 5 1<br>400 3 0<br>500 2 0</p><ul><li>样例输出：</li></ul><p>2200</p><ul><li><p>解题思路：分组背包</p></li><li><p>参考代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h5 id="树形依赖的背包问题"><a href="#树形依赖的背包问题" class="headerlink" title="树形依赖的背包问题"></a>树形依赖的背包问题</h5><ul><li>描述：</li></ul><p>有$N$个物品和一个容量是$V$的背包。</p><p>物品之间具有依赖关系，且依赖关系组成一棵树的形状。如果选择一个物品，则必须选择它的父节点。</p><!-- more --><p>如下图所示：</p><p><img src="/2019/10/21/knapsack/2019-10-21_122422.jpg" alt=""></p><p>如果选择物品5，则必须选择物品1和2。这是因为2是5的父节点，1是2的父节点。</p><p>每件物品的编号是$i$，体积是$v_i$，价值是$w_i$，依赖的父节点编号是$p_i$，物品的下标范围是$1…N$。</p><p>求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。</p><p>输出最大价值。</p><ul><li>输入：</li></ul><p>第一行两个整数$N$和$V$，$1 \le N,V \le 100$，用空格隔开，分别表示物品个数和背包容量。</p><p>接下来有$N$行数据，每行数据表示一个物品。<br>第$i$行有三个整数$v_i$,$w_i$,$p_i$，$1 &lt; v_i,w_i \le 100$，用空格隔开，分别表示物品的体积、价值和依赖的物品编号。<br>$p_i==-1$表示根节点，$1 \le p_i \le N$表示内部节点，数据保证所有物品构成一棵树。</p><ul><li>输出：</li></ul><p>输出一个整数，表示最大价值。</p><ul><li>样例输入：</li></ul><p>5 7<br>2 3 -1<br>2 2 1<br>3 5 1<br>4 7 2<br>3 6 2</p><ul><li>样例输出：</li></ul><p>11</p><ul><li><p>解题思路：分组背包+树形dp</p></li><li><p>参考代码:</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=110;</span><br><span class="line">int n,m;</span><br><span class="line">int h[N],e[N],ne[N],idx;</span><br><span class="line">int v[N],w[N],f[N][N];</span><br><span class="line">void add(int a,int b) &#123;</span><br><span class="line">    e[idx]=b,ne[idx]=h[a],h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line">void dfs(int u) &#123;</span><br><span class="line">    for(int i=h[u];i!=-1;i=ne[i]) &#123;</span><br><span class="line">        int son=e[i];</span><br><span class="line">        dfs(son);</span><br><span class="line">        for(int j=m-v[u];j&gt;=0;j--)</span><br><span class="line">            for(int k=0;k&lt;=j;k++)</span><br><span class="line">                f[u][j]=max(f[u][j],f[u][j-k]+f[son][k]);</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=m;i&gt;=v[u];i--) f[u][i]=f[u][i-v[u]]+w[u];</span><br><span class="line">    for(int i=0;i&lt;v[u];i++) f[u][i]=0;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    memset(h,-1,sizeof h);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    int root;</span><br><span class="line">    for(int i=1;i&lt;=n;i++) &#123;</span><br><span class="line">        int p;</span><br><span class="line">        cin&gt;&gt;v[i]&gt;&gt;w[i]&gt;&gt;p;</span><br><span class="line">        if(p==-1) root=i;</span><br><span class="line">        else add(p,i);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root);</span><br><span class="line">    cout&lt;&lt;f[root][m]&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;0-1背包问题&quot;&gt;&lt;a href=&quot;#0-1背包问题&quot; class=&quot;headerlink&quot; title=&quot;0/1背包问题&quot;&gt;&lt;/a&gt;0/1背包问题&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;描述：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有$N$件物品和一个容量是$V$的背包。&lt;/p&gt;
&lt;p&gt;第$i$件物品的体积是$v_i$，价值是$w_i$。&lt;/p&gt;
&lt;p&gt;求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。&lt;br&gt;输出最大价值。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://e99net.github.io/categories/Algorithm/"/>
    
    
      <category term="Knapsack" scheme="https://e99net.github.io/tags/Knapsack/"/>
    
  </entry>
  
  <entry>
    <title>记一道算法编程题</title>
    <link href="https://e99net.github.io/2019/10/21/meituan2019/"/>
    <id>https://e99net.github.io/2019/10/21/meituan2019/</id>
    <published>2019-10-21T03:33:49.258Z</published>
    <updated>2019-10-21T03:50:09.279Z</updated>
    
    <content type="html"><![CDATA[<h4 id="爱健身的小王"><a href="#爱健身的小王" class="headerlink" title="爱健身的小王"></a>爱健身的小王</h4><ul><li>描述：</li></ul><p>小王是一个喜欢健身的人，他每天都会围着一个n*n的场地外侧跑步。<br>他是一个有强迫症的人，每跑n+1个单位长度，他就要在地上做一个标记。<br>当他在一个点重复标记的时候，他就会结束当天的锻炼。<br>显然当n一定时，他每天打标记的数量也是一定的。请你计算出来他每天要打多少标记（最后一次重复标记也要计数）。</p><a id="more"></a><ul><li>输入：</li></ul><p>第一行包含一个正整数t，表示询问的数量。</p><p>第二行包含t个整数，中间用空格隔开，每个整数表示一个询问所给出的n，$1 \le n \le 1000$。</p><ul><li>输出：</li></ul><p>输出共t行，$1 \le t \le 10000$。</p><p>每行包含一个正整数，其中第i行的整数表示第i个询问的答案。</p><ul><li>样例输入：</li></ul><p>2<br>4 8</p><ul><li>样例输出：</li></ul><p>17<br>33</p><ul><li>样例解释：</li></ul><p>对于4*4的场地而言，其边界上的16个点都会被标记，因为起点会被标记两次，所以共17次。</p><ul><li><p>解题思路：最小公倍数</p></li><li><p>参考代码:</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int gcd(int a,int b)&#123;</span><br><span class="line">    return b?gcd(b,a%b):a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int T;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    while(T--) &#123;</span><br><span class="line">        int n;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        int d=gcd(4*n,n+1);</span><br><span class="line">        cout&lt;&lt;4*n/d+1&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;爱健身的小王&quot;&gt;&lt;a href=&quot;#爱健身的小王&quot; class=&quot;headerlink&quot; title=&quot;爱健身的小王&quot;&gt;&lt;/a&gt;爱健身的小王&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;描述：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;小王是一个喜欢健身的人，他每天都会围着一个n*n的场地外侧跑步。&lt;br&gt;他是一个有强迫症的人，每跑n+1个单位长度，他就要在地上做一个标记。&lt;br&gt;当他在一个点重复标记的时候，他就会结束当天的锻炼。&lt;br&gt;显然当n一定时，他每天打标记的数量也是一定的。请你计算出来他每天要打多少标记（最后一次重复标记也要计数）。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://e99net.github.io/categories/Algorithm/"/>
    
    
      <category term="Number theory" scheme="https://e99net.github.io/tags/Number-theory/"/>
    
  </entry>
  
  <entry>
    <title>记五道2020年某企业提前批招聘笔试题</title>
    <link href="https://e99net.github.io/2019/10/07/netease/"/>
    <id>https://e99net.github.io/2019/10/07/netease/</id>
    <published>2019-10-07T02:44:38.279Z</published>
    <updated>2019-11-10T12:15:01.370Z</updated>
    
    <content type="html"><![CDATA[<h4 id="窗口点击模拟"><a href="#窗口点击模拟" class="headerlink" title="窗口点击模拟"></a>窗口点击模拟</h4><ul><li>描述：</li></ul><p>本题需要让你模拟一下在Windows系统里窗囗和鼠标点击的操作，具体如下：</p><ol><li>屏幕分辨率为3840 * 2160，左上角坐标为（0，0），右下角坐标为（3839，2159）</li><li>窗口是一个矩形的形状，由左上角坐标（X，Y），和宽高（W，H），四个数字来定位。左上角坐标为（X，Y）、右下角坐标为（X+W，Y+H），其中左上角坐标一定会在屏幕范围内，其他一些部分可能会超过屏幕范围。</li><li>窗囗的点击和遮挡规则同Windows，但是不考虑关闭窗囗、最大化、最小化和强制置顶的情况。即<br> 3.1 如果发生重叠的话，后面打开的窗口会显示在前面打开的窗口上面<br> 3.2 当鼠标发生一次点击的时候，需要判断点击到了哪个窗口，如果同个坐标有多个窗口，算点击到最上层的那个<br> 3.3 当一个窗囗被点击的时候，会浮动到最上层</li></ol><a id="more"></a><ul><li>输入：</li></ul><p>每个测试输入包含1个测试用例<br>第一行为2个整数N，M。其中N表示打开的窗口数目，M表示鼠标点击的数目，0&lt;N，M&lt;1000<br>接下来N行，每一行四个整数Xi Yi Wi Hi，分别表示第i个窗口（窗口Id为i，从1开始计数）的左上角坐标以及宽高，初始时窗口是按输入的顺序依次打开。其中0&lt;=Xi&lt;3840，0&lt;=Yi&lt;2160，0&lt;Wi&lt;3840，0&lt;Hi&lt;2160<br>再接下来有M行，每一行两个整数xj Yj，分别表示接下来发生的鼠标点击坐标。其中0&lt;=Xj&lt;3840，0&lt;=Yj&lt;2160</p><ul><li>输出：</li></ul><p>对于每次鼠标点击，输出本次点击到的窗口Id。如果没有点击到窗口，输出-1</p><ul><li>样例输入：</li></ul><p>2 4<br>100 100 100 100<br>10 10 150 150<br>105 105<br>180 180<br>105 105<br>1 1</p><ul><li>样例输出：</li></ul><p>2<br>1<br>1<br>-1</p><ul><li>样例说明：</li></ul><p>有2个窗口，第1个窗口左上角坐标为(100,100)，宽和高都是100，则其右下角坐标为(200,200)；<br>第2个窗口左上角坐标为(10,10)，宽和高都是150，则其右下角坐标为(160,160)。</p><p>有4次鼠标点击，第1次点击的位置同时属于1号和2号窗口，但由于2号窗口在上面，所以它被选择并且被置于顶层；<br>第2次点击的位置只属于1号窗口，因此该次点击选择了1号窗口并将其置于顶层，现在1号窗口在上，2号窗口在下；<br>第3次点击的位置同时属于1号和2号窗口的范围，但由于1号窗口在上，所以它被选择；<br>第4次点击的位置不属于任何窗口。</p><ul><li>解题思路：模拟</li></ul><p>用一个结构体数组存给出的窗口信息，根据题意，数组中越靠后的窗口优先级越高，因此，每次点击从数字后面开始扫描，扫到满足点击的窗口就输出对应的编号，并将它提到末尾。</p><ul><li>参考代码:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=1010;</span><br><span class="line">const int M=1010;</span><br><span class="line">int n,m;</span><br><span class="line"></span><br><span class="line">struct win &#123;</span><br><span class="line">    int id,x,y,w,h;</span><br><span class="line">&#125;wins[N];//存窗口的结构体数组</span><br><span class="line"></span><br><span class="line">//将窗口i置于顶层</span><br><span class="line">void top(int i) &#123;</span><br><span class="line">    win t=wins[i];</span><br><span class="line">    for(;i&lt;n-1;i++) wins[i]=wins[i+1];</span><br><span class="line">    wins[n-1]=t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">    for(int i=0;i&lt;n;i++) &#123;</span><br><span class="line">        scanf(&quot;%d%d%d%d&quot;,&amp;wins[i].x,&amp;wins[i].y,&amp;wins[i].w,&amp;wins[i].h);</span><br><span class="line">        wins[i].id=i+1;</span><br><span class="line">    &#125;</span><br><span class="line">    while(m--) &#123;</span><br><span class="line">        int dx,dy,flag=0;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;dx,&amp;dy);</span><br><span class="line">        for(int i=n-1;i&gt;=0;i--) &#123;</span><br><span class="line">            //判断鼠标点击范围</span><br><span class="line">            if(dx&gt;=wins[i].x&amp;&amp;dy&gt;=wins[i].y&amp;&amp;dx&lt;=wins[i].x+wins[i].w&amp;&amp;dy&lt;=wins[i].y+wins[i].h) &#123;</span><br><span class="line">                printf(&quot;%d\n&quot;,wins[i].id);</span><br><span class="line">                top(i);</span><br><span class="line">                flag=1;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(!flag) printf(&quot;-1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Stern-Brocot-tree"><a href="#Stern-Brocot-tree" class="headerlink" title="Stern-Brocot tree"></a>Stern-Brocot tree</h4><ul><li>描述：</li></ul><p>The Stern-Brocot tree is an infinite complete binary tree in which the vertices correspond one-for-one to the positive rational numbers, whose values are ordered from the left to the right as in a search tree.</p><p><img src="/2019/10/07/netease/001.jpg" alt=""></p><p>Figure 1 shows a part of the Stern-Brocot tree, which has thefirst 4 rows. Each node in the tree is marked in a red cycle. The value in the node is the mediant of the left and right fractions. The mediant of two fractions A/B and C/D is defined as(A+C)/(B+D).<br>To construct the Stern-Brocot tree, we first define the left fraction of the root node is 0/1, and the right fraction of the root node is 1/0. So the value in the root node is the mediant of 0/1 and 1/0, which is(0+1)/(1+0)=1/1. Then the value of root node becomes the right fraction of the left child, and the left fraction of the right child. For example, the 1st node in row2 has 0/1 as its left fraction and 1/1(which is the value of its parent node) as its right fraction. So the value of the 1st node in row2 is (0+1)/(1+1)=1/2. For the same reason, the value of the 2nd node in row2 is (1+1)/(1+0)=2/1. This construction progress goes on infinitly. As a result, everypositive rational number can be found on the Stern-Brocot tree, and can be found only once.<br>Given a rational number in form of P/Q, find the position of P/Q in the Stern-Brocot Tree.</p><ul><li>输入：</li></ul><p>Input consists of two integers,P and Q<br>(1&lt;=P,Q&lt;=1000), which represent the rational number P/Q. We promise P and Q are relatively prime.</p><ul><li>输出：</li></ul><p>Output consists of two integers,R and C.<br>R indicates the row index of P/Q in the stern-Brocot Tree,C indicates the index of P/Q in the row.<br>Both B and C are base 1.<br>We promise the position of P/Q is always in the first 12 rows of the Stern-Brocot tree, which means R&lt;=12.</p><ul><li>样例输入：</li></ul><p>5 3</p><ul><li>样例输出：</li></ul><p>4 6</p><ul><li><p>解题思路：数学+二分</p></li><li><p>参考程序：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct Fraction &#123;</span><br><span class="line">    int m,n;</span><br><span class="line">&#125;sl,sr,input;</span><br><span class="line">int row,col;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int summ,sumn;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;input.m,&amp;input.n);</span><br><span class="line">    if(input.m!=1||input.n!=1) &#123;</span><br><span class="line">       //string ans;</span><br><span class="line">       sl.m=0,sr.m=1;</span><br><span class="line">       sl.n=1,sr.n=0;</span><br><span class="line">       row=1;</span><br><span class="line">       col=1;</span><br><span class="line">       while(1)&#123;</span><br><span class="line">            summ=sl.m+sr.m;</span><br><span class="line">            sumn=sl.n+sr.n;</span><br><span class="line">            int temp=input.m*sumn-input.n*summ;</span><br><span class="line">            if(temp&gt;0)&#123; // input.m/input.n&gt;summ/sumn --&gt; input.m*sumn-input.n*summ&gt;0</span><br><span class="line">                // ans+=&apos;R&apos;;</span><br><span class="line">                row++;</span><br><span class="line">                col*=2;</span><br><span class="line">                sl.m=summ;</span><br><span class="line">                sl.n=sumn;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(temp==0) // input.m/input.n==summ/sumn --&gt; input.m*sumn-input.n*summ==0</span><br><span class="line">                break;</span><br><span class="line">            else&#123; // input.m/input.n&lt;summ/sumn --&gt; input.m*sumn-input.n*summ&lt;0</span><br><span class="line">                // ans+=&apos;L&apos;;</span><br><span class="line">                row++;</span><br><span class="line">                col=2*col-1;</span><br><span class="line">                sr.m=summ;</span><br><span class="line">                sr.n=sumn;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d %d\n&quot;,row,col);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="双人数字游戏"><a href="#双人数字游戏" class="headerlink" title="双人数字游戏"></a>双人数字游戏</h4><ul><li>描述：</li></ul><p>游戏规则如下</p><ul><li><p>在棋盘上有N个数字（A1 ~ AN）从左到右排列成一行</p></li><li><p>A，B两个玩家轮流进行游戏，第一回合A玩家行动，第二回合B玩家行动，依次行动直到游戏结束</p></li><li><p>每回合玩家可以选择拿走棋盘上最左边或者最右边的一个数字，其余的都不能拿</p></li><li><p>拿走的数字依次从左到右排列在自己面前</p></li><li><p>棋盘上所有数字被拿走后游戏结束</p></li><li><p>最优策略的说明：在任意局面下，玩家如果取左边的数字或者取右边的数字，最终最优得分都一样，那么只能取左边的数字</p></li></ul><p>当所有数字都被拿走后，A，B两个玩家面前都各有一个数列。</p><p>假设A玩家面前数字从左到右为X1，X2，X3…XM，则他的最终得分Sa计算方式如下（B玩家的得分计算Sb也类似，不赘述）：<br>Sa=abs(X1-0)+abs(X2-X1)+abs(X3-X2)+..+abs(XM-X(M-1))</p><p>请计算在以上的规则下，如果两个玩家都想拿到尽量多的分数，用最优策略进行游戏，计算两个人的最终得分。</p><ul><li>输入：</li></ul><p>第一行一个数字N，一半的测试用例（0&lt;N&lt;=50），一半的测试用例（0&lt;N&lt;=1000）</p><p>第二行N个数字Ai（0&lt;=Ai&lt;=50）</p><ul><li>输出：</li></ul><p>用空格隔开的两个整数Sa和Sb</p><ul><li>样例输入：</li></ul><p>4<br>1 2 3 4</p><ul><li>样例输出：</li></ul><p>7 4</p><ul><li><p>解题思路：模拟</p></li><li><p>参考程序：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int n, a, k = 1;</span><br><span class="line">deque&lt;int&gt; dq;</span><br><span class="line">int pa = 0, sa = 0, pb = 0, sb = 0;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;a);</span><br><span class="line">        dq.push_back(a);</span><br><span class="line">    &#125;</span><br><span class="line">    while (dq.size()) &#123;</span><br><span class="line">        int left = dq.front();</span><br><span class="line">        int right = dq.back();</span><br><span class="line">        if (k % 2) &#123;</span><br><span class="line">            if (abs(left - pa) &gt;= abs(right - pa)) &#123;</span><br><span class="line">                dq.pop_front();</span><br><span class="line">                sa += abs(left - pa);</span><br><span class="line">                pa = left;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                dq.pop_back();</span><br><span class="line">                sa += abs(right - pa);</span><br><span class="line">                pa = right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            if (abs(left - pb) &gt;= abs(right - pb)) &#123;</span><br><span class="line">                dq.pop_front();</span><br><span class="line">                sb += abs(left - pb);</span><br><span class="line">                pb = left;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                dq.pop_back();</span><br><span class="line">                sb += abs(right - pb);</span><br><span class="line">                pb = right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d %d\n&quot;, sa, sb);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="聊天消息排版"><a href="#聊天消息排版" class="headerlink" title="聊天消息排版"></a>聊天消息排版</h4><ul><li>描述</li></ul><p>在网游中，聊天功能是一项非常重要的功能，加上玩家可以打出游戏内置的一些表情图片，因此需要实现一个图文混排系统，如下图所示。<br>玩家在聊天框输入的是一段utf-8编码的文字，且只会包含中文、英文、中英文的标点符号和空格（不会出现换行、回车和制表符）。按照网易游戏的传统，井号（#）是作为一个转义字符，支持下面几种转义行为：</p><ol><li>#加一个数字来表示内置的表情图片，为了简化问题，我们这里只支持20个表情图片，从0开始计数，并且数字是按最长匹配原则去匹配，比如#0表示0号表情图片、#1表示1号表情图片、#19表示19号表情图片、#20则表示2号表情图片后面加数字0。需要注意的是#00表示的是0号表情图片加后面数字0。</li><li>#r表示换行，遇到以后会自动切换到下一行开始排版。</li><li>##表示显示出#这个符号</li><li>如果玩家不按规则输入错误的转义，则按照玩家的输入原样显示，比如#a、#、#、#啊</li></ol><p><img src="/2019/10/07/netease/002.jpg" alt=""></p><p>上图所示的玩家输入为：“Hello world#大家好#r欢迎大家参加#1祝大家取得好成绩”</p><p>排版的时候需要像上图一样，将文字从起始位置开始，依次显示在聊天窗囗里，一些显示规则如下所示：</p><ol><li><p>聊天窗囗的宽度固定为W像素，起始坐标为左上角，坐标为（0，0），右上角坐标为（W-1，0），坐标向右向下增长。任何文字和表情必须显示在窗口内，不能超出窗口。但是高度可以无限向下延伸。</p></li><li><p>显示的字体均为等宽字体，英文（包括英文标点符号和空格）的字体宽度统一为XE，高度统一为YE。中文（包括中文的标点符号）的字体宽度统一为XC，高度统一为YC。</p></li><li><p>每个表情图片的宽高是独立的，0号表情图片的宽度为X0，高度Y0，依次类推，19号表情图片的宽度为×19，高度为Y19。</p></li><li><p>字符（中英文以及标点符号、空格等，下同）与字符之间、字符与表情之间、表情与表情之间都需要额外保留一个PX像素的字间距。每一行第一个字符左边，以及最后一个字符右边不需要保留字间距。</p></li><li><p>当下一个字符或者表情无法在本行W宽度的像素内完整显示的话，则会强行换到下一行首开始显示。遇到#r的时候也会自动换到下一行开始显示下一个字符或表情。</p></li><li><p>在一行里出现高度不同的中英文以及表情的时候，需要将其底部对齐。</p></li><li><p>当一行里没有任何字符或表情，直接被#r换行的时候，这一行的高度算英文字体的高度。</p></li><li><p>每一行里高度最高的字符或表情，需要同上一行的的底部保留PY像素的行间距。第一行上面与最后一行下面不需要保留行间距。</p></li><li><p>最后一个字符或表情显示显示以后，它的右下角坐标则为结束坐标。也就是本题需要求解的问题。输入保证最后不会以#r结尾。</p></li></ol><ul><li>输入：</li></ul><p>每个测试输入包含1个测试用例<br>第一行为7个正整数w，XE，YE，XC，YC，BX，PY<br>第二行为40个正整数x0，Y0，X1，Y1…X19，Y19<br>第三行为长度不超过10000的十六进制编码过的玩家输入，即玩家输入的utf-8编码的数据每个字节的数字转成大写的十六进制表示，不足两位的话前面补0（同c里printf的%x格式化），然后不同字节的十六进制编码表示依次拼接起来。<br>比如Hello的十六进制编码表示为48656C6C6F。<br>前两行的各个数字含义如上文描述，其中50&lt; w &lt;10000，0&lt;其他&lt;50。</p><ul><li>输出：</li></ul><p>输出用空格隔开的两个数字，表示结束坐标</p><ul><li>输入样例：</li></ul><p>60 2 4 3 4 1 3<br>7 6 7 6 7 6 7 6 7 6 7 6 7 6 7 6 7 6 7 6 7 6 7 6 7 6 7 6 7 6 7 6 7 6 7 6 7 6 7 6<br>48656C6C6F20776F726C6423E5A4A7E5AEB6E5A5B<br>D2372E6ACA2E8BF8EE5A4A7E5AEB6E58F82E58AA0<br>E7BD91E69893E99BB7E781ABE6A0A1E59BADE68B9<br>BE881982331E7A59DE5A4A7E5AEB6E58F96E5BE97<br>E5A5BDE68890E7BBA9</p><ul><li>输出样例：</li></ul><p>38 19</p><ul><li><p>解题思路：模拟</p></li><li><p>参考程序：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="黑客行动"><a href="#黑客行动" class="headerlink" title="黑客行动"></a>黑客行动</h4><ul><li>描述：</li></ul><p>钱老板家的电子保险柜被一个神秘的安保函数y=f(x)保护，每次试图开锁时，系统都会调用安保函数代码输入一个(0,1)之间的浮点数x，如果安保函数能输出正确的y数值则可以打开保险柜，否则就会报警。黑客小军想办法获取到了一份这个安保函数的测试程序，但这个程序并不能在钱老板家的系统上直接运行，必须要重新编码一份新的代码才能使用，请帮助小军实现这个安保函数代码！<br>你可以在以下的URL下载这份测试程序的可执行文件，压缩包里包含windows、linux和macos三个平台下的可执行程序：<br><a href="http://guess.zip" target="_blank" rel="noopener">http://guess.zip</a></p><ul><li>输入：</li></ul><p>一个(0,1)的浮点数，精确到小数点后6位</p><ul><li>输出：</li></ul><p>一个浮点数，精确到小数点后6位</p><ul><li>输入样例：</li></ul><p>0.268044</p><ul><li>输出样例：</li></ul><p>2.681916</p><ul><li>备注：</li></ul><p>本题的判题标准，如果你的代码输出的结果四舍五入到小数点后5位与标准答案四舍五入到小数点后5位一致就算正确</p><ul><li><p>解题思路：</p></li><li><p>参考程序：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;窗口点击模拟&quot;&gt;&lt;a href=&quot;#窗口点击模拟&quot; class=&quot;headerlink&quot; title=&quot;窗口点击模拟&quot;&gt;&lt;/a&gt;窗口点击模拟&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;描述：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本题需要让你模拟一下在Windows系统里窗囗和鼠标点击的操作，具体如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;屏幕分辨率为3840 * 2160，左上角坐标为（0，0），右下角坐标为（3839，2159）&lt;/li&gt;
&lt;li&gt;窗口是一个矩形的形状，由左上角坐标（X，Y），和宽高（W，H），四个数字来定位。左上角坐标为（X，Y）、右下角坐标为（X+W，Y+H），其中左上角坐标一定会在屏幕范围内，其他一些部分可能会超过屏幕范围。&lt;/li&gt;
&lt;li&gt;窗囗的点击和遮挡规则同Windows，但是不考虑关闭窗囗、最大化、最小化和强制置顶的情况。即&lt;br&gt; 3.1 如果发生重叠的话，后面打开的窗口会显示在前面打开的窗口上面&lt;br&gt; 3.2 当鼠标发生一次点击的时候，需要判断点击到了哪个窗口，如果同个坐标有多个窗口，算点击到最上层的那个&lt;br&gt; 3.3 当一个窗囗被点击的时候，会浮动到最上层&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://e99net.github.io/categories/Algorithm/"/>
    
    
      <category term="Dynamic Programming" scheme="https://e99net.github.io/tags/Dynamic-Programming/"/>
    
      <category term="Simulation" scheme="https://e99net.github.io/tags/Simulation/"/>
    
  </entry>
  
  <entry>
    <title>洛谷的刷题日常之P1967</title>
    <link href="https://e99net.github.io/2019/10/06/luogu_P1967/"/>
    <id>https://e99net.github.io/2019/10/06/luogu_P1967/</id>
    <published>2019-10-06T11:02:59.655Z</published>
    <updated>2019-10-06T11:54:02.534Z</updated>
    
    <content type="html"><![CDATA[<h4 id="货车运输"><a href="#货车运输" class="headerlink" title="货车运输"></a>货车运输</h4><p>这是一道比较综合的题，非常的niubility（我不会做的题都niubility，QWQ），用到的知识包括图论、倍增、贪心、LCA、生成树、并查集。</p><ul><li>描述：</li></ul><p>A国有n座城市，编号从1到n，城市之间有m条双向道路。每一条道路对车辆都有重量限制，简称限重。现在有q辆货车在运输货物， 司机们想知道每辆车在不超过车辆限重的情况下，最多能运多重的货物。</p><a id="more"></a><ul><li>输入：</li></ul><p>第一行有两个用空格隔开的整数n和m，表示A国有n座城市和m条道路。<br>接下来的m行，每行有3个整数x,y,z，每两个整数之间用一个空格隔开，表示从x号城市到y号城市有一条限重为z的道路。<br>注意：x不等于 y，两座城市之间可能有多条道路。</p><p>接下来一行有一个整数q，表示有q辆货车需要运货。</p><p>接下来的q行，每行有两个整数x、y，用一个空格隔开，表示一辆货车需要从x城市运输货物到y城市。<br>注意：x不等于y。</p><ul><li>输出：</li></ul><p>共有q行，每行一个整数，表示对于每一辆货车，它的最大载重是多少。如果货车不能到达目的地，输出-1。</p><ul><li>输入样例：</li></ul><p>4 3<br>1 2 4<br>2 3 3<br>3 1 1<br>3<br>1 3<br>1 4<br>1 3</p><ul><li>输出样例：</li></ul><p>3<br>-1<br>3</p><ul><li><p>解题思路：</p><ul><li>贪心：因为要使得货车运的货物尽可能重，所以权值较小的边不会被走过。</li><li>图论：根据给出的数据建原始图，然后根据上一步的贪心策略建新图，构造最大生成树。</li><li>生成树：构造最大生成树可以使用Kruskal算法。</li><li>并查集：Kruskal算法可以用并查集维护节点的连通情况。</li><li>LCA：在最大生成树上求最近公共祖先，得到两个节点之间最小边权的最大值，即题中的最大载重。</li><li>倍增：树上倍增法求LCA。</li></ul></li><li><p>参考代码：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define INF 0x3f3f3f3f</span><br><span class="line"></span><br><span class="line">struct road &#123;</span><br><span class="line">    int x,y,z;</span><br><span class="line">&#125;roads[50010];//原始图</span><br><span class="line"></span><br><span class="line">struct edge &#123;</span><br><span class="line">    int to,next,w;</span><br><span class="line">&#125;edges[50010];//存储最大生成树的新图</span><br><span class="line"></span><br><span class="line">//fa数组表示并查集中的父节点，f数组表示树上的父节点，w数组表示最大载重 </span><br><span class="line">int x,y,cnt,head[10010],fa[10010],f[10010][21],deep[10010],w[10010][21],n,m,q;</span><br><span class="line">bool vis[10010];</span><br><span class="line"></span><br><span class="line">//自定义排序规则，边权大的在前面</span><br><span class="line">bool cmp(road x,road y) &#123;</span><br><span class="line">    return x.z&gt;y.z;</span><br><span class="line">&#125;</span><br><span class="line">//前向星存新图</span><br><span class="line">void addroad(int start,int end,int w) &#123;</span><br><span class="line">    edges[++cnt].next=head[start];</span><br><span class="line">    edges[cnt].to=end;</span><br><span class="line">    edges[cnt].w=w;</span><br><span class="line">    head[start]=cnt;</span><br><span class="line">&#125;</span><br><span class="line">//并查集的查找操作</span><br><span class="line">int Find(int x) &#123;</span><br><span class="line">    if(x!=fa[x]) fa[x]=Find(fa[x]);</span><br><span class="line">    return fa[x];</span><br><span class="line">&#125;</span><br><span class="line">//Kruskal算法</span><br><span class="line">void kruskal() &#123;</span><br><span class="line">    sort(roads+1,roads+m+1,cmp);</span><br><span class="line">    for(int i=1;i&lt;=n;i++) fa[i]=i;//并查集的初始化操作</span><br><span class="line">    for(int i=1;i&lt;=m;i++) &#123;</span><br><span class="line">        //并查集的合并操作</span><br><span class="line">        int a=Find(roads[i].x);</span><br><span class="line">        int b=Find(roads[i].y);</span><br><span class="line">        if(a!=b) &#123;</span><br><span class="line">            fa[a]=b;</span><br><span class="line">            //无向图，双向边</span><br><span class="line">            addroad(roads[i].x,roads[i].y,roads[i].z);</span><br><span class="line">            addroad(roads[i].y,roads[i].x,roads[i].z);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//预处理：从根节点进行搜索，求节点深度</span><br><span class="line">void dfs(int node) &#123;</span><br><span class="line">    vis[node]=true;</span><br><span class="line">    for(int i=head[node];i;i=edges[i].next) &#123;//前向星遍历</span><br><span class="line">        int to=edges[i].to;</span><br><span class="line">        if(vis[to]) continue;</span><br><span class="line">        deep[to]=deep[node]+1;//计算深度</span><br><span class="line">        f[to][0]=node;//存父节点</span><br><span class="line">        w[to][0]=edges[i].w;//存节点到父节点的权值</span><br><span class="line">        dfs(to);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//树上倍增法优化求解LCA问题</span><br><span class="line">int lca(int x,int y) &#123;</span><br><span class="line">    int a=Find(x);</span><br><span class="line">    int b=Find(y);</span><br><span class="line">    if(a!=b) return -1;//不连通输出-1</span><br><span class="line">    int ans=INF;</span><br><span class="line">    if(deep[x]&gt;deep[y]) swap(x,y);//始终使得y节点更深</span><br><span class="line">    //将y节点提到与x节点相同的深度</span><br><span class="line">    for(int i=20;i&gt;=0;i--) &#123;</span><br><span class="line">        if(deep[f[y][i]]&gt;=deep[x]) &#123;</span><br><span class="line">            ans=min(ans,w[y][i]);//更新最大载重（最小边权）</span><br><span class="line">            y=f[y][i];//修改y的位置</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(x==y) return ans;//如果位置已经相等，直接返回答案</span><br><span class="line">    //寻找公共祖先</span><br><span class="line">    for(int i=20;i&gt;=0;i--) &#123;</span><br><span class="line">        if(f[x][i]!=f[y][i]) &#123;</span><br><span class="line">            ans=min(ans,min(w[x][i],w[y][i]));//更新最大载重（最小边权）</span><br><span class="line">            x=f[x][i];//修改x的位置</span><br><span class="line">            y=f[y][i];//修改y的位置</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans=min(ans,min(w[x][0],w[y][0]));//更新x,y到公共祖先的最大载重，fa[x][0]、fa[y][0]即为公共祖先 </span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">    for(int i=1;i&lt;=m;i++) &#123;//存原始图</span><br><span class="line">        scanf(&quot;%d%d%d&quot;,&amp;roads[i].x,&amp;roads[i].y,&amp;roads[i].z);</span><br><span class="line">    &#125;</span><br><span class="line">    kruskal();</span><br><span class="line">    for(int i=1;i&lt;=n;i++) &#123;//预处理</span><br><span class="line">        if(!vis[i]) &#123;</span><br><span class="line">            deep[i]=1;</span><br><span class="line">            dfs(i);</span><br><span class="line">            f[i][0]=i;</span><br><span class="line">            w[i][0]=INF;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //LCA初始化</span><br><span class="line">    for(int i=1;i&lt;=20;i++) &#123;</span><br><span class="line">        for(int j=1;j&lt;=n;j++) &#123;</span><br><span class="line">            f[j][i]=f[f[j][i-1]][i-1];</span><br><span class="line">            w[j][i]=min(w[j][i-1],w[f[j][i-1]][i-1]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;q);</span><br><span class="line">    for(int i=1;i&lt;=q;i++) &#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;x,&amp;y);</span><br><span class="line">        printf(&quot;%d\n&quot;,lca(x,y));//O(logn)复杂度回答询问</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;货车运输&quot;&gt;&lt;a href=&quot;#货车运输&quot; class=&quot;headerlink&quot; title=&quot;货车运输&quot;&gt;&lt;/a&gt;货车运输&lt;/h4&gt;&lt;p&gt;这是一道比较综合的题，非常的niubility（我不会做的题都niubility，QWQ），用到的知识包括图论、倍增、贪心、LCA、生成树、并查集。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;描述：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A国有n座城市，编号从1到n，城市之间有m条双向道路。每一条道路对车辆都有重量限制，简称限重。现在有q辆货车在运输货物， 司机们想知道每辆车在不超过车辆限重的情况下，最多能运多重的货物。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://e99net.github.io/categories/Algorithm/"/>
    
    
      <category term="Graph theory" scheme="https://e99net.github.io/tags/Graph-theory/"/>
    
      <category term="LCA" scheme="https://e99net.github.io/tags/LCA/"/>
    
      <category term="Greedy" scheme="https://e99net.github.io/tags/Greedy/"/>
    
      <category term="Union-Find Set" scheme="https://e99net.github.io/tags/Union-Find-Set/"/>
    
      <category term="Spanning tree" scheme="https://e99net.github.io/tags/Spanning-tree/"/>
    
      <category term="Doubling" scheme="https://e99net.github.io/tags/Doubling/"/>
    
  </entry>
  
  <entry>
    <title>洛谷的刷题日常之P1147</title>
    <link href="https://e99net.github.io/2019/10/05/luogu_P1147/"/>
    <id>https://e99net.github.io/2019/10/05/luogu_P1147/</id>
    <published>2019-10-04T16:15:38.897Z</published>
    <updated>2019-10-04T16:23:29.233Z</updated>
    
    <content type="html"><![CDATA[<h4 id="连续自然数和"><a href="#连续自然数和" class="headerlink" title="连续自然数和"></a>连续自然数和</h4><ul><li>描述：</li></ul><p>对一个给定的自然数$M$，求出所有的连续的自然数段，这些连续的自然数段中的全部数之和为$M$。<br>例子：1998+1999+2000+2001+2002 = 10000，所以从1998到2002的一个自然数段为$M=10000$的一个解。</p><a id="more"></a><ul><li>输入：</li></ul><p>包含一个整数的单独一行给出M的值（$10 \le M \le 2000000$）。</p><ul><li>输出：</li></ul><p>每行两个自然数，给出一个满足条件的连续自然数段中的第一个数和最后一个数，两数之间用一个空格隔开，所有输出行的第一个按从小到大的升序排列，对于给定的输入数据，保证至少有一个解。</p><ul><li>输入样例：</li></ul><p>10000</p><ul><li>输出样例：</li></ul><p>18 142<br>297 328<br>388 412<br>1998 2002</p><ul><li><p>解题思路：前缀和+二分</p></li><li><p>参考代码:</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define ll long long</span><br><span class="line">ll sum[2000010];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    ll m;</span><br><span class="line">    scanf(&quot;%lld&quot;,&amp;m);</span><br><span class="line">    for(int i=1;i&lt;=m;i++)  sum[i]=sum[i-1]+i;</span><br><span class="line">    for(int i=1;i&lt;=m-1;i++) &#123;</span><br><span class="line">        ll l=i,r=m-1,mid;</span><br><span class="line">        while(l&lt;=r) &#123;</span><br><span class="line">            mid=(l+r)/2;</span><br><span class="line">            ll t=sum[mid]-sum[i-1];</span><br><span class="line">            if(t==m) &#123;</span><br><span class="line">                printf(&quot;%d %d\n&quot;,i,mid);</span><br><span class="line">                break;</span><br><span class="line">            &#125;else if(t&lt;m) &#123;</span><br><span class="line">                l=mid+1;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                r=mid-1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;连续自然数和&quot;&gt;&lt;a href=&quot;#连续自然数和&quot; class=&quot;headerlink&quot; title=&quot;连续自然数和&quot;&gt;&lt;/a&gt;连续自然数和&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;描述：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对一个给定的自然数$M$，求出所有的连续的自然数段，这些连续的自然数段中的全部数之和为$M$。&lt;br&gt;例子：1998+1999+2000+2001+2002 = 10000，所以从1998到2002的一个自然数段为$M=10000$的一个解。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://e99net.github.io/categories/Algorithm/"/>
    
    
      <category term="Prefix Sum" scheme="https://e99net.github.io/tags/Prefix-Sum/"/>
    
      <category term="Binary Search" scheme="https://e99net.github.io/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>记两道2020年某企业秋招的算法编程题</title>
    <link href="https://e99net.github.io/2019/09/26/tourSohu/"/>
    <id>https://e99net.github.io/2019/09/26/tourSohu/</id>
    <published>2019-09-26T12:07:20.889Z</published>
    <updated>2019-10-13T05:46:43.123Z</updated>
    
    <content type="html"><![CDATA[<h4 id="专业题1"><a href="#专业题1" class="headerlink" title="专业题1"></a>专业题1</h4><ul><li>描述：</li></ul><p>一个k（1&lt;=k&lt;=80）位的十进制整数n，我们称其为大整数。现在的问题是，请你设计一个程序，对于给出的某个大整数，找到满足条件p^3+p^2+3 * p&lt;=n的p的最大值。</p><a id="more"></a><ul><li>输入：</li></ul><p>一个大整数n。</p><ul><li>输出：</li></ul><p>一个符合条件的答案值。</p><ul><li>样例输入1：</li></ul><p>1908</p><ul><li>样例输出1：</li></ul><p>12</p><ul><li>样例输入2：</li></ul><p>8620110</p><ul><li>样例输出2：</li></ul><p>204</p><ul><li><p>解题思路：高精度+二分</p></li><li><p>参考代码:</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#偷懒的Python代码</span><br><span class="line">def f(x):</span><br><span class="line">    return x*x*x+x*x+3*x</span><br><span class="line">num=int(input())</span><br><span class="line">left=0;</span><br><span class="line">right=num;</span><br><span class="line">mid=0;</span><br><span class="line">mark=0</span><br><span class="line">while left&lt;right:</span><br><span class="line">    mid=int((left+right)/2)</span><br><span class="line">    #print(&quot;midzhi &quot;,mid)</span><br><span class="line">    fx=f(mid)</span><br><span class="line">    if fx==num:</span><br><span class="line">        ans=mid</span><br><span class="line">        mark=1</span><br><span class="line">        break</span><br><span class="line">    elif fx&gt;num:</span><br><span class="line">        right=mid </span><br><span class="line">    else:</span><br><span class="line">        left=mid+1</span><br><span class="line">if mark==0:</span><br><span class="line">    ans=left-1</span><br><span class="line">print(ans)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int MAXN = 2000;</span><br><span class="line"></span><br><span class="line">struct bign &#123;</span><br><span class="line">    int len, s[MAXN];</span><br><span class="line">    bign () &#123;</span><br><span class="line">        memset(s, 0, sizeof(s));</span><br><span class="line">        len = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    bign (int num) &#123; </span><br><span class="line">        *this = num; </span><br><span class="line">    &#125;</span><br><span class="line">    bign (const char *num) &#123; </span><br><span class="line">        *this = num;</span><br><span class="line">    &#125;</span><br><span class="line">    int operator [] (int a) &#123;</span><br><span class="line">        return s[a];</span><br><span class="line">    &#125;</span><br><span class="line">    bign operator = (const int num) &#123;</span><br><span class="line">        char s[MAXN];</span><br><span class="line">        sprintf(s, &quot;%d&quot;, num);</span><br><span class="line">        *this = s;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">    bign operator = (const char *num) &#123;</span><br><span class="line">        for(int i = 0; num[i] == &apos;0&apos;; num++) ;</span><br><span class="line">        len = strlen(num);</span><br><span class="line">        for(int i = 0; i &lt; len; i++) s[i] = num[len-i-1] - &apos;0&apos;;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">    bign operator + (const bign &amp;b) const &#123;</span><br><span class="line">        bign c;</span><br><span class="line">        c.len = 0;</span><br><span class="line">        for(int i = 0, g = 0; g || i &lt; max(len, b.len); i++) &#123;</span><br><span class="line">            int x = g;</span><br><span class="line">            if(i &lt; len) x += s[i];</span><br><span class="line">            if(i &lt; b.len) x += b.s[i];</span><br><span class="line">            c.s[c.len++] = x % 10;</span><br><span class="line">            g = x / 10;</span><br><span class="line">        &#125;</span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line">    bign operator += (const bign &amp;b) &#123;</span><br><span class="line">        *this = *this + b;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">    void clean() &#123;</span><br><span class="line">        while(len &gt; 1 &amp;&amp; !s[len-1]) len--;</span><br><span class="line">    &#125;</span><br><span class="line">    bign operator * (const bign &amp;b)</span><br><span class="line">    &#123;</span><br><span class="line">        bign c;</span><br><span class="line">        c.len = len + b.len;</span><br><span class="line">        for(int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">            for(int j = 0; j &lt; b.len; j++) &#123;</span><br><span class="line">                c.s[i+j] += s[i] * b.s[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; c.len; i++) &#123;</span><br><span class="line">            c.s[i+1] += c.s[i]/10;</span><br><span class="line">            c.s[i] %= 10;</span><br><span class="line">        &#125;</span><br><span class="line">        c.clean();</span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line">    bign operator *= (const bign &amp;b) &#123;</span><br><span class="line">        *this = *this * b;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">    bign operator - (const bign &amp;b) &#123;</span><br><span class="line">        bign c;</span><br><span class="line">        c.len = 0;</span><br><span class="line">        for(int i = 0, g = 0; i &lt; len; i++) &#123;</span><br><span class="line">            int x = s[i] - g;</span><br><span class="line">            if(i &lt; b.len) x -= b.s[i];</span><br><span class="line">            if(x &gt;= 0) g = 0;</span><br><span class="line">            else &#123;</span><br><span class="line">                g = 1;</span><br><span class="line">                x += 10;</span><br><span class="line">            &#125;</span><br><span class="line">            c.s[c.len++] = x;</span><br><span class="line">        &#125;</span><br><span class="line">        c.clean();</span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line">    bign operator -= (const bign &amp;b) &#123;</span><br><span class="line">        *this = *this - b;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">    bign operator / (const bign &amp;b) &#123;</span><br><span class="line">        bign c, f = 0;</span><br><span class="line">        for(int i = len-1; i &gt;= 0; i--) &#123;</span><br><span class="line">            f = f*10;</span><br><span class="line">            f.s[0] = s[i];</span><br><span class="line">            while(f &gt;= b) &#123;</span><br><span class="line">                f -= b;</span><br><span class="line">                c.s[i]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        c.len = len;</span><br><span class="line">        c.clean();</span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line">    bign operator /= (const bign &amp;b) &#123;</span><br><span class="line">        *this = *this / b;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">    bign operator % (const bign &amp;b) &#123;</span><br><span class="line">        bign r = *this / b;</span><br><span class="line">        r = *this - r*b;</span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br><span class="line">    bign operator %= (const bign &amp;b) &#123;</span><br><span class="line">        *this = *this % b;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">    bign operator ++() &#123;</span><br><span class="line">        return *this+=1;</span><br><span class="line">    &#125;</span><br><span class="line">    bign operator --() &#123;</span><br><span class="line">        return *this-=1;</span><br><span class="line">    &#125;</span><br><span class="line">    bool operator &lt; (const bign &amp;b) &#123;</span><br><span class="line">        if(len != b.len) return len &lt; b.len;</span><br><span class="line">        for(int i = len-1; i &gt;= 0; i--) &#123;</span><br><span class="line">            if(s[i] != b.s[i]) return s[i] &lt; b.s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    bool operator &gt; (const bign &amp;b) &#123;</span><br><span class="line">        if(len != b.len) return len &gt; b.len;</span><br><span class="line">        for(int i = len-1; i &gt;= 0; i--) &#123;</span><br><span class="line">            if(s[i] != b.s[i]) return s[i] &gt; b.s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    bool operator == (const bign &amp;b) &#123;</span><br><span class="line">        return !(*this &gt; b) &amp;&amp; !(*this &lt; b);</span><br><span class="line">    &#125;</span><br><span class="line">    bool operator != (const bign &amp;b) &#123;</span><br><span class="line">        return !(*this == b);</span><br><span class="line">    &#125;</span><br><span class="line">    bool operator &lt;= (const bign &amp;b) &#123;</span><br><span class="line">        return *this &lt; b || *this == b;</span><br><span class="line">    &#125;</span><br><span class="line">    bool operator &gt;= (const bign &amp;b) &#123;</span><br><span class="line">        return *this &gt; b || *this == b;</span><br><span class="line">    &#125;</span><br><span class="line">    bign operator !() &#123;</span><br><span class="line">        bign s=1;</span><br><span class="line">        for(bign i=1;i&lt;=*this;++i)</span><br><span class="line">            s*=i; return s;</span><br><span class="line">    &#125;</span><br><span class="line">    bign operator ^ (const bign&amp; b) &#123;</span><br><span class="line">        bign s=1;</span><br><span class="line">        for(bign i=0;i&lt;b;++i)</span><br><span class="line">            s*=*this;return s;</span><br><span class="line">    &#125;</span><br><span class="line">    bign sqrt() &#123;</span><br><span class="line">        bign c=*this/2;</span><br><span class="line">        while((c*c)&gt;*this) c/=2;</span><br><span class="line">        while((c*c)&lt;=*this) ++c;</span><br><span class="line">        return c-1;</span><br><span class="line">    &#125;</span><br><span class="line">    /*string operator *()&#123;</span><br><span class="line">        string op=&quot;Hello World&quot;;</span><br><span class="line">        return op;</span><br><span class="line">    &#125;*/</span><br><span class="line">    string str() const &#123;</span><br><span class="line">        string res = &quot;&quot;;</span><br><span class="line">        for(int i = 0; i &lt; len; i++) res = char(s[i]+&apos;0&apos;) + res;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">istream&amp; operator &gt;&gt; (istream &amp;in, bign &amp;x) &#123;</span><br><span class="line">    string s;</span><br><span class="line">    in &gt;&gt; s;</span><br><span class="line">    x = s.c_str();</span><br><span class="line">    return in;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream&amp; operator &lt;&lt; (ostream &amp;out, const bign &amp;x) &#123;</span><br><span class="line">    out &lt;&lt; x.str();</span><br><span class="line">    return out;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    // bign a,b;</span><br><span class="line">    // cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    // cout&lt;&lt;a+b;</span><br><span class="line">    bign left=0,n,mid,value,ans;</span><br><span class="line">    int mark=0;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    bign right=n;</span><br><span class="line">    while(left&lt;right) &#123;</span><br><span class="line">        mid=(left+right)/2;</span><br><span class="line">        value=mid*mid*mid+mid*mid+(bign)3*mid;</span><br><span class="line">        if(value==n) &#123;</span><br><span class="line">            ans=mid;mark=1;break;</span><br><span class="line">        &#125;else if(value&gt;n) &#123;</span><br><span class="line">            right=mid;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            left=mid+1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(mark==0) ans=left-1;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="专业题2"><a href="#专业题2" class="headerlink" title="专业题2"></a>专业题2</h4><ul><li>描述：</li></ul><p>在一个棋盘上有N个处于不同位置的棋子，每个棋子所在的位置都可以用坐标(X,Y)来表示，并且任一棋子每次可以向上、下、左、右移动单位长度。如果想让所有棋子进入一个水平线，彼此靠近，即它们最后的位置是(X,Y)、(X+1,Y)、……、(X+N,Y)，水平线上棋子的最后顺序是任意的，那么最少需要移动多少次棋子？<br>注意：两个或两个以上的棋子不能在同一时间处于同一位置。</p><ul><li>输入：</li></ul><p>第一行是一个整数N，表示棋子数，1&lt;=N&lt;=10000。后面的N行分别是每个棋子的初始位置，包含空格分开的整数x、y，-10000&lt;=x,y&lt;=10000。</p><ul><li>输出：</li></ul><p>仅有一行一个值，表示使棋子移到水平线彼此相邻位置的最小移动次数。</p><ul><li>样例输入：</li></ul><p>5<br>1 2<br>2 2<br>1 3<br>3 -2<br>3 3</p><ul><li>样例输出：</li></ul><p>8</p><ul><li><p>解题思路：中位数、贪心</p><ul><li>先将棋子移动到同一水平线，这一水平线的位置应该是它们纵坐标的中位数，可通过排序后得到中位数b，这样就能使得移动的总步数$\sum_{i=1}^{n}abs(y_i-b)$最少。</li><li>然后要让棋子彼此靠近，先对横坐标从小到大排序，假设起点是a，那么要求$\sum_{i=1}^{n}abs(a+i-x_i)$，即$\sum_{i=1}^{n}abs(a-(x_i-i))$，也即$\sum_{i=1}^{n}abs((x_i-i)-a)$。当a是$x_i-i$序列的中位数时，可使移动步数最少，同样地，这个中位数可以通过排序后得到。</li><li>将上述两步的结果相加，得到的就是最后结果了。</li></ul></li><li><p>参考代码:</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int a[10010],b[10010],n,i,x,y,ans;</span><br><span class="line">int main() &#123;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(i=1;i&lt;=n;i++) scanf(&quot;%d%d&quot;,&amp;a[i],&amp;b[i]);</span><br><span class="line">    sort(b+1,b+n+1);</span><br><span class="line">    y=b[n+1&gt;&gt;1];</span><br><span class="line">    sort(a+1,a+n+1);</span><br><span class="line">    for(i=1;i&lt;=n;i++) a[i]-=i;</span><br><span class="line">    sort(a+1,a+n+1);</span><br><span class="line">    x=a[n+1&gt;&gt;1]; </span><br><span class="line">    for(i=1;i&lt;=n;i++) ans+=abs(a[i]-x)+abs(b[i]-y);</span><br><span class="line">    printf(&quot;%d\n&quot;,ans); </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;专业题1&quot;&gt;&lt;a href=&quot;#专业题1&quot; class=&quot;headerlink&quot; title=&quot;专业题1&quot;&gt;&lt;/a&gt;专业题1&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;描述：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一个k（1&amp;lt;=k&amp;lt;=80）位的十进制整数n，我们称其为大整数。现在的问题是，请你设计一个程序，对于给出的某个大整数，找到满足条件p^3+p^2+3 * p&amp;lt;=n的p的最大值。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://e99net.github.io/categories/Algorithm/"/>
    
    
      <category term="Number theory" scheme="https://e99net.github.io/tags/Number-theory/"/>
    
      <category term="Greedy" scheme="https://e99net.github.io/tags/Greedy/"/>
    
  </entry>
  
  <entry>
    <title>洛谷的刷题日常之P1880</title>
    <link href="https://e99net.github.io/2019/09/24/luogu_P1880/"/>
    <id>https://e99net.github.io/2019/09/24/luogu_P1880/</id>
    <published>2019-09-24T03:16:45.340Z</published>
    <updated>2019-10-06T12:12:45.330Z</updated>
    
    <content type="html"><![CDATA[<h4 id="石子合并"><a href="#石子合并" class="headerlink" title="石子合并"></a>石子合并</h4><p>先看一道比luogu p1880简单的题目。</p><ul><li>描述：</li></ul><p>有n堆石子排成一排，每堆石子有一定的数量，将n堆石子合并成一堆。合并的规则是每次只能合并相邻的两堆石子，合并的花费为这两堆石子的总数。石子经过n-1次合并后成为一堆，求总的最小花费和最大花费。</p><a id="more"></a><ul><li>输入：</li></ul><p>有多组测试数据，输入到文件结束。每组测试数据的第1行有一个整数n，表示有n堆石子，n&lt;250。接下来的一行有n个数，分别表示这n堆石子的数目。每堆石子至少一颗，最多10000颗。</p><ul><li>输出：</li></ul><p>总的最小花费和最大花费。</p><ul><li>输入样例：</li></ul><p>3<br>2 4 5</p><ul><li>输出样例：</li></ul><p>17<br>20</p><ul><li><p>解题思路：区间DP</p></li><li><p>参考代码:</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int INF=1&lt;&lt;30;</span><br><span class="line">const int N=300;</span><br><span class="line">int n,sum[N];</span><br><span class="line"></span><br><span class="line">int Minval()&#123;</span><br><span class="line">    int dp[N][N]；</span><br><span class="line">    for(int i=1;i&lt;=n;i++) dp[i][i]=0;</span><br><span class="line">    for(int len=1;len&lt;n;len++)</span><br><span class="line">        for(int i=1;i&lt;=n-len;i++) &#123;</span><br><span class="line">            int j=i+len;</span><br><span class="line">            dp[i][j]=INF;</span><br><span class="line">            for(int k=i;k&lt;j;k++)</span><br><span class="line">                dp[i][j]=min(dp[i][j],dp[i][k]+dp[k+1][j]+sum[j]-sum[i-1]);</span><br><span class="line">        &#125;</span><br><span class="line">    return dp[1][n];</span><br><span class="line">&#125;</span><br><span class="line">int Maxval()&#123;</span><br><span class="line">    int dp[N][N];</span><br><span class="line">    for(int i=1;i&lt;=n;i++) dp[i][i]=0;</span><br><span class="line">    for(int len=1;len&lt;n;len++)</span><br><span class="line">        for(int i=1;i&lt;=n-len;i++) &#123;</span><br><span class="line">            int j=i+len;</span><br><span class="line">            dp[i][j]=-INF;</span><br><span class="line">            for(int k=i;k&lt;j;k++)</span><br><span class="line">                dp[i][j]=max(dp[i][j],dp[i][k]+dp[k+1][j]+sum[j]-sum[i-1]);</span><br><span class="line">        &#125;</span><br><span class="line">    return dp[1][n];</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    sum[0]=0;</span><br><span class="line">    for(int i=1;i&lt;=n;i++) &#123;</span><br><span class="line">        int x;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">        sum[i]=sum[i-1]+x;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n%d&quot;,Minval(),Maxval());</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="环形石子合并"><a href="#环形石子合并" class="headerlink" title="环形石子合并"></a>环形石子合并</h4><p>接下来就可以着手解决luogu p1880了。如果按照上面的解法解这道题，会出现“min值永远比正确答案大1”的“奇怪”现象，这是因为没有考虑环形的缘故。</p><ul><li>描述：</li></ul><p>在一个圆形操场的四周摆放N堆石子,现要将石子有次序地合并成一堆.规定每次只能选相邻的2堆合并成新的一堆，并将新的一堆的石子数，记为该次合并的得分。</p><p>试设计出1个算法,计算出将N堆石子合并成1堆的最小得分和最大得分.</p><!-- more --><ul><li>输入：</li></ul><p>数据的第1行试正整数N,1≤N≤100,表示有N堆石子.第2行有N个数,分别表示每堆石子的个数.</p><ul><li>输出：</li></ul><p>输出共2行,第1行为最小得分,第2行为最大得分.</p><ul><li>输入样例：</li></ul><p>4<br>4 5 9 4</p><ul><li>输出样例：</li></ul><p>43<br>54</p><ul><li><p>解题思路：</p><ul><li>区间DP</li><li>处理环形情况的通用套路：在任意位置把环断开成链，复制一倍接在末尾</li></ul></li><li><p>参考代码:</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int INF=1&lt;&lt;30;</span><br><span class="line">const int N=240;</span><br><span class="line">int n,sum[N],x,arr[N];</span><br><span class="line"></span><br><span class="line">int Minval()&#123;</span><br><span class="line">    int dp[N][N],ans=INF;</span><br><span class="line">    for(int i=1;i&lt;=n;i++) dp[i][i]=0;</span><br><span class="line">    for(int len=1;len&lt;n;len++)</span><br><span class="line">        for(int i=1;i&lt;=2*n-len;i++) &#123;</span><br><span class="line">            int j=i+len;</span><br><span class="line">            dp[i][j]=INF;</span><br><span class="line">            for(int k=i;k&lt;j;k++)</span><br><span class="line">                dp[i][j]=min(dp[i][j],dp[i][k]+dp[k+1][j]+sum[j]-sum[i-1]);</span><br><span class="line">        &#125;</span><br><span class="line">    for(int i=1;i&lt;=n;i++) &#123;</span><br><span class="line">        ans=ans&gt;dp[i][i+n-1]?dp[i][i+n-1]:ans;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int Maxval()&#123;</span><br><span class="line">    int dp[N][N],ans=-INF;</span><br><span class="line">    for(int i=1;i&lt;=n;i++) dp[i][i]=0;</span><br><span class="line">    for(int len=1;len&lt;n;len++)</span><br><span class="line">        for(int i=1;i&lt;=2*n-len;i++) &#123;</span><br><span class="line">            int j=i+len;</span><br><span class="line">            dp[i][j]=-INF;</span><br><span class="line">            for(int k=i;k&lt;j;k++)</span><br><span class="line">                dp[i][j]=max(dp[i][j],dp[i][k]+dp[k+1][j]+sum[j]-sum[i-1]);</span><br><span class="line">        &#125;</span><br><span class="line">    for(int i=1;i&lt;=n;i++) &#123;</span><br><span class="line">        ans=ans&lt;dp[i][i+n-1]?dp[i][i+n-1]:ans;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    sum[0]=0;</span><br><span class="line">    for(int i=1;i&lt;=n;i++) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;arr[i]);</span><br><span class="line">        arr[i+n]=arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=2*n;i++) &#123;</span><br><span class="line">        sum[i]=sum[i-1]+arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n%d&quot;,Minval(),Maxval());</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>相似题目：</li></ul><p>hdu 3506 “Monkey Party”</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;石子合并&quot;&gt;&lt;a href=&quot;#石子合并&quot; class=&quot;headerlink&quot; title=&quot;石子合并&quot;&gt;&lt;/a&gt;石子合并&lt;/h4&gt;&lt;p&gt;先看一道比luogu p1880简单的题目。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;描述：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有n堆石子排成一排，每堆石子有一定的数量，将n堆石子合并成一堆。合并的规则是每次只能合并相邻的两堆石子，合并的花费为这两堆石子的总数。石子经过n-1次合并后成为一堆，求总的最小花费和最大花费。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://e99net.github.io/categories/Algorithm/"/>
    
    
      <category term="Dynamic Programming" scheme="https://e99net.github.io/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>记三道2020年某企业秋招笔试题</title>
    <link href="https://e99net.github.io/2019/09/24/cmbcc/"/>
    <id>https://e99net.github.io/2019/09/24/cmbcc/</id>
    <published>2019-09-24T02:30:06.499Z</published>
    <updated>2019-10-12T02:12:55.595Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-n-中每位数字乘积最大的值"><a href="#1-n-中每位数字乘积最大的值" class="headerlink" title="1 ~ n 中每位数字乘积最大的值"></a>1 ~ n 中每位数字乘积最大的值</h4><ul><li>描述：</li></ul><p>99°是一位爱好爬山的小青年，他每次在爬山过程中都会遇到很多小猴子，小猴子们喜欢向他提这样一种问题：在1 ~ n中找一个数字m，使得m的各个数位乘积最大。99°不擅长回答这种问题，你能帮他写一个程序得到结果吗？</p><a id="more"></a><ul><li>样例输入1：</li></ul><p>100</p><ul><li>样例输出1：</li></ul><p>81</p><p>提示：9 * 9 = 81</p><ul><li>样例输入2：</li></ul><p>6</p><ul><li>样例输出2：</li></ul><p>6</p><ul><li><p>解题思路：贪心</p><ul><li>尽量把每一位变成9，每次都向前借一位来减</li><li>n比10小就返回n，n为0就返回1</li></ul></li><li><p>参考代码:</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define ll long long</span><br><span class="line"></span><br><span class="line">ll solve(int n) &#123;</span><br><span class="line">    if(n==0) return 1;</span><br><span class="line">    if(n&lt;10) return n;</span><br><span class="line">    else return max(solve(n/10-1)*9,solve(n/10)*(n%10));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    printf(&quot;%lld&quot;,solve(n));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="完成可能有前置任务的任务"><a href="#完成可能有前置任务的任务" class="headerlink" title="完成可能有前置任务的任务"></a>完成可能有前置任务的任务</h4><ul><li>描述：</li></ul><p>99°要完成n个任务，它制定了一个计划，计划第i天完成第i个任务，每个任务可能有前置任务，在完成第i个任务时，必须先完成它的前置任务才行。问99°要想实现它的计划，每天至少要完成多少个任务？</p><ul><li>输入：</li></ul><p>一个整数n，表示要完成的任务数，2&lt;=n&lt;=10000。接下来n行，每行第一个数字k表示该任务的前置任务数，剩下的k个数字分别表示前置任务编号。</p><ul><li>输出：</li></ul><p>n个数字，每个数字以一个空格间隔，表示每天至少完成的任务数。</p><ul><li>样例输入：</li></ul><p>3<br>1 2<br>0<br>2 1 2</p><ul><li>样例输出：</li></ul><p>2 0 1</p><p>说明：任务1有1个前置任务2，第1天要想完成任务1，需先完成任务2，所以第1天至少完成2个任务。第2天计划完成任务2，因为任务2已在第一天完成，且任务2无前置任务，所以第2天至少完成0个任务。第3天计划完成任务3，任务3有两个前置任务1、2，在前两天都已完成，所以这一天只需完成任务3，至少完成1个任务即可。</p><ul><li>样例输入：</li></ul><p>5<br>4 2 3 4 5<br>1 1<br>2 1 2<br>0<br>1 3</p><ul><li>样例输出：</li></ul><p>5 0 0 0 0</p><p>说明：第1个任务有4个前置任务2、3、4、5，要想完成1，需先完成2、3、4、5，那么第1天至少完成5个任务。接下来的第2、3、4、5天每天完成0个任务，因为在第1天已完成全部5个任务。</p><ul><li><p>解题思路：开哈希数组</p></li><li><p>参考程序：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=10005;</span><br><span class="line">int n,res[N],v[N];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int k,x;</span><br><span class="line">    memset(res,0,sizeof res);</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(int i=1;i&lt;=n;i++) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;k);</span><br><span class="line">        while(k--) &#123;</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">            if(!v[x]) &#123;</span><br><span class="line">                v[x]=1;</span><br><span class="line">                res[i]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(!v[i]) &#123;</span><br><span class="line">            res[i]++;</span><br><span class="line">            v[i]=1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=n;i++) &#123;</span><br><span class="line">        printf(&quot;%d &quot;,res[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="将数组元素变为非递减"><a href="#将数组元素变为非递减" class="headerlink" title="将数组元素变为非递减"></a>将数组元素变为非递减</h4><ul><li>描述</li></ul><p>99°给出一个包含$n$个整数的数组$a_i$，99°每次可以选择数组中若干个下标不同的元素，对选中的每个元素执行下列改变：假设选中的元素为$x$，那么就将$x$替换为$(x+1) mod m$，即选中的每个元素自增1，如果变为$m$则归零。<br>请问最少执行多少次操作，99°可以把这个数组变为一个数组元素非递减的数组。</p><ul><li>输入：</li></ul><p>第一行两个整数$n$和$m$，用一个空格分隔；<br>第二行$n$个整数$a_1$,$a_2$,…,$a_n$表示数组，每两个整数之间用一个空格分隔。<br>输入满足$1&lt;=n,m&lt;=300000;0 &lt;= a_i &lt; m$ 。</p><ul><li>输出：</li></ul><p>一个整数，表示最少需要的操作次数。</p><ul><li>输入样例1：</li></ul><p>6 8<br>7 5 6 3 2 1</p><ul><li>输出样例1：</li></ul><p>3</p><ul><li>输入样例2：</li></ul><p>3 2<br>1 0 1</p><ul><li>输出样例2：</li></ul><p>1</p><ul><li>输入样例3：</li></ul><p>3 2<br>1 0 0</p><ul><li>输出样例3：</li></ul><p>1</p><ul><li><p>解题思路：线性dp</p></li><li><p>参考程序：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define INF 0x3f3f3f3f</span><br><span class="line">const int N=300005;</span><br><span class="line">int n,m,a[N],dp[N];</span><br><span class="line"></span><br><span class="line">inline int move(int i,int j) &#123;</span><br><span class="line">    int ans=j-a[i];</span><br><span class="line">    if(a[i]&gt;j) ans+=m;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int t,ans=INF;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">    for(int i=0;i&lt;m;i++)   //初始化dp数组</span><br><span class="line">        dp[i]=move(0,i);</span><br><span class="line">    for(int i=1;i&lt;n;i++) &#123;</span><br><span class="line">        t=dp[0];</span><br><span class="line">        for(int j=0;j&lt;m;j++) &#123;</span><br><span class="line">            t=min(t,dp[j]);</span><br><span class="line">            dp[j]=max(t,move(i,j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for(int i=0;i&lt;m;i++)</span><br><span class="line">        ans=min(ans,dp[i]);</span><br><span class="line">    printf(&quot;%d\n&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-n-中每位数字乘积最大的值&quot;&gt;&lt;a href=&quot;#1-n-中每位数字乘积最大的值&quot; class=&quot;headerlink&quot; title=&quot;1 ~ n 中每位数字乘积最大的值&quot;&gt;&lt;/a&gt;1 ~ n 中每位数字乘积最大的值&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;描述：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;99°是一位爱好爬山的小青年，他每次在爬山过程中都会遇到很多小猴子，小猴子们喜欢向他提这样一种问题：在1 ~ n中找一个数字m，使得m的各个数位乘积最大。99°不擅长回答这种问题，你能帮他写一个程序得到结果吗？&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://e99net.github.io/categories/Algorithm/"/>
    
    
      <category term="Dynamic Programming" scheme="https://e99net.github.io/tags/Dynamic-Programming/"/>
    
      <category term="Greedy" scheme="https://e99net.github.io/tags/Greedy/"/>
    
  </entry>
  
  <entry>
    <title>记一道2020年某企业提前批招聘的机试题</title>
    <link href="https://e99net.github.io/2019/09/21/spdb/"/>
    <id>https://e99net.github.io/2019/09/21/spdb/</id>
    <published>2019-09-21T11:20:15.013Z</published>
    <updated>2019-09-24T02:57:39.061Z</updated>
    
    <content type="html"><![CDATA[<h4 id="字符串是否由子串拼接而成"><a href="#字符串是否由子串拼接而成" class="headerlink" title="字符串是否由子串拼接而成"></a>字符串是否由子串拼接而成</h4><ul><li>描述：</li></ul><p>给出一个非空的字符串，判断这个字符串是否由它的一个子串进行多次首尾拼接构成。<br>例如，“abcabcabc”满足条件，因为它是由“abc”首尾拼接而成，而“abcab”则不满足条件。</p><a id="more"></a><ul><li>输入：</li></ul><p>abcabcabc</p><ul><li>输出：</li></ul><p>true</p><ul><li>参考代码:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    string str;</span><br><span class="line">    cin&gt;&gt;str;</span><br><span class="line">    int n=str.size();</span><br><span class="line">    int m,flag;</span><br><span class="line">    for(int i=n/2;i&gt;=1;i--) &#123;</span><br><span class="line">        flag=0;</span><br><span class="line">        if(n%i==0)&#123;</span><br><span class="line">            m=n/i;</span><br><span class="line">            for(int j=0;j&lt;i;j++)&#123;</span><br><span class="line">                for(int k=1;k&lt;m;k++) &#123;</span><br><span class="line">                    if(str[j]!=str[j+k*i]) &#123;</span><br><span class="line">                        flag=1;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if(flag) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(!flag) &#123;</span><br><span class="line">                printf(&quot;true&quot;);</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;false&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;字符串是否由子串拼接而成&quot;&gt;&lt;a href=&quot;#字符串是否由子串拼接而成&quot; class=&quot;headerlink&quot; title=&quot;字符串是否由子串拼接而成&quot;&gt;&lt;/a&gt;字符串是否由子串拼接而成&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;描述：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;给出一个非空的字符串，判断这个字符串是否由它的一个子串进行多次首尾拼接构成。&lt;br&gt;例如，“abcabcabc”满足条件，因为它是由“abc”首尾拼接而成，而“abcab”则不满足条件。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://e99net.github.io/categories/Algorithm/"/>
    
    
      <category term="String" scheme="https://e99net.github.io/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>C++的输入与输出</title>
    <link href="https://e99net.github.io/2019/08/25/InputandOutputOfCpp/"/>
    <id>https://e99net.github.io/2019/08/25/InputandOutputOfCpp/</id>
    <published>2019-08-25T07:35:30.848Z</published>
    <updated>2019-08-25T07:38:59.207Z</updated>
    
    <content type="html"><![CDATA[<p>输入时：<br>float型输入用%f。<br>double型输入用%lf。</p><a id="more"></a><p>输出时：<br>最好是都用%f输出。<br>在G++中，double类型若用%lf输出可能会错，而在C++中，double类型用%lf输出是正确的。<br>printf() 函数中不存在 %lf。</p><p>总结：<br>输入 double 用 %lf 输出用 %f。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;输入时：&lt;br&gt;float型输入用%f。&lt;br&gt;double型输入用%lf。&lt;/p&gt;
    
    </summary>
    
      <category term="memo" scheme="https://e99net.github.io/categories/memo/"/>
    
    
      <category term="C/C++" scheme="https://e99net.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>用Git进行简单有效的项目版本控制管理</title>
    <link href="https://e99net.github.io/2019/03/02/git/"/>
    <id>https://e99net.github.io/2019/03/02/git/</id>
    <published>2019-03-02T11:50:07.770Z</published>
    <updated>2019-03-02T11:59:41.342Z</updated>
    
    <content type="html"><![CDATA[<p>Git是一个非常强大的项目版本控制管理工具，在单机环境下，可以简单有效地使用Git</p><a id="more"></a><ul><li>常用的Git命令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;[提交点名称]&quot;</span><br><span class="line">git status</span><br><span class="line">git log</span><br><span class="line">git reset --hard HEAD^^</span><br><span class="line">get reset --hard [Git生成的版本号，不必写全，无歧义即可]</span><br><span class="line">git checkout -- [文件]</span><br></pre></td></tr></table></figure></li></ul><p>以上这些命令就足以较好地管理自己的项目目录了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Git是一个非常强大的项目版本控制管理工具，在单机环境下，可以简单有效地使用Git&lt;/p&gt;
    
    </summary>
    
      <category term="memo" scheme="https://e99net.github.io/categories/memo/"/>
    
    
      <category term="Git" scheme="https://e99net.github.io/tags/Git/"/>
    
  </entry>
  
</feed>
